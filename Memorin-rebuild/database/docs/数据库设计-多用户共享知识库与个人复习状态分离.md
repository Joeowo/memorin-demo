# 多用户共享知识库与个人复习状态分离设计

> **设计目标**: 支持多用户共享知识库，同时保持个人复习状态独立  
> **核心理念**: 分离知识内容与学习状态，实现内容共享、状态隔离  
> **设计时间**: 2025-01-08  

## 🎯 问题分析

### 现有设计问题
```sql
-- ❌ 问题设计：知识点绑定用户，无法共享
CREATE TABLE knowledge_points (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,  -- 绑定用户，导致无法共享
    question TEXT,
    answer TEXT
);
```

### 实际需求场景
1. **公共知识库**: 软件工程、数学、英语等标准知识库
2. **内容共享**: 多个用户使用相同的知识点内容
3. **状态独立**: 每个用户对相同知识点有不同的复习进度
4. **权限管理**: 支持公开、私有、协作等不同权限模式

## 🏗️ 重新设计的数据模型

### 1. 知识点内容表（共享）
```sql
-- 知识点内容表：不绑定用户，支持共享
CREATE TABLE knowledge_point_contents (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    content_hash VARCHAR(64) UNIQUE NOT NULL COMMENT '内容哈希，用于去重',
    
    -- 基础内容信息
    type ENUM('fill', 'choice') NOT NULL DEFAULT 'fill',
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    explanation TEXT,
    
    -- 选择题特有字段
    choice_type ENUM('single', 'multiple'),
    options JSON,
    correct_answer VARCHAR(50),
    
    -- 元数据
    tags JSON COMMENT '标签数组',
    difficulty TINYINT DEFAULT 3 COMMENT '建议难度 1-5',
    estimated_time INT COMMENT '预估答题时间（秒）',
    source VARCHAR(100) COMMENT '来源标识',
    
    -- 创建信息
    created_by BIGINT COMMENT '创建者用户ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 统计信息
    usage_count INT DEFAULT 0 COMMENT '被使用次数',
    avg_difficulty DECIMAL(3,1) COMMENT '实际平均难度',
    
    -- 索引
    INDEX idx_created_by (created_by),
    INDEX idx_difficulty (difficulty),
    INDEX idx_type (type),
    INDEX idx_created_at (created_at),
    FULLTEXT INDEX ft_content (question, answer, explanation)
) COMMENT='知识点内容表（共享）';
```

### 2. 用户知识点状态表（个人）
```sql
-- 用户对知识点的个人学习状态
CREATE TABLE user_knowledge_point_states (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    content_id BIGINT NOT NULL COMMENT '关联知识点内容ID',
    
    -- 个人复习状态
    mastery_level TINYINT DEFAULT 1 COMMENT '掌握程度 1-5',
    review_count INT DEFAULT 0 COMMENT '复习次数',
    correct_count INT DEFAULT 0 COMMENT '正确次数',
    consecutive_correct INT DEFAULT 0 COMMENT '连续正确次数',
    
    -- SM-2算法数据
    easiness_factor DECIMAL(3,2) DEFAULT 2.5 COMMENT 'SM-2算法难度因子',
    repetition_number INT DEFAULT 0 COMMENT 'SM-2算法重复次数',
    inter_repetition_interval INT DEFAULT 1 COMMENT 'SM-2算法间隔天数',
    
    -- 时间信息
    first_learned_at TIMESTAMP NULL COMMENT '首次学习时间',
    last_reviewed_at TIMESTAMP NULL COMMENT '最后复习时间',
    next_review_at TIMESTAMP NULL COMMENT '下次复习时间',
    
    -- 个人定制
    personal_difficulty TINYINT COMMENT '个人感知难度 1-5',
    personal_tags JSON COMMENT '个人标签',
    personal_notes TEXT COMMENT '个人笔记',
    is_bookmarked BOOLEAN DEFAULT FALSE COMMENT '是否收藏',
    is_hidden BOOLEAN DEFAULT FALSE COMMENT '是否隐藏',
    
    -- 性能数据
    avg_response_time INT COMMENT '平均响应时间（秒）',
    fastest_time INT COMMENT '最快答题时间',
    slowest_time INT COMMENT '最慢答题时间',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 唯一约束和索引
    UNIQUE KEY uk_user_content (user_id, content_id),
    INDEX idx_mastery_level (mastery_level),
    INDEX idx_next_review (next_review_at),
    INDEX idx_user_mastery (user_id, mastery_level),
    INDEX idx_content_users (content_id),
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES knowledge_point_contents(id) ON DELETE CASCADE
) COMMENT='用户知识点学习状态表';
```

### 3. 重新设计的知识库关联表
```sql
-- 知识库与知识点内容的关联（支持多用户共享）
CREATE TABLE knowledge_base_content_relations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_base_id BIGINT NOT NULL,
    content_id BIGINT NOT NULL,
    
    -- 在知识库中的属性
    category VARCHAR(50),
    sort_order INT DEFAULT 0,
    weight DECIMAL(3,2) DEFAULT 1.0 COMMENT '权重',
    
    -- 管理信息
    added_by BIGINT NOT NULL COMMENT '添加者用户ID',
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 唯一约束
    UNIQUE KEY uk_base_content (knowledge_base_id, content_id),
    INDEX idx_base_category (knowledge_base_id, category),
    INDEX idx_content_bases (content_id),
    INDEX idx_added_by (added_by),
    
    FOREIGN KEY (knowledge_base_id) REFERENCES knowledge_bases(id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES knowledge_point_contents(id) ON DELETE CASCADE,
    FOREIGN KEY (added_by) REFERENCES users(id)
) COMMENT='知识库-内容关联表';
```

### 4. 重新设计的知识区关联表
```sql
-- 知识区与知识点内容的关联
CREATE TABLE knowledge_area_content_relations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_area_id BIGINT NOT NULL,
    content_id BIGINT NOT NULL,
    
    -- 关联属性
    relevance_score DECIMAL(3,2) DEFAULT 1.0,
    sort_order INT DEFAULT 0,
    
    -- 管理信息
    added_by BIGINT NOT NULL,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_area_content (knowledge_area_id, content_id),
    INDEX idx_area_relevance (knowledge_area_id, relevance_score),
    INDEX idx_content_areas (content_id),
    
    FOREIGN KEY (knowledge_area_id) REFERENCES knowledge_areas(id) ON DELETE CASCADE,
    FOREIGN KEY (content_id) REFERENCES knowledge_point_contents(id) ON DELETE CASCADE,
    FOREIGN KEY (added_by) REFERENCES users(id)
) COMMENT='知识区-内容关联表';
```

### 5. 更新的知识库表（支持共享）
```sql
-- 更新知识库表，支持共享模式
CREATE TABLE knowledge_bases (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    owner_id BIGINT NOT NULL COMMENT '所有者用户ID',
    name VARCHAR(100) NOT NULL,
    description TEXT,
    icon VARCHAR(50) DEFAULT '📚',
    color VARCHAR(20) DEFAULT '#667eea',
    category VARCHAR(50),
    
    -- 共享设置
    visibility ENUM('private', 'public', 'shared') DEFAULT 'private' COMMENT '可见性',
    is_official BOOLEAN DEFAULT FALSE COMMENT '是否官方知识库',
    allow_fork BOOLEAN DEFAULT TRUE COMMENT '允许复制',
    allow_contribute BOOLEAN DEFAULT FALSE COMMENT '允许协作',
    
    -- 统计信息
    content_count INT DEFAULT 0 COMMENT '内容数量',
    subscriber_count INT DEFAULT 0 COMMENT '订阅用户数',
    fork_count INT DEFAULT 0 COMMENT '被复制次数',
    
    sort_order INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_owner_visibility (owner_id, visibility),
    INDEX idx_public_official (visibility, is_official),
    INDEX idx_category (category),
    
    FOREIGN KEY (owner_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='知识库表（支持共享）';
```

### 6. 用户知识库订阅表
```sql
-- 用户订阅知识库的记录
CREATE TABLE user_knowledge_base_subscriptions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    knowledge_base_id BIGINT NOT NULL,
    
    -- 订阅设置
    role ENUM('viewer', 'contributor', 'admin') DEFAULT 'viewer',
    is_active BOOLEAN DEFAULT TRUE,
    
    -- 个人设置
    personal_name VARCHAR(100) COMMENT '个人重命名',
    personal_color VARCHAR(20) COMMENT '个人颜色',
    sort_order INT DEFAULT 0,
    
    subscribed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_accessed_at TIMESTAMP NULL,
    
    UNIQUE KEY uk_user_base (user_id, knowledge_base_id),
    INDEX idx_user_active (user_id, is_active),
    INDEX idx_base_subscribers (knowledge_base_id),
    INDEX idx_role (role),
    
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (knowledge_base_id) REFERENCES knowledge_bases(id) ON DELETE CASCADE
) COMMENT='用户知识库订阅表';
```

## 📊 核心查询示例

### 1. 获取用户的知识点学习状态
```sql
-- 查询用户对特定知识库的学习进度
SELECT 
    kpc.id as content_id,
    kpc.question,
    kpc.difficulty as suggested_difficulty,
    ukps.mastery_level,
    ukps.review_count,
    ukps.correct_count,
    ukps.personal_difficulty,
    ukps.next_review_at,
    CASE 
        WHEN ukps.mastery_level >= 4 THEN 'mastered'
        WHEN ukps.next_review_at <= NOW() THEN 'due'
        ELSE 'learning'
    END as status
FROM knowledge_point_contents kpc
JOIN knowledge_base_content_relations kbcr ON kpc.id = kbcr.content_id
LEFT JOIN user_knowledge_point_states ukps ON kpc.id = ukps.content_id 
    AND ukps.user_id = ?
WHERE kbcr.knowledge_base_id = ?
ORDER BY ukps.next_review_at ASC NULLS FIRST;
```

### 2. 多用户共享知识库的统计
```sql
-- 查询知识库的多用户使用统计
SELECT 
    kb.name as knowledge_base_name,
    COUNT(DISTINCT ukbs.user_id) as subscriber_count,
    COUNT(DISTINCT kbcr.content_id) as content_count,
    AVG(ukps.mastery_level) as avg_mastery_level,
    COUNT(DISTINCT CASE WHEN ukps.mastery_level >= 4 THEN ukps.user_id END) as mastered_users,
    COUNT(DISTINCT CASE WHEN ukps.next_review_at <= NOW() THEN ukps.user_id END) as users_with_due_reviews
FROM knowledge_bases kb
JOIN user_knowledge_base_subscriptions ukbs ON kb.id = ukbs.knowledge_base_id
JOIN knowledge_base_content_relations kbcr ON kb.id = kbcr.knowledge_base_id
LEFT JOIN user_knowledge_point_states ukps ON kbcr.content_id = ukps.content_id 
    AND ukbs.user_id = ukps.user_id
WHERE kb.id = ?
GROUP BY kb.id;
```

### 3. 用户个人化复习队列
```sql
-- 生成用户的个人复习队列
SELECT 
    kpc.id,
    kpc.question,
    kpc.type,
    ukps.mastery_level,
    ukps.next_review_at,
    ukps.consecutive_correct,
    kb.name as knowledge_base_name,
    ka.name as knowledge_area_name,
    -- 计算复习优先级
    CASE 
        WHEN ukps.next_review_at <= NOW() - INTERVAL 1 DAY THEN 5  -- 逾期
        WHEN ukps.next_review_at <= NOW() THEN 4                   -- 到期
        WHEN ukps.mastery_level < 3 THEN 3                         -- 未掌握
        WHEN ukps.consecutive_correct = 0 THEN 2                   -- 最近错误
        ELSE 1                                                     -- 正常
    END as priority
FROM user_knowledge_point_states ukps
JOIN knowledge_point_contents kpc ON ukps.content_id = kpc.id
JOIN knowledge_base_content_relations kbcr ON kpc.id = kbcr.content_id
JOIN knowledge_bases kb ON kbcr.knowledge_base_id = kb.id
LEFT JOIN knowledge_area_content_relations kacr ON kpc.id = kacr.content_id
LEFT JOIN knowledge_areas ka ON kacr.knowledge_area_id = ka.id
WHERE ukps.user_id = ?
    AND ukps.is_hidden = FALSE
    AND ukps.next_review_at <= NOW() + INTERVAL 1 DAY
ORDER BY priority DESC, ukps.next_review_at ASC
LIMIT 50;
```

## 🔄 数据迁移策略

### 从旧模型迁移
```sql
-- 步骤1: 迁移知识点内容（去重合并）
INSERT INTO knowledge_point_contents (
    content_hash, type, question, answer, explanation, 
    difficulty, tags, created_by, created_at
)
SELECT 
    SHA2(CONCAT(question, answer), 256) as content_hash,
    type, question, answer, explanation,
    difficulty, tags, user_id, created_at
FROM old_knowledge_points
ON DUPLICATE KEY UPDATE usage_count = usage_count + 1;

-- 步骤2: 创建用户学习状态记录
INSERT INTO user_knowledge_point_states (
    user_id, content_id, review_count, correct_count,
    last_reviewed_at, next_review_at, created_at
)
SELECT 
    okp.user_id,
    kpc.id as content_id,
    COALESCE(rd.review_count, 0),
    COALESCE(rd.correct_count, 0),
    rd.last_reviewed_at,
    rd.next_review_at,
    okp.created_at
FROM old_knowledge_points okp
JOIN knowledge_point_contents kpc ON SHA2(CONCAT(okp.question, okp.answer), 256) = kpc.content_hash
LEFT JOIN old_review_data rd ON okp.id = rd.knowledge_point_id;

-- 步骤3: 迁移知识库关联
INSERT INTO knowledge_base_content_relations (
    knowledge_base_id, content_id, added_by, added_at
)
SELECT DISTINCT
    okp.knowledge_base_id,
    kpc.id as content_id,
    okp.user_id as added_by,
    okp.created_at as added_at
FROM old_knowledge_points okp
JOIN knowledge_point_contents kpc ON SHA2(CONCAT(okp.question, okp.answer), 256) = kpc.content_hash
WHERE okp.knowledge_base_id IS NOT NULL;
```

## 🎯 应用层适配

### 1. API接口设计
```typescript
// 获取用户的知识库学习状态
interface UserKnowledgeBaseProgress {
  knowledgeBaseId: number;
  knowledgeBaseName: string;
  totalContents: number;
  learnedContents: number;
  masteredContents: number;
  dueContents: number;
  progressPercentage: number;
  estimatedReviewTime: number;
}

// GET /api/users/{userId}/knowledge-bases/progress
interface UserProgressResponse {
  success: boolean;
  data: {
    subscribedBases: UserKnowledgeBaseProgress[];
    totalProgress: {
      totalContents: number;
      masteredContents: number;
      overallProgress: number;
    };
  };
}

// 获取共享知识库信息
interface SharedKnowledgeBase {
  id: number;
  name: string;
  description: string;
  owner: UserInfo;
  visibility: 'public' | 'shared';
  isOfficial: boolean;
  contentCount: number;
  subscriberCount: number;
  avgDifficulty: number;
  categories: string[];
}

// GET /api/knowledge-bases/public
interface PublicKnowledgeBasesResponse {
  success: boolean;
  data: {
    official: SharedKnowledgeBase[];
    community: SharedKnowledgeBase[];
    recommended: SharedKnowledgeBase[];
  };
}
```

### 2. Vue组件设计
```vue
<template>
  <div class="knowledge-base-browser">
    <!-- 我的知识库 -->
    <div class="my-knowledge-bases">
      <h3>我的知识库</h3>
      <KnowledgeBaseCard
        v-for="base in myBases"
        :key="base.id"
        :knowledge-base="base"
        :progress="getUserProgress(base.id)"
        @start-review="startReview"
        @manage="manageBase"
      />
    </div>
    
    <!-- 公共知识库 -->
    <div class="public-knowledge-bases">
      <h3>公共知识库</h3>
      <SharedKnowledgeBaseCard
        v-for="base in publicBases"
        :key="base.id"
        :knowledge-base="base"
        :is-subscribed="isSubscribed(base.id)"
        @subscribe="subscribeBase"
        @preview="previewBase"
      />
    </div>
    
    <!-- 个人学习状态 -->
    <PersonalLearningStatus
      :user-id="currentUserId"
      :knowledge-bases="allSubscribedBases"
    />
  </div>
</template>

<script setup lang="ts">
interface PersonalLearningState {
  contentId: number;
  masteryLevel: number;
  reviewCount: number;
  nextReviewAt: Date;
  personalDifficulty?: number;
  personalNotes?: string;
  isBookmarked: boolean;
}

const userStates = ref<Map<number, PersonalLearningState>>(new Map());

// 获取用户对特定内容的学习状态
const getUserState = (contentId: number): PersonalLearningState | null => {
  return userStates.value.get(contentId) || null;
};

// 更新学习状态
const updateLearningState = async (contentId: number, updates: Partial<PersonalLearningState>) => {
  const currentState = getUserState(contentId);
  const newState = { ...currentState, ...updates };
  
  await api.updateUserKnowledgeState(currentUserId.value, contentId, newState);
  userStates.value.set(contentId, newState);
};
</script>
```

## ⚡ 性能优化策略

### 1. 缓存策略
```typescript
// Redis缓存设计
interface CacheKeys {
  // 用户学习状态缓存（热数据）
  userStates: `user:${userId}:states`;           // 过期时间: 1小时
  
  // 知识库内容缓存
  knowledgeBaseContents: `kb:${baseId}:contents`; // 过期时间: 24小时
  
  // 用户复习队列缓存
  userReviewQueue: `user:${userId}:review:queue`; // 过期时间: 30分钟
  
  // 公共知识库列表缓存
  publicKnowledgeBases: 'kb:public:list';         // 过期时间: 6小时
}

// 缓存更新策略
class LearningStateCache {
  async updateUserState(userId: number, contentId: number, state: PersonalLearningState) {
    // 更新数据库
    await db.updateUserKnowledgeState(userId, contentId, state);
    
    // 更新缓存
    const cacheKey = `user:${userId}:states`;
    await redis.hset(cacheKey, contentId.toString(), JSON.stringify(state));
    
    // 如果复习状态变化，清除复习队列缓存
    if (state.nextReviewAt) {
      await redis.del(`user:${userId}:review:queue`);
    }
  }
}
```

### 2. 分片策略
```sql
-- 按用户ID对学习状态表进行分片
CREATE TABLE user_knowledge_point_states_shard_0 LIKE user_knowledge_point_states;
CREATE TABLE user_knowledge_point_states_shard_1 LIKE user_knowledge_point_states;
CREATE TABLE user_knowledge_point_states_shard_2 LIKE user_knowledge_point_states;
CREATE TABLE user_knowledge_point_states_shard_3 LIKE user_knowledge_point_states;

-- 分片路由函数
DELIMITER $$
CREATE FUNCTION GetUserStateShardTable(p_user_id BIGINT) 
RETURNS VARCHAR(100)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE shard_suffix INT;
    SET shard_suffix = p_user_id % 4;
    RETURN CONCAT('user_knowledge_point_states_shard_', shard_suffix);
END$$
DELIMITER ;
```

---

**总结**: 这个重新设计的模型完美解决了多用户共享知识库的问题：

1. **内容共享**: `knowledge_point_contents`表不绑定用户，支持多用户共享相同内容
2. **状态隔离**: `user_knowledge_point_states`表记录每个用户的个人学习状态
3. **灵活权限**: 支持私有、公开、协作等多种知识库共享模式
4. **性能优化**: 通过分片和缓存策略支持大规模用户使用

现在同一个知识点可以被多个用户使用，但每个用户的复习进度、掌握程度、个人笔记等都是完全独立的！ 