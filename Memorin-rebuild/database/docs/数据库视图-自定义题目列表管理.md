# 自定义题目列表管理 - 数据库视图设计

> **配套文档**: [自定义题目列表多对多关系架构](./数据库设计-自定义题目列表多对多关系.md)  
> **目的**: 提供便捷的查询视图和管理功能  
> **设计时间**: 2025-01-08  

## 🎯 核心视图设计

### 1. 知识点完整信息视图
```sql
-- 知识点的完整关联信息视图
CREATE VIEW v_knowledge_points_full AS
SELECT 
    kp.id,
    kp.user_id,
    kp.type,
    kp.question,
    kp.answer,
    kp.explanation,
    kp.difficulty,
    kp.choice_type,
    kp.options,
    kp.correct_answer,
    kp.tags,
    kp.score,
    kp.source,
    kp.created_at,
    kp.updated_at,
    
    -- 知识库信息聚合
    GROUP_CONCAT(DISTINCT kb.name ORDER BY kpbr.is_primary DESC, kb.name) as knowledge_bases,
    GROUP_CONCAT(DISTINCT kb.id ORDER BY kpbr.is_primary DESC, kb.name) as knowledge_base_ids,
    GROUP_CONCAT(DISTINCT kpbr.category ORDER BY kpbr.is_primary DESC) as kb_categories,
    
    -- 知识区信息聚合  
    GROUP_CONCAT(DISTINCT ka.name ORDER BY kpar.is_primary DESC, ka.name) as knowledge_areas,
    GROUP_CONCAT(DISTINCT ka.id ORDER BY kpar.is_primary DESC, ka.name) as knowledge_area_ids,
    GROUP_CONCAT(DISTINCT kpar.relevance_score ORDER BY kpar.is_primary DESC) as area_relevance_scores,
    
    -- 主要归属信息
    (SELECT kb2.name FROM knowledge_bases kb2 
     JOIN knowledge_point_base_relations kpbr2 ON kb2.id = kpbr2.knowledge_base_id 
     WHERE kpbr2.knowledge_point_id = kp.id AND kpbr2.is_primary = TRUE LIMIT 1) as primary_knowledge_base,
     
    (SELECT ka2.name FROM knowledge_areas ka2 
     JOIN knowledge_point_area_relations kpar2 ON ka2.id = kpar2.knowledge_area_id 
     WHERE kpar2.knowledge_point_id = kp.id AND kpar2.is_primary = TRUE LIMIT 1) as primary_knowledge_area,
    
    -- 统计信息
    COUNT(DISTINCT kpbr.knowledge_base_id) as base_count,
    COUNT(DISTINCT kpar.knowledge_area_id) as area_count
    
FROM knowledge_points kp
LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
LEFT JOIN knowledge_bases kb ON kpbr.knowledge_base_id = kb.id
LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id
LEFT JOIN knowledge_areas ka ON kpar.knowledge_area_id = ka.id
GROUP BY kp.id;
```

### 2. 自定义题目列表详情视图
```sql
-- 自定义题目列表的详细信息视图
CREATE VIEW v_custom_question_lists_detail AS
SELECT 
    cql.id,
    cql.user_id,
    cql.name,
    cql.description,
    cql.total_count,
    cql.estimated_time,
    cql.difficulty_level,
    cql.generation_config,
    cql.source_summary,
    cql.status,
    cql.is_public,
    cql.is_template,
    cql.usage_count,
    cql.last_used_at,
    cql.created_at,
    cql.updated_at,
    
    -- 实际统计信息
    COUNT(DISTINCT qlpr.knowledge_point_id) as actual_count,
    AVG(kp.difficulty) as actual_avg_difficulty,
    COUNT(DISTINCT CASE WHEN kp.type = 'choice' THEN kp.id END) as choice_count,
    COUNT(DISTINCT CASE WHEN kp.type = 'fill' THEN kp.id END) as fill_count,
    
    -- 涉及的知识库和知识区
    COUNT(DISTINCT kpbr.knowledge_base_id) as involved_base_count,
    COUNT(DISTINCT kpar.knowledge_area_id) as involved_area_count,
    GROUP_CONCAT(DISTINCT kb.name ORDER BY kb.name) as involved_knowledge_bases,
    GROUP_CONCAT(DISTINCT ka.name ORDER BY ka.name) as involved_knowledge_areas,
    
    -- 来源分布
    COUNT(DISTINCT CASE WHEN qlpr.source_type = 'knowledge-base' THEN qlpr.source_id END) as base_source_count,
    COUNT(DISTINCT CASE WHEN qlpr.source_type = 'knowledge-area' THEN qlpr.source_id END) as area_source_count,
    COUNT(DISTINCT CASE WHEN qlpr.source_type = 'custom' THEN qlpr.knowledge_point_id END) as custom_source_count
    
FROM custom_question_lists cql
LEFT JOIN question_list_point_relations qlpr ON cql.id = qlpr.question_list_id
LEFT JOIN knowledge_points kp ON qlpr.knowledge_point_id = kp.id
LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
LEFT JOIN knowledge_bases kb ON kpbr.knowledge_base_id = kb.id
LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id
LEFT JOIN knowledge_areas ka ON kpar.knowledge_area_id = ka.id
GROUP BY cql.id;
```

### 3. 知识库知识点统计视图
```sql
-- 知识库的知识点统计视图
CREATE VIEW v_knowledge_base_stats AS
SELECT 
    kb.id,
    kb.user_id,
    kb.name,
    kb.description,
    kb.icon,
    kb.color,
    kb.category,
    kb.is_public,
    kb.sort_order,
    kb.created_at,
    kb.updated_at,
    
    -- 知识点统计
    COUNT(DISTINCT kpbr.knowledge_point_id) as total_points,
    COUNT(DISTINCT CASE WHEN kpbr.is_primary = TRUE THEN kpbr.knowledge_point_id END) as primary_points,
    COUNT(DISTINCT CASE WHEN kpbr.is_primary = FALSE THEN kpbr.knowledge_point_id END) as shared_points,
    
    -- 题型分布
    COUNT(DISTINCT CASE WHEN kp.type = 'choice' THEN kp.id END) as choice_points,
    COUNT(DISTINCT CASE WHEN kp.type = 'fill' THEN kp.id END) as fill_points,
    
    -- 难度分布
    AVG(kp.difficulty) as avg_difficulty,
    COUNT(DISTINCT CASE WHEN kp.difficulty = 1 THEN kp.id END) as difficulty_1_count,
    COUNT(DISTINCT CASE WHEN kp.difficulty = 2 THEN kp.id END) as difficulty_2_count,
    COUNT(DISTINCT CASE WHEN kp.difficulty = 3 THEN kp.id END) as difficulty_3_count,
    COUNT(DISTINCT CASE WHEN kp.difficulty = 4 THEN kp.id END) as difficulty_4_count,
    COUNT(DISTINCT CASE WHEN kp.difficulty = 5 THEN kp.id END) as difficulty_5_count,
    
    -- 相关知识区统计
    COUNT(DISTINCT kpar.knowledge_area_id) as related_area_count,
    GROUP_CONCAT(DISTINCT ka.name ORDER BY ka.name) as related_areas,
    
    -- 被引用统计
    COUNT(DISTINCT qlpr.question_list_id) as used_in_lists_count
    
FROM knowledge_bases kb
LEFT JOIN knowledge_point_base_relations kpbr ON kb.id = kpbr.knowledge_base_id
LEFT JOIN knowledge_points kp ON kpbr.knowledge_point_id = kp.id
LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id
LEFT JOIN knowledge_areas ka ON kpar.knowledge_area_id = ka.id
LEFT JOIN question_list_point_relations qlpr ON kp.id = qlpr.knowledge_point_id
GROUP BY kb.id;
```

### 4. 知识区知识点统计视图
```sql
-- 知识区的知识点统计视图
CREATE VIEW v_knowledge_area_stats AS
SELECT 
    ka.id,
    ka.user_id,
    ka.name,
    ka.description,
    ka.color,
    ka.category,
    ka.parent_area_id,
    ka.sort_order,
    ka.created_at,
    ka.updated_at,
    
    -- 层次信息
    (SELECT name FROM knowledge_areas WHERE id = ka.parent_area_id) as parent_area_name,
    (SELECT COUNT(*) FROM knowledge_areas WHERE parent_area_id = ka.id) as sub_area_count,
    
    -- 知识点统计
    COUNT(DISTINCT kpar.knowledge_point_id) as total_points,
    COUNT(DISTINCT CASE WHEN kpar.is_primary = TRUE THEN kpar.knowledge_point_id END) as primary_points,
    COUNT(DISTINCT CASE WHEN kpar.is_primary = FALSE THEN kpar.knowledge_point_id END) as shared_points,
    AVG(kpar.relevance_score) as avg_relevance,
    
    -- 题型分布
    COUNT(DISTINCT CASE WHEN kp.type = 'choice' THEN kp.id END) as choice_points,
    COUNT(DISTINCT CASE WHEN kp.type = 'fill' THEN kp.id END) as fill_points,
    
    -- 难度分布
    AVG(kp.difficulty) as avg_difficulty,
    MIN(kp.difficulty) as min_difficulty,
    MAX(kp.difficulty) as max_difficulty,
    
    -- 相关知识库统计
    COUNT(DISTINCT kpbr.knowledge_base_id) as related_base_count,
    GROUP_CONCAT(DISTINCT kb.name ORDER BY kb.name) as related_bases,
    
    -- 被引用统计
    COUNT(DISTINCT qlpr.question_list_id) as used_in_lists_count
    
FROM knowledge_areas ka
LEFT JOIN knowledge_point_area_relations kpar ON ka.id = kpar.knowledge_area_id
LEFT JOIN knowledge_points kp ON kpar.knowledge_point_id = kp.id
LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
LEFT JOIN knowledge_bases kb ON kpbr.knowledge_base_id = kb.id
LEFT JOIN question_list_point_relations qlpr ON kp.id = qlpr.knowledge_point_id
GROUP BY ka.id;
```

## 🔍 专用查询函数

### 1. 跨域知识点查询函数
```sql
-- 创建函数：根据多个条件查询知识点
DELIMITER $$
CREATE FUNCTION GetCrossDomainPoints(
    p_base_ids JSON,
    p_area_ids JSON,
    p_tags JSON,
    p_min_difficulty INT,
    p_max_difficulty INT,
    p_user_id BIGINT
) RETURNS JSON
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE result JSON;
    DECLARE query_sql TEXT;
    
    SET query_sql = '
        SELECT JSON_ARRAYAGG(
            JSON_OBJECT(
                "id", kp.id,
                "question", kp.question,
                "difficulty", kp.difficulty,
                "type", kp.type,
                "knowledge_bases", 
                    (SELECT JSON_ARRAYAGG(kb.name) 
                     FROM knowledge_point_base_relations kpbr2 
                     JOIN knowledge_bases kb ON kpbr2.knowledge_base_id = kb.id 
                     WHERE kpbr2.knowledge_point_id = kp.id),
                "knowledge_areas",
                    (SELECT JSON_ARRAYAGG(ka.name) 
                     FROM knowledge_point_area_relations kpar2 
                     JOIN knowledge_areas ka ON kpar2.knowledge_area_id = ka.id 
                     WHERE kpar2.knowledge_point_id = kp.id)
            )
        )
        FROM knowledge_points kp
        WHERE kp.user_id = ' + CAST(p_user_id AS CHAR);
    
    -- 添加知识库条件
    IF JSON_LENGTH(p_base_ids) > 0 THEN
        SET query_sql = CONCAT(query_sql, '
            AND kp.id IN (
                SELECT kpbr.knowledge_point_id 
                FROM knowledge_point_base_relations kpbr 
                WHERE kpbr.knowledge_base_id IN (', 
                REPLACE(REPLACE(JSON_EXTRACT(p_base_ids, '$'), '[', ''), ']', ''), ')
            )');
    END IF;
    
    -- 添加知识区条件
    IF JSON_LENGTH(p_area_ids) > 0 THEN
        SET query_sql = CONCAT(query_sql, '
            AND kp.id IN (
                SELECT kpar.knowledge_point_id 
                FROM knowledge_point_area_relations kpar 
                WHERE kpar.knowledge_area_id IN (', 
                REPLACE(REPLACE(JSON_EXTRACT(p_area_ids, '$'), '[', ''), ']', ''), ')
            )');
    END IF;
    
    -- 添加难度条件
    IF p_min_difficulty IS NOT NULL THEN
        SET query_sql = CONCAT(query_sql, ' AND kp.difficulty >= ', p_min_difficulty);
    END IF;
    
    IF p_max_difficulty IS NOT NULL THEN
        SET query_sql = CONCAT(query_sql, ' AND kp.difficulty <= ', p_max_difficulty);
    END IF;
    
    -- 执行查询（这里需要动态SQL支持）
    SET @sql = query_sql;
    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    RETURN result;
END$$
DELIMITER ;
```

### 2. 题目列表生成存储过程
```sql
-- 创建存储过程：生成自定义题目列表
DELIMITER $$
CREATE PROCEDURE CreateCustomQuestionList(
    IN p_user_id BIGINT,
    IN p_name VARCHAR(100),
    IN p_description TEXT,
    IN p_generation_config JSON,
    OUT p_list_id BIGINT
)
BEGIN
    DECLARE v_list_id BIGINT;
    DECLARE v_base_ids JSON;
    DECLARE v_area_ids JSON;
    DECLARE v_filters JSON;
    DECLARE v_count INT DEFAULT 20;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;
    
    START TRANSACTION;
    
    -- 解析生成配置
    SET v_base_ids = JSON_EXTRACT(p_generation_config, '$.source.params.knowledgeBaseIds');
    SET v_area_ids = JSON_EXTRACT(p_generation_config, '$.source.params.knowledgeAreaIds');
    SET v_filters = JSON_EXTRACT(p_generation_config, '$.filters');
    SET v_count = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(p_generation_config, '$.limiter.params.count')), 20);
    
    -- 创建题目列表
    INSERT INTO custom_question_lists (
        user_id, name, description, generation_config, status, total_count
    ) VALUES (
        p_user_id, p_name, p_description, p_generation_config, 'draft', v_count
    );
    
    SET v_list_id = LAST_INSERT_ID();
    
    -- 获取符合条件的知识点
    INSERT INTO question_list_point_relations (
        question_list_id, knowledge_point_id, sequence_order, 
        source_type, source_id, generation_meta
    )
    SELECT 
        v_list_id,
        kp.id,
        ROW_NUMBER() OVER (ORDER BY RAND()) as sequence_order,
        CASE 
            WHEN v_base_ids IS NOT NULL THEN 'knowledge-base'
            WHEN v_area_ids IS NOT NULL THEN 'knowledge-area'
            ELSE 'mixed'
        END as source_type,
        CASE 
            WHEN v_base_ids IS NOT NULL THEN kpbr.knowledge_base_id
            WHEN v_area_ids IS NOT NULL THEN kpar.knowledge_area_id
            ELSE NULL
        END as source_id,
        JSON_OBJECT(
            'generatedAt', NOW(),
            'difficulty', kp.difficulty,
            'type', kp.type
        ) as generation_meta
    FROM knowledge_points kp
    LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
    LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id
    WHERE kp.user_id = p_user_id
    AND (
        v_base_ids IS NULL OR kpbr.knowledge_base_id IN (
            SELECT JSON_UNQUOTE(JSON_EXTRACT(v_base_ids, CONCAT('$[', numbers.n, ']')))
            FROM (SELECT 0 n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) numbers
            WHERE JSON_UNQUOTE(JSON_EXTRACT(v_base_ids, CONCAT('$[', numbers.n, ']'))) IS NOT NULL
        )
    )
    AND (
        v_area_ids IS NULL OR kpar.knowledge_area_id IN (
            SELECT JSON_UNQUOTE(JSON_EXTRACT(v_area_ids, CONCAT('$[', numbers.n, ']')))
            FROM (SELECT 0 n UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4) numbers
            WHERE JSON_UNQUOTE(JSON_EXTRACT(v_area_ids, CONCAT('$[', numbers.n, ']'))) IS NOT NULL
        )
    )
    ORDER BY RAND()
    LIMIT v_count;
    
    -- 更新列表状态
    UPDATE custom_question_lists 
    SET status = 'active',
        total_count = (SELECT COUNT(*) FROM question_list_point_relations WHERE question_list_id = v_list_id),
        difficulty_level = (
            SELECT AVG(kp.difficulty) 
            FROM question_list_point_relations qlpr
            JOIN knowledge_points kp ON qlpr.knowledge_point_id = kp.id
            WHERE qlpr.question_list_id = v_list_id
        )
    WHERE id = v_list_id;
    
    SET p_list_id = v_list_id;
    
    COMMIT;
END$$
DELIMITER ;
```

## 📱 前端接口适配

### 1. Vue组件数据接口
```typescript
// 知识点多维度展示组件
interface KnowledgePointDetailView {
  id: number;
  question: string;
  answer: string;
  difficulty: number;
  type: 'fill' | 'choice';
  
  // 多对多关系信息
  knowledgeBases: KnowledgeBaseInfo[];
  knowledgeAreas: KnowledgeAreaInfo[];
  primaryKnowledgeBase?: KnowledgeBaseInfo;
  primaryKnowledgeArea?: KnowledgeAreaInfo;
  
  // 使用统计
  usedInLists: CustomQuestionListInfo[];
  relatedPoints: KnowledgePointInfo[];
}

interface CustomQuestionListDetailView {
  id: number;
  name: string;
  description: string;
  totalCount: number;
  actualCount: number;
  
  // 来源分析
  sourceDistribution: {
    knowledgeBases: { name: string; count: number; }[];
    knowledgeAreas: { name: string; count: number; }[];
    customPoints: number;
  };
  
  // 统计信息
  statistics: {
    avgDifficulty: number;
    typeDistribution: { choice: number; fill: number; };
    estimatedTime: number;
  };
  
  // 知识点列表
  points: KnowledgePointInList[];
}
```

### 2. API响应格式
```typescript
// GET /api/knowledge-points/{id}/full
interface KnowledgePointFullResponse {
  success: boolean;
  data: {
    point: KnowledgePointDetailView;
    relationships: {
      knowledgeBases: Array<{
        id: number;
        name: string;
        isPrimary: boolean;
        category?: string;
        addedAt: string;
      }>;
      knowledgeAreas: Array<{
        id: number;
        name: string;
        isPrimary: boolean;
        relevanceScore: number;
        addedAt: string;
      }>;
    };
    usage: {
      listsCount: number;
      totalUsage: number;
      recentLists: CustomQuestionListInfo[];
    };
  };
}

// POST /api/question-lists/generate
interface GenerateQuestionListRequest {
  name: string;
  description?: string;
  config: {
    sources: {
      knowledgeBaseIds?: number[];
      knowledgeAreaIds?: number[];
      customPointIds?: number[];
    };
    filters: {
      difficulty?: [number, number];
      tags?: string[];
      type?: 'fill' | 'choice' | 'mixed';
    };
    options: {
      count: number;
      shuffleOrder: boolean;
      includeExplanations: boolean;
    };
  };
}
```

## 🎛️ 管理界面设计

### 1. 知识点多维度管理界面
```vue
<template>
  <div class="knowledge-point-manager">
    <!-- 知识点基本信息 -->
    <KnowledgePointEditor :point="currentPoint" @save="handleSave" />
    
    <!-- 关联管理 -->
    <div class="relations-manager">
      <div class="knowledge-bases-section">
        <h3>所属知识库</h3>
        <RelationshipManager
          :items="point.knowledgeBases"
          :available="availableKnowledgeBases"
          @add="addToKnowledgeBase"
          @remove="removeFromKnowledgeBase"
          @setPrimary="setPrimaryKnowledgeBase"
        />
      </div>
      
      <div class="knowledge-areas-section">
        <h3>所属知识区</h3>
        <RelationshipManager
          :items="point.knowledgeAreas"
          :available="availableKnowledgeAreas"
          @add="addToKnowledgeArea"
          @remove="removeFromKnowledgeArea"
          @setPrimary="setPrimaryKnowledgeArea"
        />
      </div>
    </div>
    
    <!-- 使用统计 -->
    <UsageStatistics :usage="point.usage" />
  </div>
</template>
```

### 2. 自定义题目列表管理界面
```vue
<template>
  <div class="custom-list-manager">
    <!-- 列表配置 -->
    <QuestionListConfig 
      v-model="listConfig"
      :knowledge-bases="knowledgeBases"
      :knowledge-areas="knowledgeAreas"
    />
    
    <!-- 预览和调整 -->
    <div class="list-preview">
      <QuestionListPreview
        :questions="previewQuestions"
        :statistics="previewStats"
        @reorder="handleReorder"
        @remove="handleRemove"
        @regenerate="handleRegenerate"
      />
    </div>
    
    <!-- 保存和分享 -->
    <div class="list-actions">
      <button @click="saveList">保存列表</button>
      <button @click="shareList">分享列表</button>
      <button @click="exportList">导出列表</button>
    </div>
  </div>
</template>
```

---

**总结**: 这个视图设计提供了完整的多对多关系管理界面，支持灵活的知识点组织、跨域查询和自定义题目列表配置。通过专用的视图和存储过程，大大简化了复杂查询的开发工作，提升了系统的易用性和性能。 