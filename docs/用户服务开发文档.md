# 用户服务开发文档

## 服务概述

### 服务基本信息
- **服务名称**: User Service (用户服务)
- **服务端口**: 8001
- **数据库**: user_db
- **主要职责**: 用户认证、权限管理、用户信息管理

### 当前Demo分析

#### Demo中的用户模块现状
当前静态网页demo **没有用户概念**，特点如下：
- **无用户系统**: 数据直接存储在浏览器LocalStorage
- **无身份认证**: 用户无需登录即可使用所有功能
- **单用户模式**: 一个浏览器对应一个用户的数据
- **数据隔离**: 不同浏览器之间数据完全隔离
- **即开即用**: 打开页面即可开始学习，用户体验极佳

#### Demo的用户体验优势
1. **零门槛**: 无需注册登录
2. **隐私性**: 数据完全本地化
3. **速度快**: 无网络请求延迟
4. **离线可用**: 完全离线工作

### 微服务架构下的用户需求

#### 新增的用户功能需求
1. **多设备同步**: 用户可以在不同设备上访问相同数据
2. **数据安全**: 用户数据在云端安全存储
3. **社交功能**: 支持知识库分享和社区功能
4. **个性化配置**: 用户偏好设置云端同步
5. **数据备份**: 防止数据丢失

#### 保持的用户体验
1. **快速启动**: 支持游客模式，可先试用再注册
2. **离线支持**: 核心功能支持离线使用
3. **数据迁移**: 支持从本地数据迁移到云端

## 技术架构设计

### 技术栈选择
```yaml
框架: Spring Boot 2.7.x
安全: Spring Security + JWT
数据库: MySQL 8.0
缓存: Redis 6.0
ORM: MyBatis-Plus
文档: Swagger/OpenAPI 3
测试: JUnit 5 + Testcontainers
```

### 项目结构
```
user-service/
├── src/main/java/com/memorin/user/
│   ├── UserServiceApplication.java           # 启动类
│   ├── config/                               # 配置类
│   │   ├── SecurityConfig.java              # 安全配置
│   │   ├── RedisConfig.java                 # Redis配置
│   │   └── JwtConfig.java                   # JWT配置
│   ├── controller/                           # 控制器层
│   │   ├── AuthController.java              # 认证控制器
│   │   ├── UserController.java              # 用户控制器
│   │   └── SettingsController.java          # 设置控制器
│   ├── service/                              # 服务层
│   │   ├── UserService.java                 # 用户服务接口
│   │   ├── AuthService.java                 # 认证服务接口
│   │   ├── impl/                            # 服务实现
│   │   │   ├── UserServiceImpl.java
│   │   │   └── AuthServiceImpl.java
│   │   ├── entity/                               # 实体类
│   │   │   ├── User.java                        # 用户实体
│   │   │   ├── UserSettings.java               # 用户设置实体
│   │   │   └── LoginLog.java                   # 登录日志实体
│   │   ├── dto/                                  # 数据传输对象
│   │   │   ├── request/                         # 请求DTO
│   │   │   │   ├── LoginRequest.java
│   │   │   │   ├── RegisterRequest.java
│   │   │   │   └── UpdateUserRequest.java
│   │   │   └── response/                        # 响应DTO
│   │   │       ├── LoginResponse.java
│   │   │       ├── UserInfoResponse.java
│   │   │       └── UserSettingsResponse.java
│   │   ├── mapper/                               # 数据访问层
│   │   │   ├── UserMapper.java
│   │   │   ├── UserSettingsMapper.java
│   │   │   └── LoginLogMapper.java
│   │   ├── security/                             # 安全相关
│   │   │   ├── JwtTokenProvider.java            # JWT工具类
│   │   │   ├── JwtAuthenticationFilter.java     # JWT过滤器
│   │   │   └── CustomUserDetailsService.java   # 用户详情服务
│   │   ├── exception/                            # 异常处理
│   │   │   ├── UserException.java               # 用户异常
│   │   │   └── GlobalExceptionHandler.java     # 全局异常处理
│   │   └── utils/                                # 工具类
│   │       ├── PasswordEncoder.java             # 密码加密
│   │       └── ValidationUtils.java             # 验证工具
│   ├── src/main/resources/
│   │   ├── application.yml                       # 应用配置
│   │   ├── application-dev.yml                  # 开发环境配置
│   │   ├── application-prod.yml                 # 生产环境配置
│   │   └── mapper/                              # MyBatis映射文件
│   │       ├── UserMapper.xml
│   │       ├── UserSettingsMapper.xml
│   │       └── LoginLogMapper.xml
│   └── src/test/                                 # 测试代码
│       └── java/com/memorin/user/
│           ├── controller/                       # 控制器测试
│           ├── service/                         # 服务层测试
│           └── integration/                     # 集成测试
```

## 数据库设计

### 数据表设计

#### 1. 用户基本信息表 (users)
```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    username VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    email VARCHAR(100) NOT NULL UNIQUE COMMENT '邮箱',
    password VARCHAR(255) NOT NULL COMMENT '密码(加密)',
    avatar VARCHAR(500) DEFAULT NULL COMMENT '头像URL',
    nickname VARCHAR(50) DEFAULT NULL COMMENT '昵称',
    phone VARCHAR(20) DEFAULT NULL COMMENT '手机号',
    gender TINYINT DEFAULT 0 COMMENT '性别(0:未知,1:男,2:女)',
    birthday DATE DEFAULT NULL COMMENT '生日',
    status TINYINT DEFAULT 1 COMMENT '状态(0:禁用,1:正常)',
    last_login_time DATETIME DEFAULT NULL COMMENT '最后登录时间',
    last_login_ip VARCHAR(50) DEFAULT NULL COMMENT '最后登录IP',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户基本信息表';
```

#### 2. 用户设置表 (user_settings)
```sql
CREATE TABLE user_settings (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '设置ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    theme VARCHAR(20) DEFAULT 'light' COMMENT '主题(light/dark)',
    language VARCHAR(10) DEFAULT 'zh-CN' COMMENT '语言',
    timezone VARCHAR(50) DEFAULT 'Asia/Shanghai' COMMENT '时区',
    notification_email TINYINT DEFAULT 1 COMMENT '邮件通知(0:关闭,1:开启)',
    notification_push TINYINT DEFAULT 1 COMMENT '推送通知(0:关闭,1:开启)',
    auto_review_reminder TINYINT DEFAULT 1 COMMENT '自动复习提醒(0:关闭,1:开启)',
    daily_goal INT DEFAULT 20 COMMENT '每日学习目标(分钟)',
    review_mode VARCHAR(20) DEFAULT 'smart' COMMENT '默认复习模式',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    UNIQUE KEY uk_user_id (user_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户设置表';
```

#### 3. 登录日志表 (login_logs)
```sql
CREATE TABLE login_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '日志ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    login_type VARCHAR(20) NOT NULL COMMENT '登录类型(password/oauth)',
    login_ip VARCHAR(50) NOT NULL COMMENT '登录IP',
    user_agent VARCHAR(500) DEFAULT NULL COMMENT '用户代理',
    device_info VARCHAR(200) DEFAULT NULL COMMENT '设备信息',
    login_status TINYINT NOT NULL COMMENT '登录状态(0:失败,1:成功)',
    error_message VARCHAR(500) DEFAULT NULL COMMENT '错误信息',
    login_time DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '登录时间',
    
    INDEX idx_user_id (user_id),
    INDEX idx_login_time (login_time),
    INDEX idx_login_status (login_status),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='登录日志表';
```

#### 4. JWT Token黑名单表 (jwt_blacklist)
```sql
CREATE TABLE jwt_blacklist (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
    token_hash VARCHAR(64) NOT NULL UNIQUE COMMENT 'Token哈希值',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    expired_at DATETIME NOT NULL COMMENT 'Token过期时间',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '加入黑名单时间',
    
    INDEX idx_token_hash (token_hash),
    INDEX idx_user_id (user_id),
    INDEX idx_expired_at (expired_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='JWT Token黑名单表';
```

## 核心功能实现

### 1. 用户认证模块

#### JWT配置类
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authConfig) throws Exception {
        return authConfig.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors().and().csrf().disable()
            .exceptionHandling()
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .and()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/health/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .anyRequest().authenticated()
            );

        http.addFilterBefore(
            new JwtAuthenticationFilter(jwtTokenProvider),
            UsernamePasswordAuthenticationFilter.class
        );

        return http.build();
    }
}
```

#### JWT Token提供者
```java
@Component
public class JwtTokenProvider {

    @Value("${jwt.secret}")
    private String jwtSecret;

    @Value("${jwt.expiration}")
    private int jwtExpirationInMs;

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public String generateToken(UserDetails userDetails) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(userDetails.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }

    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }

    public boolean validateToken(String authToken) {
        try {
            // 检查Token是否在黑名单中
            String tokenHash = DigestUtils.sha256Hex(authToken);
            Boolean isBlacklisted = redisTemplate.hasKey("jwt:blacklist:" + tokenHash);
            if (Boolean.TRUE.equals(isBlacklisted)) {
                return false;
            }

            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
            return true;
        } catch (SignatureException | MalformedJwtException | 
                 ExpiredJwtException | UnsupportedJwtException | 
                 IllegalArgumentException ex) {
            return false;
        }
    }

    public void invalidateToken(String token) {
        String tokenHash = DigestUtils.sha256Hex(token);
        // 将Token添加到Redis黑名单，过期时间为Token的剩余有效期
        long expiration = getExpirationFromToken(token).getTime() - System.currentTimeMillis();
        if (expiration > 0) {
            redisTemplate.opsForValue().set(
                "jwt:blacklist:" + tokenHash, 
                "invalid", 
                expiration, 
                TimeUnit.MILLISECONDS
            );
        }
    }

    private Date getExpirationFromToken(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody();
        return claims.getExpiration();
    }
}
```

### 2. 认证控制器

#### AuthController实现
```java
@RestController
@RequestMapping("/api/auth")
@Api(tags = "认证管理")
@Validated
public class AuthController {

    @Autowired
    private AuthService authService;

    @PostMapping("/register")
    @ApiOperation("用户注册")
    public Result<UserInfoResponse> register(
            @Valid @RequestBody RegisterRequest request) {
        UserInfoResponse response = authService.register(request);
        return Result.success(response);
    }

    @PostMapping("/login")
    @ApiOperation("用户登录")
    public Result<LoginResponse> login(
            @Valid @RequestBody LoginRequest request,
            HttpServletRequest httpRequest) {
        String userAgent = httpRequest.getHeader("User-Agent");
        String clientIp = getClientIp(httpRequest);
        
        LoginResponse response = authService.login(request, userAgent, clientIp);
        return Result.success(response);
    }

    @PostMapping("/logout")
    @ApiOperation("用户登出")
    public Result<Void> logout(HttpServletRequest request) {
        String token = extractToken(request);
        authService.logout(token);
        return Result.success();
    }

    @PostMapping("/refresh")
    @ApiOperation("刷新Token")
    public Result<LoginResponse> refreshToken(
            @RequestParam("refreshToken") String refreshToken) {
        LoginResponse response = authService.refreshToken(refreshToken);
        return Result.success(response);
    }

    @GetMapping("/verify")
    @ApiOperation("验证Token")
    public Result<UserInfoResponse> verifyToken() {
        UserInfoResponse response = authService.getCurrentUser();
        return Result.success(response);
    }

    @PostMapping("/forgot-password")
    @ApiOperation("忘记密码")
    public Result<Void> forgotPassword(@RequestParam("email") String email) {
        authService.sendPasswordResetEmail(email);
        return Result.success();
    }

    @PostMapping("/reset-password")
    @ApiOperation("重置密码")
    public Result<Void> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
        authService.resetPassword(request);
        return Result.success();
    }

    private String extractToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }

    private String getClientIp(HttpServletRequest request) {
        String xip = request.getHeader("X-Real-IP");
        String xff = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xip) && !"unKnown".equalsIgnoreCase(xip)) {
            return xip;
        }
        if (StringUtils.hasText(xff) && !"unKnown".equalsIgnoreCase(xff)) {
            int index = xff.indexOf(",");
            if (index != -1) {
                return xff.substring(0, index);
            } else {
                return xff;
            }
        }
        return request.getRemoteAddr();
    }
}
```

### 3. 用户服务实现

#### AuthService接口和实现
```java
@Service
@Transactional
public class AuthServiceImpl implements AuthService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private LoginLogMapper loginLogMapper;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtTokenProvider jwtTokenProvider;

    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public UserInfoResponse register(RegisterRequest request) {
        // 检查用户名和邮箱是否已存在
        if (userMapper.existsByUsername(request.getUsername())) {
            throw new UserException("用户名已存在");
        }
        if (userMapper.existsByEmail(request.getEmail())) {
            throw new UserException("邮箱已被注册");
        }

        // 创建新用户
        User user = new User();
        user.setUsername(request.getUsername());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));
        user.setNickname(request.getNickname());
        user.setStatus(1); // 正常状态

        userMapper.insert(user);

        // 创建默认用户设置
        createDefaultUserSettings(user.getId());

        // 发送注册成功事件
        publishUserRegisteredEvent(user);

        return convertToUserInfoResponse(user);
    }

    @Override
    public LoginResponse login(LoginRequest request, String userAgent, String clientIp) {
        try {
            // 认证用户凭据
            Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    request.getUsername(),
                    request.getPassword()
                )
            );

            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
            User user = userMapper.findByUsername(request.getUsername());

            // 生成JWT Token
            String accessToken = jwtTokenProvider.generateToken(userDetails);
            String refreshToken = generateRefreshToken(user.getId());

            // 更新用户最后登录信息
            user.setLastLoginTime(LocalDateTime.now());
            user.setLastLoginIp(clientIp);
            userMapper.updateById(user);

            // 记录登录日志
            recordLoginLog(user.getId(), "password", clientIp, userAgent, true, null);

            // 构建响应
            LoginResponse response = new LoginResponse();
            response.setAccessToken(accessToken);
            response.setRefreshToken(refreshToken);
            response.setTokenType("Bearer");
            response.setExpiresIn(jwtTokenProvider.getExpirationTime());
            response.setUserInfo(convertToUserInfoResponse(user));

            return response;

        } catch (BadCredentialsException e) {
            // 记录失败的登录尝试
            User user = userMapper.findByUsername(request.getUsername());
            if (user != null) {
                recordLoginLog(user.getId(), "password", clientIp, userAgent, false, "密码错误");
            }
            throw new UserException("用户名或密码错误");
        }
    }

    @Override
    public void logout(String token) {
        if (StringUtils.hasText(token)) {
            // 将Token加入黑名单
            jwtTokenProvider.invalidateToken(token);
            
            // 清除相关的缓存
            String username = jwtTokenProvider.getUsernameFromToken(token);
            redisTemplate.delete("user:session:" + username);
        }
    }

    @Override
    public LoginResponse refreshToken(String refreshToken) {
        // 验证refresh token
        String userId = validateRefreshToken(refreshToken);
        if (userId == null) {
            throw new UserException("无效的刷新令牌");
        }

        User user = userMapper.selectById(Long.parseLong(userId));
        if (user == null || user.getStatus() != 1) {
            throw new UserException("用户不存在或已被禁用");
        }

        // 生成新的access token
        UserDetails userDetails = createUserDetails(user);
        String newAccessToken = jwtTokenProvider.generateToken(userDetails);
        String newRefreshToken = generateRefreshToken(user.getId());

        // 构建响应
        LoginResponse response = new LoginResponse();
        response.setAccessToken(newAccessToken);
        response.setRefreshToken(newRefreshToken);
        response.setTokenType("Bearer");
        response.setExpiresIn(jwtTokenProvider.getExpirationTime());
        response.setUserInfo(convertToUserInfoResponse(user));

        return response;
    }

    private void createDefaultUserSettings(Long userId) {
        UserSettings settings = new UserSettings();
        settings.setUserId(userId);
        settings.setTheme("light");
        settings.setLanguage("zh-CN");
        settings.setTimezone("Asia/Shanghai");
        settings.setNotificationEmail(true);
        settings.setNotificationPush(true);
        settings.setAutoReviewReminder(true);
        settings.setDailyGoal(20);
        settings.setReviewMode("smart");

        userSettingsMapper.insert(settings);
    }

    private String generateRefreshToken(Long userId) {
        String refreshToken = UUID.randomUUID().toString();
        // 将refresh token存储到Redis，有效期30天
        redisTemplate.opsForValue().set(
            "refresh_token:" + refreshToken,
            userId.toString(),
            30,
            TimeUnit.DAYS
        );
        return refreshToken;
    }

    private String validateRefreshToken(String refreshToken) {
        Object userId = redisTemplate.opsForValue().get("refresh_token:" + refreshToken);
        return userId != null ? userId.toString() : null;
    }

    private void recordLoginLog(Long userId, String loginType, String loginIp, 
                               String userAgent, boolean success, String errorMessage) {
        LoginLog loginLog = new LoginLog();
        loginLog.setUserId(userId);
        loginLog.setLoginType(loginType);
        loginLog.setLoginIp(loginIp);
        loginLog.setUserAgent(userAgent);
        loginLog.setLoginStatus(success ? 1 : 0);
        loginLog.setErrorMessage(errorMessage);
        loginLog.setLoginTime(LocalDateTime.now());

        loginLogMapper.insert(loginLog);
    }

    private void publishUserRegisteredEvent(User user) {
        // TODO: 发送用户注册事件到消息队列
        // 其他服务可以监听此事件来初始化用户相关数据
    }
}
```

## API接口文档

### 认证相关接口

#### 1. 用户注册
```http
POST /api/auth/register
Content-Type: application/json

{
    "username": "testuser",
    "email": "test@example.com",
    "password": "Password123!",
    "nickname": "测试用户"
}

Response 200:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "username": "testuser",
        "email": "test@example.com",
        "nickname": "测试用户",
        "avatar": null,
        "createdAt": "2024-01-01T10:00:00"
    }
}
```

#### 2. 用户登录
```http
POST /api/auth/login
Content-Type: application/json

{
    "username": "testuser",
    "password": "Password123!"
}

Response 200:
{
    "code": 200,
    "message": "success",
    "data": {
        "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
        "refreshToken": "550e8400-e29b-41d4-a716-446655440000",
        "tokenType": "Bearer",
        "expiresIn": 86400,
        "userInfo": {
            "id": 1,
            "username": "testuser",
            "email": "test@example.com",
            "nickname": "测试用户",
            "avatar": null
        }
    }
}
```

#### 3. 用户登出
```http
POST /api/auth/logout
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...

Response 200:
{
    "code": 200,
    "message": "success",
    "data": null
}
```

### 用户信息相关接口

#### 1. 获取当前用户信息
```http
GET /api/user/profile
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...

Response 200:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "username": "testuser",
        "email": "test@example.com",
        "nickname": "测试用户",
        "avatar": "http://example.com/avatar.jpg",
        "phone": null,
        "gender": 0,
        "birthday": null,
        "lastLoginTime": "2024-01-01T10:00:00",
        "createdAt": "2024-01-01T09:00:00"
    }
}
```

#### 2. 更新用户信息
```http
PUT /api/user/profile
Authorization: Bearer eyJhbGciOiJIUzUxMiJ9...
Content-Type: application/json

{
    "nickname": "新昵称",
    "avatar": "http://example.com/new-avatar.jpg",
    "phone": "13800138000",
    "gender": 1,
    "birthday": "1990-01-01"
}

Response 200:
{
    "code": 200,
    "message": "success",
    "data": {
        "id": 1,
        "username": "testuser",
        "email": "test@example.com",
        "nickname": "新昵称",
        "avatar": "http://example.com/new-avatar.jpg",
        "phone": "13800138000",
        "gender": 1,
        "birthday": "1990-01-01"
    }
}
```

## 配置文件

### application.yml
```yaml
server:
  port: 8001

spring:
  application:
    name: user-service
  
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/user_db?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: password
    
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-wait: -1ms
        max-idle: 10
        min-idle: 0

  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        service: ${spring.application.name}

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      logic-delete-field: deleted
      logic-delete-value: 1
      logic-not-delete-value: 0

jwt:
  secret: memorinSecretKeyForJwtToken2024
  expiration: 86400000  # 24小时

logging:
  level:
    com.memorin.user: debug
  pattern:
    console: '%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n'
```

## 测试策略

### 单元测试
```java
@SpringBootTest
@Testcontainers
class AuthServiceTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("test_user_db")
            .withUsername("test")
            .withPassword("test");

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:6.0-alpine")
            .withExposedPorts(6379);

    @Autowired
    private AuthService authService;

    @Test
    void testUserRegistration() {
        RegisterRequest request = new RegisterRequest();
        request.setUsername("testuser");
        request.setEmail("test@example.com");
        request.setPassword("Password123!");
        request.setNickname("测试用户");

        UserInfoResponse response = authService.register(request);

        assertThat(response.getUsername()).isEqualTo("testuser");
        assertThat(response.getEmail()).isEqualTo("test@example.com");
    }

    @Test
    void testUserLogin() {
        // 先注册用户
        RegisterRequest registerRequest = new RegisterRequest();
        registerRequest.setUsername("logintest");
        registerRequest.setEmail("logintest@example.com");
        registerRequest.setPassword("Password123!");
        authService.register(registerRequest);

        // 测试登录
        LoginRequest loginRequest = new LoginRequest();
        loginRequest.setUsername("logintest");
        loginRequest.setPassword("Password123!");

        LoginResponse response = authService.login(loginRequest, "test-agent", "127.0.0.1");

        assertThat(response.getAccessToken()).isNotNull();
        assertThat(response.getRefreshToken()).isNotNull();
        assertThat(response.getUserInfo().getUsername()).isEqualTo("logintest");
    }
}
```

## 部署说明

### Docker配置
```dockerfile
FROM openjdk:11-jre-slim

WORKDIR /app

COPY target/user-service-1.0.0.jar app.jar

EXPOSE 8001

ENV TZ=Asia/Shanghai
ENV JAVA_OPTS="-Xmx512m -Xms256m"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### Docker Compose配置
```yaml
version: '3.8'
services:
  user-service:
    build: .
    ports:
      - "8001:8001"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/user_db
      - SPRING_REDIS_HOST=redis
      - SPRING_CLOUD_NACOS_DISCOVERY_SERVER_ADDR=nacos:8848
    depends_on:
      - mysql
      - redis
      - nacos
    networks:
      - memorin-network

networks:
  memorin-network:
    external: true
```

## 与前端集成

### 前端适配方案

#### 1. 认证状态管理
前端需要新增用户认证状态管理：
```javascript
// 原来的无状态设计
class App {
    init() {
        this.loadDashboard();
    }
}

// 新增认证状态管理
class App {
    constructor() {
        this.authManager = new AuthManager();
        this.isAuthenticated = false;
        this.currentUser = null;
    }

    async init() {
        // 检查是否已登录
        await this.authManager.checkAuthStatus();
        if (this.authManager.isAuthenticated()) {
            this.isAuthenticated = true;
            this.currentUser = this.authManager.getCurrentUser();
            this.loadDashboard();
        } else {
            this.showLoginPage();
        }
    }
}
```

#### 2. API适配层
```javascript
class ApiService {
    constructor() {
        this.baseURL = '/api';
        this.authManager = new AuthManager();
    }

    async request(url, options = {}) {
        const token = this.authManager.getAccessToken();
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };

        if (token) {
            headers.Authorization = `Bearer ${token}`;
        }

        const response = await fetch(`${this.baseURL}${url}`, {
            ...options,
            headers
        });

        if (response.status === 401) {
            // Token过期，尝试刷新
            const refreshed = await this.authManager.refreshToken();
            if (refreshed) {
                // 重新发送请求
                headers.Authorization = `Bearer ${this.authManager.getAccessToken()}`;
                return fetch(`${this.baseURL}${url}`, { ...options, headers });
            } else {
                // 刷新失败，跳转到登录页
                this.authManager.logout();
                window.location.href = '/login';
            }
        }

        return response;
    }
}
```

这个用户服务开发文档提供了从当前demo分析到微服务实现的完整方案。您觉得这个设计如何？是否需要调整某些部分？接下来我可以继续编写知识库服务的开发文档。 