# 答题服务开发文档

## 服务概述

### 服务基本信息
- **服务名称**: Practice Service (答题服务)
- **服务端口**: 8003
- **数据库**: practice_db
- **主要职责**: 题目生成、复习计划、答题记录、SM-2算法实现

### 当前Demo分析

#### Demo中的答题模块实现

**1. 核心组件分析**
```javascript
// 题目列表生成器 - 策略模式实现
class QuestionListGenerator {
    strategies = new Map([
        ['smart-review', this.smartReviewStrategy.bind(this)],
        ['random-selection', this.randomSelectionStrategy.bind(this)],
        ['knowledge-base-review', this.knowledgeBaseReviewStrategy.bind(this)],
        ['knowledge-area-review', this.knowledgeAreaReviewStrategy.bind(this)],
        ['weak-points-review', this.weakPointsReviewStrategy.bind(this)],
        ['mistake-review', this.mistakeReviewStrategy.bind(this)]
    ]);

    // 智能复习策略
    smartReviewStrategy(knowledge) {
        const now = Date.now();
        return knowledge
            .filter(k => new Date(k.nextReview) <= now)
            .sort((a, b) => this.calculateUrgency(b) - this.calculateUrgency(a));
    }
}

// 复习管理器 - 答题会话管理
class ReviewManager {
    constructor() {
        this.currentSession = null;
        this.questionGenerator = new QuestionListGenerator();
    }

    startReview(config) {
        const questions = this.questionGenerator.generateQuestions(config);
        this.currentSession = {
            id: generateId(),
            questions,
            currentIndex: 0,
            startTime: Date.now(),
            answers: []
        };
        return this.currentSession;
    }
}
```

**2. SM-2算法实现**
```javascript
function calculateNextReview(easeFactor, interval, userRating) {
    // userRating: 1=错误, 2=模糊, 3=正确, 4=较好, 5=很好
    
    if (userRating === 1) {
        // 错误：重置间隔，降低难易度因子
        return {
            interval: 1,
            easeFactor: Math.max(1.3, easeFactor - 0.3),
            nextReview: Date.now() + 6 * 60 * 60 * 1000 // 6小时后
        };
    } else if (userRating === 2) {
        // 模糊：缩短间隔
        return {
            interval: Math.max(1, Math.round(interval * 0.6)),
            easeFactor: Math.max(1.3, easeFactor - 0.1)
        };
    } else {
        // 正确：延长间隔
        const bonus = userRating >= 4 ? 0.2 : 0.15;
        const newEaseFactor = Math.min(3.0, easeFactor + bonus);
        const newInterval = calculateNewInterval(interval, newEaseFactor);
        
        return {
            interval: newInterval,
            easeFactor: newEaseFactor,
            nextReview: Date.now() + newInterval * 24 * 60 * 60 * 1000
        };
    }
}
```

**3. 答题界面特性**
- **键盘快捷键**: Space查看答案，Enter下一题，← →导航
- **用户答案输入**: 支持自由文本输入
- **笔记功能**: 答题时可查看和编辑笔记
- **自主评分**: 1-5分评分系统
- **进度显示**: 实时显示答题进度

## 技术架构设计

### 技术栈选择
```yaml
框架: Spring Boot 2.7.x
数据库: MySQL 8.0
缓存: Redis 6.0
ORM: MyBatis-Plus
任务调度: Quartz
消息队列: RabbitMQ
测试: JUnit 5 + Testcontainers
```

### 数据库设计

#### 1. 复习会话表 (review_sessions)
```sql
CREATE TABLE review_sessions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '会话ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    session_type VARCHAR(50) NOT NULL COMMENT '会话类型',
    base_id BIGINT COMMENT '知识库ID',
    area_id BIGINT COMMENT '知识区ID',
    config JSON COMMENT '会话配置',
    total_questions INT DEFAULT 0 COMMENT '总题目数',
    answered_questions INT DEFAULT 0 COMMENT '已答题目数',
    correct_answers INT DEFAULT 0 COMMENT '正确答案数',
    total_time INT DEFAULT 0 COMMENT '总用时(秒)',
    status TINYINT DEFAULT 1 COMMENT '状态(1:进行中,2:已完成,3:已暂停)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    completed_at DATETIME COMMENT '完成时间',
    
    INDEX idx_user_id (user_id),
    INDEX idx_session_type (session_type),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (user_id) REFERENCES user_db.users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='复习会话表';
```

#### 2. 复习记录表 (review_records)
```sql
CREATE TABLE review_records (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '记录ID',
    session_id BIGINT NOT NULL COMMENT '会话ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    knowledge_id BIGINT NOT NULL COMMENT '知识点ID',
    question_text TEXT NOT NULL COMMENT '题目内容',
    correct_answer TEXT NOT NULL COMMENT '正确答案',
    user_answer TEXT COMMENT '用户答案',
    is_correct TINYINT COMMENT '是否正确(0:错误,1:正确)',
    rating TINYINT COMMENT '用户评分(1-5)',
    time_spent INT DEFAULT 0 COMMENT '用时(秒)',
    review_type VARCHAR(20) DEFAULT 'normal' COMMENT '复习类型',
    difficulty_before INT COMMENT '复习前难度',
    difficulty_after INT COMMENT '复习后难度',
    ease_factor_before DECIMAL(3,2) COMMENT '复习前难易度因子',
    ease_factor_after DECIMAL(3,2) COMMENT '复习后难易度因子',
    interval_before INT COMMENT '复习前间隔',
    interval_after INT COMMENT '复习后间隔',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_session_id (session_id),
    INDEX idx_user_id (user_id),
    INDEX idx_knowledge_id (knowledge_id),
    INDEX idx_is_correct (is_correct),
    INDEX idx_rating (rating),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (session_id) REFERENCES review_sessions(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user_db.users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='复习记录表';
```

#### 3. 复习计划表 (review_plans)
```sql
CREATE TABLE review_plans (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '计划ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    knowledge_id BIGINT NOT NULL COMMENT '知识点ID',
    current_interval INT DEFAULT 1 COMMENT '当前间隔(天)',
    ease_factor DECIMAL(3,2) DEFAULT 2.50 COMMENT '难易度因子',
    review_count INT DEFAULT 0 COMMENT '复习次数',
    correct_count INT DEFAULT 0 COMMENT '正确次数',
    last_reviewed DATETIME COMMENT '最后复习时间',
    next_review DATETIME COMMENT '下次复习时间',
    priority_score DECIMAL(5,2) DEFAULT 50.0 COMMENT '优先级评分',
    status TINYINT DEFAULT 1 COMMENT '状态(1:正常,2:暂停,3:完成)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_knowledge (user_id, knowledge_id),
    INDEX idx_user_id (user_id),
    INDEX idx_knowledge_id (knowledge_id),
    INDEX idx_next_review (next_review),
    INDEX idx_priority_score (priority_score),
    INDEX idx_status (status),
    FOREIGN KEY (user_id) REFERENCES user_db.users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='复习计划表';
```

#### 4. 题目生成历史表 (question_generation_history)
```sql
CREATE TABLE question_generation_history (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    session_id BIGINT NOT NULL COMMENT '会话ID',
    strategy_type VARCHAR(50) NOT NULL COMMENT '生成策略',
    filter_config JSON COMMENT '筛选配置',
    sort_config JSON COMMENT '排序配置',
    limit_config JSON COMMENT '限制配置',
    generated_count INT DEFAULT 0 COMMENT '生成题目数',
    execution_time INT DEFAULT 0 COMMENT '执行时间(毫秒)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_session_id (session_id),
    INDEX idx_strategy_type (strategy_type),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (user_id) REFERENCES user_db.users(id) ON DELETE CASCADE,
    FOREIGN KEY (session_id) REFERENCES review_sessions(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='题目生成历史表';
```

## 核心功能实现

### 1. 题目生成服务

```java
@Service
public class QuestionGeneratorService {

    @Autowired
    private KnowledgeServiceClient knowledgeServiceClient;
    
    @Autowired
    private ReviewPlanMapper reviewPlanMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 题目生成策略枚举
     */
    public enum GenerationStrategy {
        SMART_REVIEW,           // 智能复习
        RANDOM_SELECTION,       // 随机选择
        KNOWLEDGE_BASE_REVIEW,  // 知识库复习
        KNOWLEDGE_AREA_REVIEW,  // 知识区复习
        WEAK_POINTS_REVIEW,     // 弱项强化
        MISTAKE_REVIEW         // 错题复习
    }

    public List<QuestionDTO> generateQuestions(QuestionGenerationRequest request, Long userId) {
        // 记录生成开始时间
        long startTime = System.currentTimeMillis();
        
        try {
            List<QuestionDTO> questions = executeGenerationStrategy(request, userId);
            
            // 记录生成历史
            recordGenerationHistory(request, userId, questions.size(), 
                (int)(System.currentTimeMillis() - startTime));
            
            return questions;
        } catch (Exception e) {
            log.error("题目生成失败: userId={}, request={}", userId, request, e);
            throw new BusinessException("题目生成失败: " + e.getMessage());
        }
    }

    private List<QuestionDTO> executeGenerationStrategy(QuestionGenerationRequest request, Long userId) {
        GenerationStrategy strategy = GenerationStrategy.valueOf(request.getStrategy().toUpperCase());
        
        switch (strategy) {
            case SMART_REVIEW:
                return generateSmartReviewQuestions(request, userId);
            case RANDOM_SELECTION:
                return generateRandomQuestions(request, userId);
            case KNOWLEDGE_BASE_REVIEW:
                return generateKnowledgeBaseQuestions(request, userId);
            case KNOWLEDGE_AREA_REVIEW:
                return generateKnowledgeAreaQuestions(request, userId);
            case WEAK_POINTS_REVIEW:
                return generateWeakPointsQuestions(request, userId);
            case MISTAKE_REVIEW:
                return generateMistakeQuestions(request, userId);
            default:
                throw new BusinessException("不支持的生成策略: " + strategy);
        }
    }

    /**
     * 智能复习题目生成
     */
    private List<QuestionDTO> generateSmartReviewQuestions(QuestionGenerationRequest request, Long userId) {
        // 获取需要复习的知识点
        List<ReviewPlan> duePlans = reviewPlanMapper.selectList(
            Wrappers.<ReviewPlan>lambdaQuery()
                .eq(ReviewPlan::getUserId, userId)
                .le(ReviewPlan::getNextReview, LocalDateTime.now())
                .eq(ReviewPlan::getStatus, 1)
                .orderByDesc(ReviewPlan::getPriorityScore)
                .orderByAsc(ReviewPlan::getNextReview)
                .last("LIMIT " + request.getLimit())
        );

        if (duePlans.isEmpty()) {
            // 没有到期的知识点，选择优先级最高的
            duePlans = reviewPlanMapper.selectList(
                Wrappers.<ReviewPlan>lambdaQuery()
                    .eq(ReviewPlan::getUserId, userId)
                    .eq(ReviewPlan::getStatus, 1)
                    .orderByDesc(ReviewPlan::getPriorityScore)
                    .last("LIMIT " + Math.min(request.getLimit(), 10))
            );
        }

        List<Long> knowledgeIds = duePlans.stream()
            .map(ReviewPlan::getKnowledgeId)
            .collect(Collectors.toList());

        // 从知识库服务获取知识点详情
        List<KnowledgePointVO> knowledgePoints = knowledgeServiceClient.getKnowledgePointsByIds(knowledgeIds);
        
        // 转换为题目DTO
        return knowledgePoints.stream()
            .map(this::convertToQuestionDTO)
            .collect(Collectors.toList());
    }

    /**
     * 弱项强化题目生成
     */
    private List<QuestionDTO> generateWeakPointsQuestions(QuestionGenerationRequest request, Long userId) {
        // 查找正确率最低的知识点
        List<ReviewPlan> weakPlans = reviewPlanMapper.selectList(
            Wrappers.<ReviewPlan>lambdaQuery()
                .eq(ReviewPlan::getUserId, userId)
                .eq(ReviewPlan::getStatus, 1)
                .gt(ReviewPlan::getReviewCount, 0)
                .orderByAsc(ReviewPlan::getCorrectCount / ReviewPlan::getReviewCount) // 正确率升序
                .orderByDesc(ReviewPlan::getReviewCount) // 复习次数降序
                .last("LIMIT " + request.getLimit())
        );

        // 如果弱项不足，补充优先级高的题目
        if (weakPlans.size() < request.getLimit()) {
            int remaining = request.getLimit() - weakPlans.size();
            List<Long> excludeIds = weakPlans.stream()
                .map(ReviewPlan::getKnowledgeId)
                .collect(Collectors.toList());
                
            List<ReviewPlan> additionalPlans = reviewPlanMapper.selectList(
                Wrappers.<ReviewPlan>lambdaQuery()
                    .eq(ReviewPlan::getUserId, userId)
                    .eq(ReviewPlan::getStatus, 1)
                    .notIn(!excludeIds.isEmpty(), ReviewPlan::getKnowledgeId, excludeIds)
                    .orderByDesc(ReviewPlan::getPriorityScore)
                    .last("LIMIT " + remaining)
            );
            
            weakPlans.addAll(additionalPlans);
        }

        List<Long> knowledgeIds = weakPlans.stream()
            .map(ReviewPlan::getKnowledgeId)
            .collect(Collectors.toList());

        List<KnowledgePointVO> knowledgePoints = knowledgeServiceClient.getKnowledgePointsByIds(knowledgeIds);
        
        return knowledgePoints.stream()
            .map(this::convertToQuestionDTO)
            .collect(Collectors.toList());
    }

    /**
     * 计算知识点复习紧急程度
     */
    private double calculateUrgency(ReviewPlan plan) {
        if (plan.getNextReview() == null) {
            return 100.0; // 从未复习过的最紧急
        }

        long overdueDays = ChronoUnit.DAYS.between(plan.getNextReview(), LocalDateTime.now());
        double correctRate = plan.getReviewCount() > 0 ? 
            (double) plan.getCorrectCount() / plan.getReviewCount() : 0.5;
        
        // 紧急程度 = 逾期天数权重 + 错误率权重 + 优先级权重
        double urgency = Math.max(0, overdueDays) * 0.4 +  // 逾期天数
                        (1 - correctRate) * 0.4 +           // 错误率
                        (plan.getPriorityScore() / 100.0) * 0.2; // 优先级
        
        return urgency;
    }
}
```

### 2. 复习会话管理服务

```java
@Service
@Transactional
public class ReviewSessionService {

    @Autowired
    private ReviewSessionMapper reviewSessionMapper;
    
    @Autowired
    private ReviewRecordMapper reviewRecordMapper;
    
    @Autowired
    private QuestionGeneratorService questionGeneratorService;
    
    @Autowired
    private SM2AlgorithmService sm2AlgorithmService;

    public ReviewSessionVO startReviewSession(StartReviewRequest request, Long userId) {
        // 检查是否有进行中的会话
        ReviewSession activeSession = reviewSessionMapper.selectOne(
            Wrappers.<ReviewSession>lambdaQuery()
                .eq(ReviewSession::getUserId, userId)
                .eq(ReviewSession::getStatus, 1) // 进行中
        );

        if (activeSession != null) {
            throw new BusinessException("存在进行中的复习会话，请先完成或暂停");
        }

        // 生成题目
        QuestionGenerationRequest genRequest = new QuestionGenerationRequest();
        genRequest.setStrategy(request.getSessionType());
        genRequest.setBaseId(request.getBaseId());
        genRequest.setAreaId(request.getAreaId());
        genRequest.setLimit(request.getQuestionCount());
        
        List<QuestionDTO> questions = questionGeneratorService.generateQuestions(genRequest, userId);
        
        if (questions.isEmpty()) {
            throw new BusinessException("没有可用的题目，请先添加知识点");
        }

        // 创建会话
        ReviewSession session = new ReviewSession();
        session.setUserId(userId);
        session.setSessionType(request.getSessionType());
        session.setBaseId(request.getBaseId());
        session.setAreaId(request.getAreaId());
        session.setConfig(request.getConfig());
        session.setTotalQuestions(questions.size());
        session.setStatus(1); // 进行中

        reviewSessionMapper.insert(session);

        // 将题目缓存到Redis
        String questionsKey = "review:session:" + session.getId() + ":questions";
        redisTemplate.opsForValue().set(questionsKey, questions, 2, TimeUnit.HOURS);

        // 构建响应
        ReviewSessionVO sessionVO = convertToVO(session);
        sessionVO.setQuestions(questions);
        sessionVO.setCurrentIndex(0);

        return sessionVO;
    }

    public void submitAnswer(SubmitAnswerRequest request, Long userId) {
        // 验证会话
        ReviewSession session = reviewSessionMapper.selectById(request.getSessionId());
        if (session == null || !session.getUserId().equals(userId)) {
            throw new BusinessException("无效的复习会话");
        }

        if (session.getStatus() != 1) {
            throw new BusinessException("会话已结束");
        }

        // 获取题目信息
        String questionsKey = "review:session:" + session.getId() + ":questions";
        List<QuestionDTO> questions = (List<QuestionDTO>) redisTemplate.opsForValue().get(questionsKey);
        
        if (questions == null || request.getQuestionIndex() >= questions.size()) {
            throw new BusinessException("无效的题目索引");
        }

        QuestionDTO question = questions.get(request.getQuestionIndex());

        // 创建复习记录
        ReviewRecord record = new ReviewRecord();
        record.setSessionId(session.getId());
        record.setUserId(userId);
        record.setKnowledgeId(question.getKnowledgeId());
        record.setQuestionText(question.getQuestion());
        record.setCorrectAnswer(question.getAnswer());
        record.setUserAnswer(request.getUserAnswer());
        record.setIsCorrect(request.getIsCorrect());
        record.setRating(request.getRating());
        record.setTimeSpent(request.getTimeSpent());

        reviewRecordMapper.insert(record);

        // 更新会话统计
        session.setAnsweredQuestions(session.getAnsweredQuestions() + 1);
        if (request.getIsCorrect()) {
            session.setCorrectAnswers(session.getCorrectAnswers() + 1);
        }
        session.setTotalTime(session.getTotalTime() + request.getTimeSpent());

        // 检查是否完成
        if (session.getAnsweredQuestions() >= session.getTotalQuestions()) {
            session.setStatus(2); // 已完成
            session.setCompletedAt(LocalDateTime.now());
        }

        reviewSessionMapper.updateById(session);

        // 更新复习计划（异步处理）
        updateReviewPlanAsync(userId, question.getKnowledgeId(), request.getRating(), record);

        // 发送答题完成事件
        publishAnswerSubmittedEvent(record);
    }

    @Async
    public void updateReviewPlanAsync(Long userId, Long knowledgeId, Integer rating, ReviewRecord record) {
        try {
            sm2AlgorithmService.updateReviewPlan(userId, knowledgeId, rating, record);
        } catch (Exception e) {
            log.error("更新复习计划失败: userId={}, knowledgeId={}", userId, knowledgeId, e);
        }
    }

    public ReviewSessionStatsVO getSessionStats(Long sessionId, Long userId) {
        ReviewSession session = reviewSessionMapper.selectById(sessionId);
        if (session == null || !session.getUserId().equals(userId)) {
            throw new BusinessException("无效的复习会话");
        }

        // 获取详细统计
        List<ReviewRecord> records = reviewRecordMapper.selectList(
            Wrappers.<ReviewRecord>lambdaQuery()
                .eq(ReviewRecord::getSessionId, sessionId)
                .orderByAsc(ReviewRecord::getCreatedAt)
        );

        ReviewSessionStatsVO stats = new ReviewSessionStatsVO();
        stats.setSessionId(sessionId);
        stats.setTotalQuestions(session.getTotalQuestions());
        stats.setAnsweredQuestions(session.getAnsweredQuestions());
        stats.setCorrectAnswers(session.getCorrectAnswers());
        stats.setTotalTime(session.getTotalTime());
        
        if (session.getAnsweredQuestions() > 0) {
            stats.setAccuracy((double) session.getCorrectAnswers() / session.getAnsweredQuestions());
            stats.setAvgTimePerQuestion((double) session.getTotalTime() / session.getAnsweredQuestions());
        }

        // 计算评分分布
        Map<Integer, Long> ratingDistribution = records.stream()
            .filter(r -> r.getRating() != null)
            .collect(Collectors.groupingBy(ReviewRecord::getRating, Collectors.counting()));
        stats.setRatingDistribution(ratingDistribution);

        return stats;
    }
}
```

### 3. SM-2算法服务

```java
@Service
public class SM2AlgorithmService {

    @Autowired
    private ReviewPlanMapper reviewPlanMapper;

    /**
     * 根据用户评分更新复习计划
     */
    public void updateReviewPlan(Long userId, Long knowledgeId, Integer rating, ReviewRecord record) {
        ReviewPlan plan = reviewPlanMapper.selectOne(
            Wrappers.<ReviewPlan>lambdaQuery()
                .eq(ReviewPlan::getUserId, userId)
                .eq(ReviewPlan::getKnowledgeId, knowledgeId)
        );

        if (plan == null) {
            // 创建新的复习计划
            plan = createInitialReviewPlan(userId, knowledgeId);
        }

        // 记录更新前的状态
        record.setDifficultyBefore(plan.getCurrentInterval());
        record.setEaseFactor Before(plan.getEaseFactor());
        record.setIntervalBefore(plan.getCurrentInterval());

        // 计算新的复习参数
        SM2Result result = calculateSM2(plan.getEaseFactor(), plan.getCurrentInterval(), rating);

        // 更新复习计划
        plan.setCurrentInterval(result.getNewInterval());
        plan.setEaseFactor(result.getNewEaseFactor());
        plan.setReviewCount(plan.getReviewCount() + 1);
        
        if (rating >= 3) { // 3分及以上算正确
            plan.setCorrectCount(plan.getCorrectCount() + 1);
        }
        
        plan.setLastReviewed(LocalDateTime.now());
        plan.setNextReview(LocalDateTime.now().plusDays(result.getNewInterval()));
        plan.setPriorityScore(calculatePriorityScore(plan));

        reviewPlanMapper.updateById(plan);

        // 记录更新后的状态
        record.setDifficultyAfter(plan.getCurrentInterval());
        record.setEaseFactorAfter(plan.getEaseFactor());
        record.setIntervalAfter(plan.getCurrentInterval());
        
        reviewRecordMapper.updateById(record);
    }

    /**
     * SM-2算法核心计算
     */
    private SM2Result calculateSM2(BigDecimal currentEaseFactor, Integer currentInterval, Integer rating) {
        if (rating == null || rating < 1 || rating > 5) {
            throw new IllegalArgumentException("评分必须在1-5之间");
        }

        BigDecimal easeFactor = currentEaseFactor;
        int interval = currentInterval;

        if (rating == 1) {
            // 评分1（错误）：重置间隔，大幅降低难易度因子
            interval = 1;
            easeFactor = easeFactor.subtract(new BigDecimal("0.30"));
        } else if (rating == 2) {
            // 评分2（模糊）：缩短间隔，轻微降低难易度因子
            interval = Math.max(1, (int) Math.round(interval * 0.6));
            easeFactor = easeFactor.subtract(new BigDecimal("0.10"));
        } else {
            // 评分3-5（正确）：延长间隔，提高难易度因子
            BigDecimal bonus = rating >= 4 ? new BigDecimal("0.20") : new BigDecimal("0.15");
            easeFactor = easeFactor.add(bonus);
            
            if (interval == 1) {
                interval = rating >= 4 ? 4 : 3;
            } else if (interval < 6) {
                interval = rating >= 4 ? 8 : 6;
            } else {
                interval = (int) Math.round(interval * easeFactor.doubleValue());
            }
        }

        // 限制难易度因子范围
        if (easeFactor.compareTo(new BigDecimal("1.30")) < 0) {
            easeFactor = new BigDecimal("1.30");
        } else if (easeFactor.compareTo(new BigDecimal("3.00")) > 0) {
            easeFactor = new BigDecimal("3.00");
        }

        return new SM2Result(interval, easeFactor);
    }

    /**
     * 计算优先级评分
     */
    private BigDecimal calculatePriorityScore(ReviewPlan plan) {
        // 基础分数
        BigDecimal score = new BigDecimal("50.0");

        // 正确率影响（正确率低的优先级高）
        if (plan.getReviewCount() > 0) {
            double correctRate = (double) plan.getCorrectCount() / plan.getReviewCount();
            score = score.add(new BigDecimal((1 - correctRate) * 30));
        }

        // 复习频次影响（复习次数少的优先级高）
        if (plan.getReviewCount() < 3) {
            score = score.add(new BigDecimal("20.0"));
        } else if (plan.getReviewCount() < 6) {
            score = score.add(new BigDecimal("10.0"));
        }

        // 时间间隔影响（间隔短的优先级高）
        if (plan.getCurrentInterval() <= 1) {
            score = score.add(new BigDecimal("15.0"));
        } else if (plan.getCurrentInterval() <= 3) {
            score = score.add(new BigDecimal("10.0"));
        }

        return score;
    }

    @Data
    @AllArgsConstructor
    public static class SM2Result {
        private Integer newInterval;
        private BigDecimal newEaseFactor;
    }
}
```

## API接口设计

### 1. 开始复习会话
```http
POST /api/practice/sessions/start
Authorization: Bearer {token}
Content-Type: application/json

{
    "sessionType": "smart-review",
    "baseId": 1,
    "areaId": null,
    "questionCount": 20,
    "config": {
        "timeLimit": 1800,
        "showAnswer": true,
        "enableNote": true
    }
}

Response:
{
    "code": 200,
    "data": {
        "sessionId": 12345,
        "sessionType": "smart-review",
        "totalQuestions": 20,
        "currentIndex": 0,
        "questions": [
            {
                "knowledgeId": 1,
                "question": "什么是国防？",
                "answer": "国防是指国家为防备...",
                "explanation": "国防是国家安全的基石...",
                "userNote": "这是重点概念",
                "userScore": 4
            }
        ],
        "startTime": "2024-01-01T10:00:00"
    }
}
```

### 2. 提交答案
```http
POST /api/practice/sessions/{sessionId}/submit
Authorization: Bearer {token}
Content-Type: application/json

{
    "questionIndex": 0,
    "userAnswer": "国防是国家为防备和抵抗侵略...",
    "isCorrect": true,
    "rating": 4,
    "timeSpent": 30
}

Response:
{
    "code": 200,
    "data": {
        "success": true,
        "nextQuestionIndex": 1,
        "sessionCompleted": false
    }
}
```

### 3. 获取会话统计
```http
GET /api/practice/sessions/{sessionId}/stats
Authorization: Bearer {token}

Response:
{
    "code": 200,
    "data": {
        "sessionId": 12345,
        "totalQuestions": 20,
        "answeredQuestions": 15,
        "correctAnswers": 12,
        "accuracy": 0.8,
        "totalTime": 450,
        "avgTimePerQuestion": 30.0,
        "ratingDistribution": {
            "1": 1,
            "2": 2,
            "3": 5,
            "4": 4,
            "5": 3
        }
    }
}
```

## 与前端集成方案

### 1. 答题会话管理适配
```javascript
// 原来的ReviewManager
class ReviewManager {
    startReview(config) {
        const questions = this.questionGenerator.generateQuestions(config);
        this.currentSession = {
            questions,
            currentIndex: 0,
            startTime: Date.now()
        };
        return this.currentSession;
    }
}

// 新的API适配
class PracticeApiService {
    async startReviewSession(config) {
        const response = await this.apiService.request('/practice/sessions/start', {
            method: 'POST',
            body: JSON.stringify(config)
        });
        return response.data;
    }

    async submitAnswer(sessionId, answerData) {
        const response = await this.apiService.request(`/practice/sessions/${sessionId}/submit`, {
            method: 'POST',
            body: JSON.stringify(answerData)
        });
        return response.data;
    }
}
```

### 2. 实时同步机制
```javascript
class ReviewSessionManager {
    constructor() {
        this.currentSession = null;
        this.apiService = new PracticeApiService();
        this.autoSaveInterval = null;
    }

    async startSession(config) {
        this.currentSession = await this.apiService.startReviewSession(config);
        this.startAutoSave();
        return this.currentSession;
    }

    async submitAnswer(answerData) {
        const result = await this.apiService.submitAnswer(
            this.currentSession.sessionId, 
            answerData
        );
        
        // 更新本地状态
        this.currentSession.currentIndex = result.nextQuestionIndex;
        
        if (result.sessionCompleted) {
            this.stopAutoSave();
            this.showSessionStats();
        }
        
        return result;
    }

    startAutoSave() {
        this.autoSaveInterval = setInterval(async () => {
            await this.saveSessionProgress();
        }, 30000); // 30秒自动保存
    }
}
```

这个答题服务文档详细分析了当前demo的实现并设计了完整的微服务方案，保持了原有的用户体验同时增加了企业级的功能特性。您觉得这个设计如何？接下来我可以继续编写错题本服务和其他服务的开发文档。 