# 知识库服务开发文档

## 服务概述

### 服务基本信息
- **服务名称**: Knowledge Service (知识库服务)
- **服务端口**: 8002
- **数据库**: knowledge_db
- **主要职责**: 知识库管理、知识区管理、知识点CRUD、笔记和评分管理

### 当前Demo分析

#### Demo中的知识库模块实现
当前静态网页demo的知识库模块特点：

**1. 数据结构分析**
```javascript
// 三级知识库结构
knowledgeBase: {
    id: 'military_theory_base',
    name: '军事理论知识库',
    description: '军事理论课程完整知识体系',
    areas: [
        {
            id: 'area_defense',
            name: '第一章 国防概述',
            description: '国防基础理论、法规制度...',
            color: '#667eea',
            knowledgePoints: [
                {
                    id: 'mil_0001',
                    question: '什么是国防？',
                    answer: '国防是指国家为防备和抵抗侵略...',
                    explanation: '国防是国家安全的基石...',
                    note: '',        // 用户笔记
                    score: null,     // 用户评分
                    tags: ['国防', '基本概念'],
                    difficulty: 2,
                    areaId: 'area_defense',
                    baseId: 'military_theory_base'
                }
            ]
        }
    ]
}
```

**2. 核心功能实现**
- **知识点管理**: `KnowledgeManager`类实现三级层次展示
- **数据存储**: 基于LocalStorage的JSON结构化存储
- **搜索筛选**: 前端JavaScript实现实时搜索和标签筛选
- **导入导出**: 完整的军理知识库导入功能
- **笔记评分**: 用户可添加个人笔记和1-5分评分

**3. 用户体验特色**
- **层次化展示**: 知识库→知识区→知识点的清晰结构
- **颜色标识**: 每个知识区有专属主题色
- **展开收起**: 知识点可展开查看详细内容
- **实时保存**: 笔记和评分实时保存到本地

## 技术架构设计

### 技术栈选择
```yaml
框架: Spring Boot 2.7.x
数据库: MySQL 8.0
缓存: Redis 6.0
ORM: MyBatis-Plus
搜索: Elasticsearch 7.x (可选)
文档: Swagger/OpenAPI 3
测试: JUnit 5 + Testcontainers
```

### 数据库设计

#### 1. 知识库表 (knowledge_bases)
```sql
CREATE TABLE knowledge_bases (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '知识库ID',
    user_id BIGINT NOT NULL COMMENT '创建者ID',
    name VARCHAR(100) NOT NULL COMMENT '知识库名称',
    description TEXT COMMENT '知识库描述',
    cover_image VARCHAR(500) COMMENT '封面图片',
    is_public TINYINT DEFAULT 0 COMMENT '是否公开(0:私有,1:公开)',
    category VARCHAR(50) COMMENT '分类',
    tags JSON COMMENT '标签数组',
    total_points INT DEFAULT 0 COMMENT '知识点总数',
    total_areas INT DEFAULT 0 COMMENT '知识区总数',
    status TINYINT DEFAULT 1 COMMENT '状态(0:删除,1:正常)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_id (user_id),
    INDEX idx_is_public (is_public),
    INDEX idx_category (category),
    INDEX idx_status (status),
    FOREIGN KEY (user_id) REFERENCES user_db.users(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='知识库表';
```

#### 2. 知识区表 (knowledge_areas)
```sql
CREATE TABLE knowledge_areas (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '知识区ID',
    base_id BIGINT NOT NULL COMMENT '知识库ID',
    name VARCHAR(100) NOT NULL COMMENT '知识区名称',
    description TEXT COMMENT '知识区描述',
    color VARCHAR(20) DEFAULT '#667eea' COMMENT '主题色',
    sort_order INT DEFAULT 0 COMMENT '排序序号',
    point_count INT DEFAULT 0 COMMENT '知识点数量',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_base_id (base_id),
    INDEX idx_sort_order (sort_order),
    FOREIGN KEY (base_id) REFERENCES knowledge_bases(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='知识区表';
```

#### 3. 知识点表 (knowledge_points)
```sql
CREATE TABLE knowledge_points (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '知识点ID',
    area_id BIGINT NOT NULL COMMENT '知识区ID',
    base_id BIGINT NOT NULL COMMENT '知识库ID',
    question TEXT NOT NULL COMMENT '问题',
    answer TEXT NOT NULL COMMENT '答案',
    explanation TEXT COMMENT '解析说明',
    tags JSON COMMENT '标签数组',
    difficulty INT DEFAULT 3 COMMENT '难度等级(1-5)',
    source VARCHAR(200) COMMENT '来源',
    sort_order INT DEFAULT 0 COMMENT '排序序号',
    status TINYINT DEFAULT 1 COMMENT '状态(0:删除,1:正常)',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_area_id (area_id),
    INDEX idx_base_id (base_id),
    INDEX idx_difficulty (difficulty),
    INDEX idx_status (status),
    FULLTEXT idx_content (question, answer, explanation),
    FOREIGN KEY (area_id) REFERENCES knowledge_areas(id) ON DELETE CASCADE,
    FOREIGN KEY (base_id) REFERENCES knowledge_bases(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='知识点表';
```

#### 4. 用户知识点数据表 (user_knowledge_data)
```sql
CREATE TABLE user_knowledge_data (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
    user_id BIGINT NOT NULL COMMENT '用户ID',
    knowledge_id BIGINT NOT NULL COMMENT '知识点ID',
    note TEXT COMMENT '个人笔记',
    score TINYINT COMMENT '个人评分(1-5)',
    review_count INT DEFAULT 0 COMMENT '复习次数',
    correct_count INT DEFAULT 0 COMMENT '正确次数',
    last_reviewed DATETIME COMMENT '最后复习时间',
    next_review DATETIME COMMENT '下次复习时间',
    ease_factor DECIMAL(3,2) DEFAULT 2.50 COMMENT '难易度因子',
    interval_days INT DEFAULT 1 COMMENT '复习间隔天数',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_knowledge (user_id, knowledge_id),
    INDEX idx_user_id (user_id),
    INDEX idx_knowledge_id (knowledge_id),
    INDEX idx_next_review (next_review),
    FOREIGN KEY (user_id) REFERENCES user_db.users(id) ON DELETE CASCADE,
    FOREIGN KEY (knowledge_id) REFERENCES knowledge_points(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户知识点数据表';
```

## 核心功能实现

### 1. 知识库管理服务

```java
@Service
@Transactional
public class KnowledgeBaseServiceImpl implements KnowledgeBaseService {

    @Autowired
    private KnowledgeBaseMapper knowledgeBaseMapper;
    
    @Autowired
    private KnowledgeAreaMapper knowledgeAreaMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public KnowledgeBaseDetailVO createKnowledgeBase(CreateKnowledgeBaseRequest request, Long userId) {
        // 创建知识库
        KnowledgeBase knowledgeBase = new KnowledgeBase();
        knowledgeBase.setUserId(userId);
        knowledgeBase.setName(request.getName());
        knowledgeBase.setDescription(request.getDescription());
        knowledgeBase.setCoverImage(request.getCoverImage());
        knowledgeBase.setCategory(request.getCategory());
        knowledgeBase.setTags(request.getTags());
        knowledgeBase.setIsPublic(request.getIsPublic());
        
        knowledgeBaseMapper.insert(knowledgeBase);
        
        // 清除用户知识库缓存
        clearUserKnowledgeBaseCache(userId);
        
        return convertToDetailVO(knowledgeBase);
    }

    @Override
    public PageResult<KnowledgeBaseListVO> getUserKnowledgeBases(Long userId, PageRequest pageRequest) {
        // 先尝试从缓存获取
        String cacheKey = String.format("user:kb:%d:page:%d:%d", userId, pageRequest.getPageNum(), pageRequest.getPageSize());
        PageResult<KnowledgeBaseListVO> cached = (PageResult<KnowledgeBaseListVO>) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 分页查询
        Page<KnowledgeBase> page = new Page<>(pageRequest.getPageNum(), pageRequest.getPageSize());
        Page<KnowledgeBase> result = knowledgeBaseMapper.selectPage(page, 
            Wrappers.<KnowledgeBase>lambdaQuery()
                .eq(KnowledgeBase::getUserId, userId)
                .eq(KnowledgeBase::getStatus, 1)
                .orderByDesc(KnowledgeBase::getUpdatedAt)
        );

        List<KnowledgeBaseListVO> voList = result.getRecords().stream()
            .map(this::convertToListVO)
            .collect(Collectors.toList());

        PageResult<KnowledgeBaseListVO> pageResult = new PageResult<>(
            voList, result.getTotal(), result.getCurrent(), result.getSize()
        );

        // 缓存结果，5分钟过期
        redisTemplate.opsForValue().set(cacheKey, pageResult, 5, TimeUnit.MINUTES);
        
        return pageResult;
    }

    @Override
    public KnowledgeBaseDetailVO getKnowledgeBaseDetail(Long baseId, Long userId) {
        // 检查权限
        KnowledgeBase knowledgeBase = knowledgeBaseMapper.selectById(baseId);
        if (knowledgeBase == null) {
            throw new BusinessException("知识库不存在");
        }
        
        if (!knowledgeBase.getIsPublic() && !knowledgeBase.getUserId().equals(userId)) {
            throw new BusinessException("无权限访问该知识库");
        }

        // 获取知识区列表
        List<KnowledgeArea> areas = knowledgeAreaMapper.selectList(
            Wrappers.<KnowledgeArea>lambdaQuery()
                .eq(KnowledgeArea::getBaseId, baseId)
                .orderByAsc(KnowledgeArea::getSortOrder)
        );

        KnowledgeBaseDetailVO detailVO = convertToDetailVO(knowledgeBase);
        detailVO.setAreas(areas.stream()
            .map(this::convertAreaToVO)
            .collect(Collectors.toList()));

        return detailVO;
    }

    @Override
    public void importKnowledgeBase(ImportKnowledgeBaseRequest request, Long userId) {
        // 解析导入数据
        KnowledgeBaseImportData importData = parseImportData(request.getData());
        
        // 创建知识库
        KnowledgeBase knowledgeBase = new KnowledgeBase();
        knowledgeBase.setUserId(userId);
        knowledgeBase.setName(importData.getName());
        knowledgeBase.setDescription(importData.getDescription());
        knowledgeBase.setCategory(importData.getCategory());
        
        knowledgeBaseMapper.insert(knowledgeBase);
        
        // 批量创建知识区和知识点
        batchCreateAreasAndPoints(knowledgeBase.getId(), importData.getAreas());
        
        // 更新统计数据
        updateKnowledgeBaseStats(knowledgeBase.getId());
        
        // 清除缓存
        clearUserKnowledgeBaseCache(userId);
    }

    private void batchCreateAreasAndPoints(Long baseId, List<ImportAreaData> areaDataList) {
        for (int i = 0; i < areaDataList.size(); i++) {
            ImportAreaData areaData = areaDataList.get(i);
            
            // 创建知识区
            KnowledgeArea area = new KnowledgeArea();
            area.setBaseId(baseId);
            area.setName(areaData.getName());
            area.setDescription(areaData.getDescription());
            area.setColor(areaData.getColor());
            area.setSortOrder(i);
            
            knowledgeAreaMapper.insert(area);
            
            // 批量创建知识点
            if (areaData.getKnowledgePoints() != null && !areaData.getKnowledgePoints().isEmpty()) {
                List<KnowledgePoint> points = new ArrayList<>();
                for (int j = 0; j < areaData.getKnowledgePoints().size(); j++) {
                    ImportPointData pointData = areaData.getKnowledgePoints().get(j);
                    
                    KnowledgePoint point = new KnowledgePoint();
                    point.setAreaId(area.getId());
                    point.setBaseId(baseId);
                    point.setQuestion(pointData.getQuestion());
                    point.setAnswer(pointData.getAnswer());
                    point.setExplanation(pointData.getExplanation());
                    point.setTags(pointData.getTags());
                    point.setDifficulty(pointData.getDifficulty());
                    point.setSortOrder(j);
                    
                    points.add(point);
                }
                
                // 使用MyBatis-Plus的批量插入
                knowledgePointService.saveBatch(points, 100);
            }
        }
    }
}
```

### 2. 知识点管理服务

```java
@Service
@Transactional
public class KnowledgePointServiceImpl implements KnowledgePointService {

    @Autowired
    private KnowledgePointMapper knowledgePointMapper;
    
    @Autowired
    private UserKnowledgeDataMapper userKnowledgeDataMapper;

    @Override
    public PageResult<KnowledgePointVO> getKnowledgePoints(KnowledgePointQueryRequest request, Long userId) {
        Page<KnowledgePoint> page = new Page<>(request.getPageNum(), request.getPageSize());
        
        LambdaQueryWrapper<KnowledgePoint> queryWrapper = Wrappers.<KnowledgePoint>lambdaQuery()
            .eq(request.getAreaId() != null, KnowledgePoint::getAreaId, request.getAreaId())
            .eq(request.getBaseId() != null, KnowledgePoint::getBaseId, request.getBaseId())
            .eq(request.getDifficulty() != null, KnowledgePoint::getDifficulty, request.getDifficulty())
            .like(StringUtils.hasText(request.getKeyword()), KnowledgePoint::getQuestion, request.getKeyword())
            .or(StringUtils.hasText(request.getKeyword()))
            .like(StringUtils.hasText(request.getKeyword()), KnowledgePoint::getAnswer, request.getKeyword())
            .eq(KnowledgePoint::getStatus, 1)
            .orderByAsc(KnowledgePoint::getSortOrder);

        Page<KnowledgePoint> result = knowledgePointMapper.selectPage(page, queryWrapper);
        
        // 获取用户相关数据
        List<Long> pointIds = result.getRecords().stream()
            .map(KnowledgePoint::getId)
            .collect(Collectors.toList());
            
        Map<Long, UserKnowledgeData> userDataMap = getUserKnowledgeDataMap(userId, pointIds);
        
        List<KnowledgePointVO> voList = result.getRecords().stream()
            .map(point -> convertToVO(point, userDataMap.get(point.getId())))
            .collect(Collectors.toList());

        return new PageResult<>(voList, result.getTotal(), result.getCurrent(), result.getSize());
    }

    @Override
    public void updateKnowledgePointNote(Long pointId, Long userId, String note) {
        // 获取或创建用户知识点数据
        UserKnowledgeData userData = userKnowledgeDataMapper.selectOne(
            Wrappers.<UserKnowledgeData>lambdaQuery()
                .eq(UserKnowledgeData::getUserId, userId)
                .eq(UserKnowledgeData::getKnowledgeId, pointId)
        );

        if (userData == null) {
            userData = new UserKnowledgeData();
            userData.setUserId(userId);
            userData.setKnowledgeId(pointId);
            userData.setNote(note);
            userKnowledgeDataMapper.insert(userData);
        } else {
            userData.setNote(note);
            userKnowledgeDataMapper.updateById(userData);
        }

        // 清除相关缓存
        clearUserKnowledgePointCache(userId, pointId);
    }

    @Override
    public void updateKnowledgePointScore(Long pointId, Long userId, Integer score) {
        if (score < 1 || score > 5) {
            throw new BusinessException("评分必须在1-5之间");
        }

        UserKnowledgeData userData = userKnowledgeDataMapper.selectOne(
            Wrappers.<UserKnowledgeData>lambdaQuery()
                .eq(UserKnowledgeData::getUserId, userId)
                .eq(UserKnowledgeData::getKnowledgeId, pointId)
        );

        if (userData == null) {
            userData = new UserKnowledgeData();
            userData.setUserId(userId);
            userData.setKnowledgeId(pointId);
            userData.setScore(score);
            userKnowledgeDataMapper.insert(userData);
        } else {
            userData.setScore(score);
            userKnowledgeDataMapper.updateById(userData);
        }

        // 清除相关缓存
        clearUserKnowledgePointCache(userId, pointId);
    }

    @Override
    public List<KnowledgePointVO> searchKnowledgePoints(KnowledgePointSearchRequest request, Long userId) {
        // 使用全文搜索
        List<KnowledgePoint> points = knowledgePointMapper.fullTextSearch(
            request.getKeyword(),
            request.getBaseIds(),
            request.getAreaIds(),
            request.getTags(),
            request.getDifficulties(),
            request.getLimit()
        );

        // 获取用户数据
        List<Long> pointIds = points.stream()
            .map(KnowledgePoint::getId)
            .collect(Collectors.toList());
            
        Map<Long, UserKnowledgeData> userDataMap = getUserKnowledgeDataMap(userId, pointIds);

        return points.stream()
            .map(point -> convertToVO(point, userDataMap.get(point.getId())))
            .collect(Collectors.toList());
    }

    private Map<Long, UserKnowledgeData> getUserKnowledgeDataMap(Long userId, List<Long> pointIds) {
        if (pointIds.isEmpty()) {
            return new HashMap<>();
        }

        List<UserKnowledgeData> userDataList = userKnowledgeDataMapper.selectList(
            Wrappers.<UserKnowledgeData>lambdaQuery()
                .eq(UserKnowledgeData::getUserId, userId)
                .in(UserKnowledgeData::getKnowledgeId, pointIds)
        );

        return userDataList.stream()
            .collect(Collectors.toMap(
                UserKnowledgeData::getKnowledgeId,
                Function.identity()
            ));
    }
}
```

## API接口设计

### 知识库管理接口

#### 1. 创建知识库
```http
POST /api/knowledge/bases
Authorization: Bearer {token}
Content-Type: application/json

{
    "name": "我的知识库",
    "description": "这是我的个人知识库",
    "category": "学习",
    "tags": ["编程", "算法"],
    "isPublic": false
}
```

#### 2. 获取用户知识库列表
```http
GET /api/knowledge/bases?pageNum=1&pageSize=10&category=学习
Authorization: Bearer {token}

Response:
{
    "code": 200,
    "data": {
        "list": [
            {
                "id": 1,
                "name": "我的知识库",
                "description": "这是我的个人知识库",
                "totalPoints": 100,
                "totalAreas": 5,
                "category": "学习",
                "isPublic": false,
                "createdAt": "2024-01-01T10:00:00"
            }
        ],
        "total": 1,
        "pageNum": 1,
        "pageSize": 10
    }
}
```

#### 3. 获取知识库详情
```http
GET /api/knowledge/bases/{baseId}
Authorization: Bearer {token}

Response:
{
    "code": 200,
    "data": {
        "id": 1,
        "name": "军事理论知识库",
        "description": "军事理论课程完整知识体系",
        "totalPoints": 54,
        "totalAreas": 5,
        "areas": [
            {
                "id": 1,
                "name": "第一章 国防概述",
                "description": "国防基础理论...",
                "color": "#667eea",
                "pointCount": 27
            }
        ]
    }
}
```

### 知识点管理接口

#### 1. 获取知识点列表
```http
GET /api/knowledge/points?areaId=1&pageNum=1&pageSize=20&keyword=国防
Authorization: Bearer {token}
```

#### 2. 更新知识点笔记
```http
PUT /api/knowledge/points/{pointId}/note
Authorization: Bearer {token}
Content-Type: application/json

{
    "note": "这是我的学习笔记..."
}
```

#### 3. 更新知识点评分
```http
PUT /api/knowledge/points/{pointId}/score
Authorization: Bearer {token}
Content-Type: application/json

{
    "score": 4
}
```

## 与前端集成方案

### 1. 数据适配层
```javascript
// 原来的LocalStorage操作
class StorageManager {
    getAllKnowledge() {
        const data = JSON.parse(localStorage.getItem('memorin_data') || '{}');
        return data.knowledge || [];
    }
}

// 新的API适配层
class KnowledgeApiService {
    constructor() {
        this.apiService = new ApiService();
    }

    async getAllKnowledge(baseId, areaId) {
        const response = await this.apiService.request('/knowledge/points', {
            method: 'GET',
            params: { baseId, areaId, pageSize: 1000 }
        });
        return response.data.list;
    }

    async updateKnowledgeNote(pointId, note) {
        return await this.apiService.request(`/knowledge/points/${pointId}/note`, {
            method: 'PUT',
            body: JSON.stringify({ note })
        });
    }

    async updateKnowledgeScore(pointId, score) {
        return await this.apiService.request(`/knowledge/points/${pointId}/score`, {
            method: 'PUT',
            body: JSON.stringify({ score })
        });
    }
}
```

### 2. 缓存策略
```javascript
// 前端缓存管理
class KnowledgeCacheManager {
    constructor() {
        this.cache = new Map();
        this.cacheTimeout = 5 * 60 * 1000; // 5分钟
    }

    async getKnowledgeBase(baseId) {
        const cacheKey = `kb_${baseId}`;
        const cached = this.cache.get(cacheKey);
        
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }

        const data = await this.apiService.getKnowledgeBase(baseId);
        this.cache.set(cacheKey, {
            data,
            timestamp: Date.now()
        });
        
        return data;
    }

    clearCache(pattern) {
        for (const key of this.cache.keys()) {
            if (key.includes(pattern)) {
                this.cache.delete(key);
            }
        }
    }
}
```

这个知识库服务文档涵盖了从demo分析到微服务实现的完整方案。主要特点是保持了原有的三级结构设计，同时增加了用户权限管理、数据缓存、批量导入等企业级功能。您觉得这个设计如何？接下来我可以继续编写答题服务的开发文档。 