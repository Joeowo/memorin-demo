# 4-è¯¦ç»†åŠŸèƒ½è§„æ ¼è¯´æ˜.md

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2025-01-08  
> **æœ€åæ›´æ–°**: 2025-01-08  
> **æ–‡æ¡£çŠ¶æ€**: ğŸ”„ è¿›è¡Œä¸­  

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºTask-1è‡³Task-3çš„åˆ†æå’Œè®¾è®¡ï¼Œè¯¦ç»†å®šä¹‰Memorinæ™ºèƒ½çŸ¥è¯†å¤ä¹ ç³»ç»Ÿé‡æ„åçš„åŠŸèƒ½è§„æ ¼è¯´æ˜ã€‚æ–‡æ¡£å°†é€ä¸ªåŠŸèƒ½æ¨¡å—è¿›è¡Œæ·±å…¥åˆ†æï¼Œç¡®ä¿é‡æ„é¡¹ç›®çš„åŠŸèƒ½å®Œæ•´æ€§å’Œå®ç°å¯è¡Œæ€§ã€‚

---

## ğŸ¯ åŠŸèƒ½æ¨¡å—æ¦‚è§ˆ

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

| æ¨¡å—åç§° | ä¼˜å…ˆçº§ | å¤æ‚åº¦ | ç°æœ‰ä»£ç è¡Œæ•° | é‡æ„çŠ¶æ€ |
|---------|-------|-------|-------------|---------|
| **ä»ªè¡¨ç›˜æ¨¡å—** | ğŸ”´ æé«˜ | ğŸŸ¡ ä¸­ç­‰ | 595è¡Œ(app.js) | âœ… å·²å®Œæˆ |
| **çŸ¥è¯†ç®¡ç†æ¨¡å—** | ğŸ”´ æé«˜ | ğŸ”´ æé«˜ | 1900è¡Œ(knowledge.js) | ğŸ”„ è¿›è¡Œä¸­ |
| **å¤ä¹ ç³»ç»Ÿæ¨¡å—** | ğŸ”´ æé«˜ | ğŸ”´ æé«˜ | 2099è¡Œ(review.js) | â³ å¾…å¼€å§‹ |
| **é”™é¢˜æœ¬æ¨¡å—** | ğŸŸ¡ é«˜ | ğŸŸ¡ ä¸­ç­‰ | é›†æˆåœ¨review.js | â³ å¾…å¼€å§‹ |
| **ç¬”è®°ç¼–è¾‘æ¨¡å—** | ğŸŸ¡ é«˜ | ğŸŸ¡ ä¸­ç­‰ | 1200è¡Œ(notes-manager.js) | â³ å¾…å¼€å§‹ |
| **ç»Ÿè®¡åˆ†ææ¨¡å—** | ğŸŸ¢ ä¸­ç­‰ | ğŸŸ¡ ä¸­ç­‰ | é›†æˆåœ¨statistics.js | â³ å¾…å¼€å§‹ |

---

## ğŸ“± 1. ä»ªè¡¨ç›˜æ¨¡å—åŠŸèƒ½è§„æ ¼

### 1.1 æ¨¡å—æ¦‚è¿°

ä»ªè¡¨ç›˜æ˜¯ç”¨æˆ·è¿›å…¥ç³»ç»Ÿåçš„ä¸»ç•Œé¢ï¼Œæ‰¿æ‹…ç€ç³»ç»Ÿå¯¼èˆªã€çŠ¶æ€å±•ç¤ºã€å¿«é€Ÿæ“ä½œç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

### 1.2 ç°æœ‰å®ç°åˆ†æ

#### 1.2.1 æ ¸å¿ƒæ¶æ„åˆ†æ

**ä¸»æ§ç±»**: `MemoryApp`ç±» (595è¡Œä»£ç )
- **èŒè´£**: åº”ç”¨åˆå§‹åŒ–ã€é¡µé¢å¯¼èˆªã€æ¨¡æ€æ¡†ç®¡ç†ã€å…¨å±€äº‹ä»¶å¤„ç†
- **æ ¸å¿ƒæ–¹æ³•**:
  - `init()`: åº”ç”¨åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š
  - `switchSection()`: é¡µé¢åˆ‡æ¢é€»è¾‘
  - `loadDashboard()`: ä»ªè¡¨ç›˜æ•°æ®åŠ è½½
  - `getDashboardStats()`: ç»Ÿè®¡æ•°æ®è®¡ç®—
  - `handleQuickAction()`: å¿«é€Ÿæ“ä½œå¤„ç†

#### 1.2.2 ç•Œé¢ç»„æˆåˆ†æ

```html
<!-- ä»ªè¡¨ç›˜æ ¸å¿ƒç•Œé¢ç»“æ„ -->
<section id="dashboard" class="content-section active">
  <!-- å¤´éƒ¨åŒºåŸŸ -->
  <div class="dashboard-header">
    <h2>å­¦ä¹ æ¦‚è§ˆ</h2>
    <p class="welcome-text">æ¬¢è¿å›åˆ°Memorinï¼Œç»§ç»­æ‚¨çš„å­¦ä¹ ä¹‹æ—…ï¼</p>
  </div>
  
  <!-- ç»Ÿè®¡å¡ç‰‡åŒºåŸŸ -->
  <div class="stats-grid">
    <div class="stat-card">ğŸ“š æ€»çŸ¥è¯†ç‚¹</div>
    <div class="stat-card">ğŸ¯ ä»Šæ—¥å¾…å¤ä¹ </div>
    <div class="stat-card">âœ… å·²æŒæ¡</div>
    <div class="stat-card">âŒ é”™é¢˜æ•°é‡</div>
  </div>

  <!-- å¿«é€Ÿæ“ä½œåŒºåŸŸ -->
  <div class="quick-actions">
    <h3>å¿«é€Ÿæ“ä½œ</h3>
    <div class="action-buttons">
      <!-- 7ä¸ªå¿«é€Ÿæ“ä½œæŒ‰é’® -->
    </div>
    <div class="data-info">
      <!-- çŸ¥è¯†åº“ä¿¡æ¯å±•ç¤º -->
    </div>
  </div>
</section>
```

#### 1.2.3 æ•°æ®æµåˆ†æ

```javascript
// ç»Ÿè®¡æ•°æ®è®¡ç®—é€»è¾‘
getDashboardStats() {
  const knowledge = window.storageManager.getAllKnowledge();
  const mistakes = window.storageManager.getMistakes();
  
  return {
    totalKnowledge: knowledge.length,                    // æ€»çŸ¥è¯†ç‚¹æ•°
    todayReview: knowledge.filter(å¤ä¹ æ¡ä»¶).length,       // ä»Šæ—¥å¾…å¤ä¹ 
    masteredCount: knowledge.filter(æŒæ¡æ¡ä»¶).length,    // å·²æŒæ¡æ•°é‡
    mistakesCount: mistakes.length                       // é”™é¢˜æ•°é‡
  };
}
```

#### 1.2.4 äº¤äº’åŠŸèƒ½åˆ†æ

1. **é¡µé¢å¯¼èˆª**: é€šè¿‡`data-section`å±æ€§å®ç°å•é¡µé¢åº”ç”¨çš„é¡µé¢åˆ‡æ¢
2. **å¿«é€Ÿæ“ä½œ**: 7ä¸ªæ“ä½œæŒ‰é’®ï¼ŒåŒ…æ‹¬å¼€å§‹å¤ä¹ ã€é”™é¢˜å¤ä¹ ã€ç¬”è®°ç¼–è¾‘å™¨ç­‰
3. **æ¨¡æ€æ¡†ç³»ç»Ÿ**: ç»Ÿä¸€çš„æ¨¡æ€æ¡†ç®¡ç†æœºåˆ¶
4. **é€šçŸ¥ç³»ç»Ÿ**: è½»é‡çº§çš„toasté€šçŸ¥
5. **ç¡®è®¤å¯¹è¯æ¡†**: å±é™©æ“ä½œçš„äºŒæ¬¡ç¡®è®¤

#### 1.2.5 æ€§èƒ½ç‰¹ç‚¹

- **åŒæ­¥æ¸²æŸ“**: æ‰€æœ‰æ•°æ®è®¡ç®—å’ŒDOMæ›´æ–°éƒ½æ˜¯åŒæ­¥çš„
- **å…¨å±€ä¾èµ–**: ä¾èµ–`window.storageManager`ç­‰å…¨å±€å¯¹è±¡
- **ç›´æ¥DOMæ“ä½œ**: å¤§é‡çš„`document.getElementById`è°ƒç”¨
- **äº‹ä»¶å§”æ‰˜ä¸è¶³**: æ¯ä¸ªæŒ‰é’®éƒ½æœ‰ç‹¬ç«‹çš„äº‹ä»¶ç›‘å¬å™¨

#### 1.2.6 å­˜åœ¨é—®é¢˜

1. **å•ä¸€èŒè´£è¿èƒŒ**: MemoryAppç±»æ‰¿æ‹…äº†è¿‡å¤šèŒè´£
2. **ç´§è€¦åˆ**: ä¸å…¨å±€å¯¹è±¡çš„å¼ºä¾èµ–å…³ç³»
3. **å¯æµ‹è¯•æ€§å·®**: éš¾ä»¥è¿›è¡Œå•å…ƒæµ‹è¯•
4. **å¯ç»´æŠ¤æ€§ä½**: 595è¡Œçš„å•ä¸€ç±»æ–‡ä»¶
5. **æ€§èƒ½é—®é¢˜**: æ¯æ¬¡æ•°æ®æ›´æ–°éƒ½é‡æ–°è®¡ç®—æ‰€æœ‰ç»Ÿè®¡

### 1.3 åŠŸèƒ½è§„æ ¼å®šä¹‰

#### 1.3.1 Vueç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// ä»ªè¡¨ç›˜æ¨¡å—ç»„ä»¶æ ‘ç»“æ„
src/views/Dashboard/
â”œâ”€â”€ Dashboard.vue              // ä¸»å®¹å™¨ç»„ä»¶
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ DashboardHeader.vue    // å¤´éƒ¨æ¬¢è¿åŒºåŸŸ (è‡ªå®šä¹‰GradientHeader)
â”‚   â”œâ”€â”€ StatsGrid.vue          // ç»Ÿè®¡å¡ç‰‡ç½‘æ ¼ (å¸ƒå±€ç»„ä»¶)
â”‚   â”‚   â””â”€â”€ StatCard.vue       // å•ä¸ªç»Ÿè®¡å¡ç‰‡ (è‡ªå®šä¹‰GlassCard)
â”‚   â”œâ”€â”€ QuickActions.vue       // å¿«é€Ÿæ“ä½œåŒºåŸŸ (å¸ƒå±€ç»„ä»¶)
â”‚   â”‚   â”œâ”€â”€ ActionButton.vue   // æ“ä½œæŒ‰é’®ç»„ä»¶ (è‡ªå®šä¹‰GlassButton)
â”‚   â”‚   â””â”€â”€ ActionGrid.vue     // æŒ‰é’®ç½‘æ ¼å¸ƒå±€ (CSS Grid)
â”‚   â””â”€â”€ KnowledgeBasesInfo.vue // çŸ¥è¯†åº“ä¿¡æ¯å±•ç¤º (å¯ä½¿ç”¨ElTable+æ ·å¼è¦†ç›–)
â””â”€â”€ composables/
    â”œâ”€â”€ useDashboardStats.ts   // ç»Ÿè®¡æ•°æ®é€»è¾‘
    â”œâ”€â”€ useQuickActions.ts     // å¿«é€Ÿæ“ä½œé€»è¾‘
    â””â”€â”€ useKnowledgeBasesInfo.ts // çŸ¥è¯†åº“ä¿¡æ¯é€»è¾‘
```

**ç»„ä»¶è®¾è®¡è¯´æ˜ï¼š**
- **StatCard**: æ ¸å¿ƒè§†è§‰ç»„ä»¶ï¼Œå¿…é¡»ä½¿ç”¨è‡ªå®šä¹‰GlassCardä¿æŒæ¯›ç»ç’ƒä¸»é¢˜
- **ActionButton**: æ ¸å¿ƒäº¤äº’ç»„ä»¶ï¼Œä½¿ç”¨è‡ªå®šä¹‰GlassButtonä¿æŒä¸€è‡´æ€§
- **DashboardHeader**: æ¸å˜èƒŒæ™¯å¤´éƒ¨ï¼Œä½¿ç”¨è‡ªå®šä¹‰GradientHeader
- **KnowledgeBasesInfo**: æ•°æ®å±•ç¤ºç»„ä»¶ï¼Œå¯ä½¿ç”¨ElTableå¹¶åº”ç”¨æ¯›ç»ç’ƒæ ·å¼è¦†ç›–

#### 1.3.2 çŠ¶æ€ç®¡ç†è§„æ ¼

```typescript
// stores/dashboard.ts
export const useDashboardStore = defineStore('dashboard', () => {
  // çŠ¶æ€å®šä¹‰
  const stats = ref<DashboardStats>({
    totalKnowledge: 0,
    todayReview: 0,
    masteredCount: 0,
    mistakesCount: 0,
    loading: false,
    lastUpdated: null
  })
  
  const knowledgeBasesInfo = ref<KnowledgeBaseInfo[]>([])
  
  // è®¡ç®—å±æ€§
  const completionRate = computed(() => {
    if (stats.value.totalKnowledge === 0) return 0
    return Math.round((stats.value.masteredCount / stats.value.totalKnowledge) * 100)
  })
  
  const reviewProgress = computed(() => {
    if (stats.value.totalKnowledge === 0) return 0
    const reviewedToday = stats.value.totalKnowledge - stats.value.todayReview
    return Math.round((reviewedToday / stats.value.totalKnowledge) * 100)
  })
  
  // æ“ä½œæ–¹æ³•
  const refreshStats = async () => {
    stats.value.loading = true
    try {
      const knowledgeStore = useKnowledgeStore()
      const mistakeStore = useMistakeStore()
      
      const knowledge = await knowledgeStore.getAllKnowledge()
      const mistakes = await mistakeStore.getAllMistakes()
      const today = new Date()
      today.setHours(0, 0, 0, 0)
      
      stats.value = {
        totalKnowledge: knowledge.length,
        todayReview: knowledge.filter(k => {
          const nextReview = new Date(k.reviewData.nextReviewDate)
          return nextReview <= new Date()
        }).length,
        masteredCount: knowledge.filter(k => 
          k.reviewData.repetitions >= 5 && 
          (k.reviewData.correctCount / k.reviewData.totalReviews) >= 0.8
        ).length,
        mistakesCount: mistakes.length,
        loading: false,
        lastUpdated: new Date()
      }
    } catch (error) {
      console.error('åˆ·æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥:', error)
      stats.value.loading = false
    }
  }
  
  const refreshKnowledgeBasesInfo = async () => {
    try {
      const knowledgeStore = useKnowledgeStore()
      const bases = await knowledgeStore.getAllKnowledgeBases()
      
      knowledgeBasesInfo.value = bases.map(base => ({
        id: base.id,
        name: base.name,
        icon: base.icon,
        knowledgeCount: base.areas.reduce((total, area) => 
          total + area.knowledgePoints.length, 0
        ),
        lastActivity: base.updatedAt
      }))
    } catch (error) {
      console.error('åˆ·æ–°çŸ¥è¯†åº“ä¿¡æ¯å¤±è´¥:', error)
    }
  }
  
  return {
    // çŠ¶æ€
    stats: readonly(stats),
    knowledgeBasesInfo: readonly(knowledgeBasesInfo),
    
    // è®¡ç®—å±æ€§
    completionRate,
    reviewProgress,
    
    // æ“ä½œ
    refreshStats,
    refreshKnowledgeBasesInfo
  }
})
```

#### 1.3.3 ç»„ä»¶å®ç°è§„æ ¼

```vue
<!-- views/Dashboard/Dashboard.vue -->
<template>
  <div class="dashboard">
    <DashboardHeader />
    
    <StatsGrid 
      :stats="dashboardStats" 
      :loading="statsLoading"
    />
    
    <QuickActions 
      @action="handleQuickAction"
    />
    
    <KnowledgeBasesInfo 
      :knowledge-bases="knowledgeBasesInfo"
    />
  </div>
</template>

<script setup lang="ts">
import { onMounted, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useDashboardStore } from '@/stores/dashboard'
import DashboardHeader from './components/DashboardHeader.vue'
import StatsGrid from './components/StatsGrid.vue'
import QuickActions from './components/QuickActions.vue'
import KnowledgeBasesInfo from './components/KnowledgeBasesInfo.vue'

const router = useRouter()
const dashboardStore = useDashboardStore()

// è®¡ç®—å±æ€§
const dashboardStats = computed(() => dashboardStore.stats)
const knowledgeBasesInfo = computed(() => dashboardStore.knowledgeBasesInfo)
const statsLoading = computed(() => dashboardStore.stats.loading)

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await Promise.all([
    dashboardStore.refreshStats(),
    dashboardStore.refreshKnowledgeBasesInfo()
  ])
})

// äº‹ä»¶å¤„ç†
const handleQuickAction = (action: QuickActionType) => {
  switch (action) {
    case 'start-review':
      router.push('/review')
      break
    case 'review-mistakes':
      router.push('/mistakes')
      break
    case 'open-notes':
      window.open('/notes', '_blank')
      break
    case 'import-military':
      importMilitaryKnowledge()
      break
    case 'import-software':
      importSoftwareEngineering()
      break
    case 'fix-data':
      fixAllData()
      break
    case 'clear-data':
      clearAllDataWithConfirm()
      break
  }
}

// æ“ä½œæ–¹æ³•
const importMilitaryKnowledge = async () => {
  // å¯¼å…¥å†›ç†çŸ¥è¯†åº“é€»è¾‘
}

const importSoftwareEngineering = async () => {
  // å¯¼å…¥è½¯ä»¶å·¥ç¨‹çŸ¥è¯†åº“é€»è¾‘
}

const fixAllData = async () => {
  // æ•°æ®ä¿®å¤é€»è¾‘
}

const clearAllDataWithConfirm = async () => {
  // æ¸…ç©ºæ•°æ®ç¡®è®¤é€»è¾‘
}
</script>
```

#### 1.3.4 æ•°æ®æ¨¡å‹è§„æ ¼

```typescript
// types/dashboard.ts
export interface DashboardStats {
  totalKnowledge: number
  todayReview: number
  masteredCount: number
  mistakesCount: number
  loading: boolean
  lastUpdated: Date | null
}

export interface KnowledgeBaseInfo {
  id: string
  name: string
  icon: string
  knowledgeCount: number
  lastActivity: string
}

export type QuickActionType = 
  | 'start-review'
  | 'review-mistakes' 
  | 'open-notes'
  | 'import-military'
  | 'import-software'
  | 'fix-data'
  | 'clear-data'

export interface QuickAction {
  id: QuickActionType
  label: string
  icon: string
  variant: 'primary' | 'secondary' | 'success' | 'warning' | 'info'
  description?: string
}
```

#### 1.3.5 APIæ¥å£è§„æ ¼

```typescript
// services/api/dashboard.ts
export interface DashboardAPI {
  // è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®
  getStats(): Promise<DashboardStats>
  
  // è·å–çŸ¥è¯†åº“æ¦‚è§ˆä¿¡æ¯
  getKnowledgeBasesOverview(): Promise<KnowledgeBaseInfo[]>
  
  // æ‰§è¡Œæ•°æ®ä¿®å¤
  fixAllData(): Promise<{ success: boolean; message: string }>
  
  // æ¸…ç©ºæ‰€æœ‰æ•°æ®
  clearAllData(): Promise<{ success: boolean }>
  
  // å¯¼å…¥é¢„ç½®çŸ¥è¯†åº“
  importPresetKnowledgeBase(type: 'military' | 'software'): Promise<{
    success: boolean
    importedCount: number
    message: string
  }>
}

class DashboardService implements DashboardAPI {
  async getStats(): Promise<DashboardStats> {
    // ä»åç«¯APIè·å–ç»Ÿè®¡æ•°æ®
    const response = await api.get('/dashboard/stats')
    return response.data
  }
  
  async getKnowledgeBasesOverview(): Promise<KnowledgeBaseInfo[]> {
    // è·å–çŸ¥è¯†åº“æ¦‚è§ˆ
    const response = await api.get('/dashboard/knowledge-bases')
    return response.data
  }
  
  // ... å…¶ä»–æ–¹æ³•å®ç°
}
```

#### 1.3.6 æ€§èƒ½ä¼˜åŒ–è§„æ ¼

1. **æ•°æ®ç¼“å­˜**: ç»Ÿè®¡æ•°æ®ç¼“å­˜5åˆ†é’Ÿï¼Œé¿å…é¢‘ç¹è®¡ç®—
2. **æ‡’åŠ è½½**: çŸ¥è¯†åº“ä¿¡æ¯æŒ‰éœ€åŠ è½½
3. **é˜²æŠ–ä¼˜åŒ–**: å¿«é€Ÿæ“ä½œæŒ‰é’®500msé˜²æŠ–
4. **è™šæ‹Ÿæ»šåŠ¨**: çŸ¥è¯†åº“åˆ—è¡¨æ”¯æŒè™šæ‹Ÿæ»šåŠ¨
5. **å¹¶å‘è¯·æ±‚**: ç»Ÿè®¡æ•°æ®å’ŒçŸ¥è¯†åº“ä¿¡æ¯å¹¶è¡ŒåŠ è½½

#### 1.3.7 ç”¨æˆ·äº¤äº’è§„æ ¼

1. **åŠ è½½çŠ¶æ€**: æ‰€æœ‰æ•°æ®åŠ è½½éƒ½æœ‰éª¨æ¶å±æˆ–åŠ è½½æŒ‡ç¤ºå™¨
2. **é”™è¯¯å¤„ç†**: æ•°æ®åŠ è½½å¤±è´¥æ˜¾ç¤ºå‹å¥½çš„é”™è¯¯ä¿¡æ¯å’Œé‡è¯•æŒ‰é’®
3. **å“åº”å¼è®¾è®¡**: ç§»åŠ¨ç«¯ç»Ÿè®¡å¡ç‰‡å‚ç›´æ’åˆ—
4. **æ— éšœç¢æ”¯æŒ**: å®Œæ•´çš„ARIAæ ‡ç­¾å’Œé”®ç›˜å¯¼èˆª
5. **åŠ¨ç”»æ•ˆæœ**: ç»Ÿè®¡æ•°å­—å˜åŒ–æ—¶çš„åŠ¨ç”»æ•ˆæœ

#### 1.3.8 æµ‹è¯•è§„æ ¼

```typescript
// å•å…ƒæµ‹è¯•è§„æ ¼
describe('Dashboard Store', () => {
  it('åº”è¯¥æ­£ç¡®è®¡ç®—å®Œæˆç‡', () => {
    // æµ‹è¯•å®Œæˆç‡è®¡ç®—é€»è¾‘
  })
  
  it('åº”è¯¥æ­£ç¡®è®¡ç®—å¤ä¹ è¿›åº¦', () => {
    // æµ‹è¯•å¤ä¹ è¿›åº¦è®¡ç®—é€»è¾‘
  })
  
  it('åº”è¯¥å¤„ç†æ•°æ®åŠ è½½é”™è¯¯', () => {
    // æµ‹è¯•é”™è¯¯å¤„ç†é€»è¾‘
  })
})

// E2Eæµ‹è¯•è§„æ ¼
describe('Dashboard Page', () => {
  it('åº”è¯¥æ˜¾ç¤ºæ­£ç¡®çš„ç»Ÿè®¡æ•°æ®', () => {
    // æµ‹è¯•ç»Ÿè®¡æ•°æ®æ˜¾ç¤º
  })
  
  it('å¿«é€Ÿæ“ä½œæŒ‰é’®åº”è¯¥æ­£ç¡®å¯¼èˆª', () => {
    // æµ‹è¯•å¿«é€Ÿæ“ä½œåŠŸèƒ½
  })
})
```

---

## ğŸ—ï¸ 2. çŸ¥è¯†ç®¡ç†æ¨¡å—åŠŸèƒ½è§„æ ¼

### 2.1 æ¨¡å—æ¦‚è¿°

çŸ¥è¯†ç®¡ç†æ¨¡å—æ˜¯ç³»ç»Ÿçš„æ ¸å¿ƒæ¨¡å—ï¼Œè´Ÿè´£ä¸‰çº§çŸ¥è¯†æ¶æ„ï¼ˆçŸ¥è¯†åº“â†’çŸ¥è¯†åŒºâ†’çŸ¥è¯†ç‚¹ï¼‰çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ŒåŒ…æ‹¬CRUDæ“ä½œã€æœç´¢ç­›é€‰ã€æ‰¹é‡æ“ä½œå’Œæ•°æ®å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ã€‚

### 2.2 ç°æœ‰å®ç°åˆ†æ

#### 2.2.1 æ ¸å¿ƒæ¶æ„åˆ†æ

**ä¸»æ§ç±»**: `KnowledgeManager`ç±» (1900è¡Œä»£ç )
- **èŒè´£**: ä¸‰çº§çŸ¥è¯†æ¶æ„ç®¡ç†ã€è§†å›¾åˆ‡æ¢ã€CRUDæ“ä½œã€æœç´¢ç­›é€‰
- **æ ¸å¿ƒçŠ¶æ€**:
  - `currentView`: å½“å‰è§†å›¾('base'|'area'|'points')
  - `currentBase`: å½“å‰çŸ¥è¯†åº“å¯¹è±¡
  - `currentArea`: å½“å‰çŸ¥è¯†åŒºå¯¹è±¡
  - `filteredPoints`: ç­›é€‰åçš„çŸ¥è¯†ç‚¹åˆ—è¡¨
  - `expandedPoints`: å±•å¼€çš„çŸ¥è¯†ç‚¹é›†åˆ

#### 2.2.2 ä¸‰çº§è§†å›¾æ¶æ„

```javascript
// ä¸‰çº§è§†å›¾åˆ‡æ¢é€»è¾‘
showBaseView()     // çŸ¥è¯†åº“é€‰æ‹©è§†å›¾
showAreaView()     // çŸ¥è¯†åŒºé€‰æ‹©è§†å›¾  
showPointsView()   // çŸ¥è¯†ç‚¹åˆ—è¡¨è§†å›¾

// è§†å›¾çŠ¶æ€ç®¡ç†
hideAllViews()     // éšè—æ‰€æœ‰è§†å›¾
refresh()          // åˆ·æ–°å½“å‰è§†å›¾
```

#### 2.2.3 çŸ¥è¯†åº“ç®¡ç†åŠŸèƒ½

```javascript
// çŸ¥è¯†åº“CRUDæ“ä½œ
renderKnowledgeBases()           // æ¸²æŸ“çŸ¥è¯†åº“ç½‘æ ¼
showCreateKnowledgeBaseModal()   // æ˜¾ç¤ºåˆ›å»ºæ¨¡æ€æ¡†
handleCreateKnowledgeBase()      // å¤„ç†åˆ›å»º/ç¼–è¾‘
editKnowledgeBase()              // ç¼–è¾‘çŸ¥è¯†åº“
deleteKnowledgeBase()            // åˆ é™¤çŸ¥è¯†åº“
getKnowledgeBaseStats()          // ç»Ÿè®¡ä¿¡æ¯

// çŸ¥è¯†åº“åŠŸèƒ½ç‰¹ç‚¹
- å›¾æ ‡å’Œé¢œè‰²è‡ªå®šä¹‰ï¼š8ç§å›¾æ ‡ Ã— 8ç§é¢œè‰²é€‰æ‹©
- è‡ªåŠ¨åˆ›å»ºç¤ºä¾‹çŸ¥è¯†åŒºåŠŸèƒ½
- ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤ºï¼šçŸ¥è¯†åŒºæ•°é‡ã€çŸ¥è¯†ç‚¹æ€»æ•°
- æ‰¹é‡åˆ é™¤ç¡®è®¤æœºåˆ¶
```

#### 2.2.4 çŸ¥è¯†åŒºç®¡ç†åŠŸèƒ½

```javascript
// çŸ¥è¯†åŒºCRUDæ“ä½œ
renderKnowledgeAreas()           // æ¸²æŸ“çŸ¥è¯†åŒºç½‘æ ¼
showCreateKnowledgeAreaModal()   // æ˜¾ç¤ºåˆ›å»ºæ¨¡æ€æ¡†
handleCreateKnowledgeArea()      // å¤„ç†åˆ›å»º/ç¼–è¾‘
editKnowledgeArea()              // ç¼–è¾‘çŸ¥è¯†åŒº
deleteKnowledgeArea()            // åˆ é™¤çŸ¥è¯†åŒº
startAreaReview()                // å¼€å§‹çŸ¥è¯†åŒºå¤ä¹ 

// çŸ¥è¯†åŒºåŠŸèƒ½ç‰¹ç‚¹
- é¢œè‰²ä¸»é¢˜è‡ªå®šä¹‰ï¼š8ç§æ¸å˜é¢œè‰²é€‰æ‹©
- å­¦ä¹ è¿›åº¦æ¡ï¼šæŒæ¡ç‡å¯è§†åŒ–æ˜¾ç¤º
- å¿«é€Ÿå¤ä¹ å…¥å£ï¼šä¸€é”®å¼€å§‹å¤ä¹ 
- ç»Ÿè®¡ä¿¡æ¯ï¼šçŸ¥è¯†ç‚¹æ•°é‡ã€æŒæ¡æƒ…å†µ
```

#### 2.2.5 çŸ¥è¯†ç‚¹ç®¡ç†åŠŸèƒ½

```javascript
// çŸ¥è¯†ç‚¹CRUDæ“ä½œ
loadKnowledgePoints()            // åŠ è½½çŸ¥è¯†ç‚¹åˆ—è¡¨
renderKnowledgePoints()          // æ¸²æŸ“çŸ¥è¯†ç‚¹åˆ—è¡¨
showAddKnowledgePointModal()     // æ˜¾ç¤ºæ·»åŠ æ¨¡æ€æ¡†
handleSaveKnowledgePoint()       // ä¿å­˜çŸ¥è¯†ç‚¹
editKnowledgePoint()             // ç¼–è¾‘çŸ¥è¯†ç‚¹
validateKnowledgePointForm()     // è¡¨å•éªŒè¯
collectKnowledgePointData()      // æ”¶é›†è¡¨å•æ•°æ®

// é¢˜å‹æ”¯æŒ
- å¡«ç©ºé¢˜ï¼šé—®é¢˜ + ç­”æ¡ˆ + è§£é‡Š
- å•é€‰é¢˜ï¼šé—®é¢˜ + é€‰é¡¹ + æ­£ç¡®ç­”æ¡ˆ + åˆ†æ•°
- å¤šé€‰é¢˜ï¼šé—®é¢˜ + é€‰é¡¹ + å¤šä¸ªæ­£ç¡®ç­”æ¡ˆ + åˆ†æ•°

// é«˜çº§åŠŸèƒ½
- å±•å¼€/æ”¶èµ·ï¼štogglePoint(), expandAllPoints(), collapseAllPoints()
- æœç´¢åŠŸèƒ½ï¼šhandleSearch() - æ”¯æŒé¢˜ç›®ã€ç­”æ¡ˆã€æ ‡ç­¾æœç´¢
- æ ‡ç­¾ç­›é€‰ï¼šhandleFilter(), updateTagFilter()
- å¤ä¹ çŠ¶æ€ï¼šgetReviewStatus() - æ˜¾ç¤ºæŒæ¡ç¨‹åº¦
```

#### 2.2.6 äº¤äº’åŠŸèƒ½åˆ†æ

1. **å¤æ‚è¡¨å•ç³»ç»Ÿ**: é€‰æ‹©é¢˜åŠ¨æ€é€‰é¡¹ç®¡ç†ï¼Œæ”¯æŒA-Zé€‰é¡¹æ ‡è®°
2. **å®æ—¶é¢„è§ˆ**: åˆ›å»ºçŸ¥è¯†åº“/çŸ¥è¯†åŒºæ—¶çš„å®æ—¶é¢„è§ˆåŠŸèƒ½
3. **æ™ºèƒ½éªŒè¯**: è¡¨å•éªŒè¯åŒ…å«ä¸šåŠ¡é€»è¾‘ï¼ˆå¦‚å¤šé€‰é¢˜æ­£ç¡®ç­”æ¡ˆæ•°é‡ï¼‰
4. **çŠ¶æ€åŒæ­¥**: å¤šä¸ªå…¨å±€çŠ¶æ€å¯¹è±¡ä¹‹é—´çš„å¤æ‚åŒæ­¥é€»è¾‘
5. **æ•°æ®å…³è”**: çŸ¥è¯†åº“ã€çŸ¥è¯†åŒºã€çŸ¥è¯†ç‚¹çš„ä¸‰çº§å…³è”å…³ç³»ç»´æŠ¤

#### 2.2.7 æ€§èƒ½ç‰¹ç‚¹

- **åŒæ­¥æ¸²æŸ“**: å¤§é‡DOMæ“ä½œå¯¼è‡´çš„æ€§èƒ½ç“¶é¢ˆ
- **é‡å¤è®¡ç®—**: æ¯æ¬¡æ¸²æŸ“éƒ½é‡æ–°è®¡ç®—ç»Ÿè®¡æ•°æ®
- **å†…å­˜æ³„æ¼**: å¤§é‡äº‹ä»¶ç›‘å¬å™¨æœªæ­£ç¡®æ¸…ç†
- **æ•°æ®å†—ä½™**: å¤šå¤„å­˜å‚¨ç›¸åŒçš„æ•°æ®å¼•ç”¨

#### 2.2.8 å­˜åœ¨é—®é¢˜

1. **å·¨å‹å•ä¸€ç±»**: 1900è¡Œä»£ç ï¼ŒèŒè´£è¿‡åº¦é›†ä¸­
2. **æ·±åº¦åµŒå¥—**: è§†å›¾åˆ‡æ¢é€»è¾‘å¤æ‚ï¼ŒçŠ¶æ€ç®¡ç†æ··ä¹±
3. **å…¨å±€ä¾èµ–**: å¼ºä¾èµ–`window.storageManager`ç­‰å…¨å±€å¯¹è±¡
4. **æµ‹è¯•å›°éš¾**: å¤æ‚çš„DOMæ“ä½œå’Œäº‹ä»¶ç»‘å®šéš¾ä»¥æµ‹è¯•
5. **æ•°æ®ä¸€è‡´æ€§**: å¤šçº§æ•°æ®å…³è”å®¹æ˜“å‡ºç°ä¸ä¸€è‡´é—®é¢˜

### 2.3 åŠŸèƒ½è§„æ ¼å®šä¹‰

#### 2.3.1 Vueç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// çŸ¥è¯†ç®¡ç†æ¨¡å—ç»„ä»¶æ ‘ç»“æ„
src/views/Knowledge/
â”œâ”€â”€ Knowledge.vue                    // ä¸»å®¹å™¨ç»„ä»¶
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ KnowledgeBase/
â”‚   â”‚   â”œâ”€â”€ KnowledgeBaseGrid.vue    // çŸ¥è¯†åº“ç½‘æ ¼
â”‚   â”‚   â”œâ”€â”€ KnowledgeBaseCard.vue    // çŸ¥è¯†åº“å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ CreateBaseModal.vue      // åˆ›å»ºçŸ¥è¯†åº“æ¨¡æ€æ¡†
â”‚   â”‚   â”œâ”€â”€ BaseIconSelector.vue     // å›¾æ ‡é€‰æ‹©å™¨
â”‚   â”‚   â””â”€â”€ BaseColorSelector.vue    // é¢œè‰²é€‰æ‹©å™¨
â”‚   â”œâ”€â”€ KnowledgeArea/
â”‚   â”‚   â”œâ”€â”€ KnowledgeAreaGrid.vue    // çŸ¥è¯†åŒºç½‘æ ¼
â”‚   â”‚   â”œâ”€â”€ KnowledgeAreaCard.vue    // çŸ¥è¯†åŒºå¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ CreateAreaModal.vue      // åˆ›å»ºçŸ¥è¯†åŒºæ¨¡æ€æ¡†
â”‚   â”‚   â””â”€â”€ AreaProgressBar.vue      // è¿›åº¦æ¡ç»„ä»¶
â”‚   â”œâ”€â”€ KnowledgePoint/
â”‚   â”‚   â”œâ”€â”€ KnowledgePointList.vue   // çŸ¥è¯†ç‚¹åˆ—è¡¨
â”‚   â”‚   â”œâ”€â”€ KnowledgePointCard.vue   // çŸ¥è¯†ç‚¹å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ PointEditor.vue          // çŸ¥è¯†ç‚¹ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ QuestionTypeSelector.vue // é¢˜å‹é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ ChoiceOptionsEditor.vue  // é€‰æ‹©é¢˜é€‰é¡¹ç¼–è¾‘å™¨
â”‚   â”‚   â””â”€â”€ TagsInput.vue            // æ ‡ç­¾è¾“å…¥ç»„ä»¶
â”‚   â”œâ”€â”€ Common/
â”‚   â”‚   â”œâ”€â”€ ViewSwitcher.vue         // è§†å›¾åˆ‡æ¢å™¨
â”‚   â”‚   â”œâ”€â”€ SearchBar.vue            // æœç´¢æ 
â”‚   â”‚   â”œâ”€â”€ FilterBar.vue            // ç­›é€‰æ 
â”‚   â”‚   â”œâ”€â”€ BreadcrumbNav.vue        // é¢åŒ…å±‘å¯¼èˆª
â”‚   â”‚   â””â”€â”€ ImportExportModal.vue    // å¯¼å…¥å¯¼å‡ºæ¨¡æ€æ¡†
â”‚   â””â”€â”€ Toolbar/
â”‚       â”œâ”€â”€ KnowledgeToolbar.vue     // å·¥å…·æ ä¸»ç»„ä»¶
â”‚       â”œâ”€â”€ ActionButtons.vue        // æ“ä½œæŒ‰é’®ç»„
â”‚       â””â”€â”€ ViewControls.vue         // è§†å›¾æ§åˆ¶å™¨
â””â”€â”€ composables/
    â”œâ”€â”€ useKnowledgeBase.ts          // çŸ¥è¯†åº“é€»è¾‘
    â”œâ”€â”€ useKnowledgeArea.ts          // çŸ¥è¯†åŒºé€»è¾‘
    â”œâ”€â”€ useKnowledgePoint.ts         // çŸ¥è¯†ç‚¹é€»è¾‘
    â”œâ”€â”€ useKnowledgeNavigation.ts    // å¯¼èˆªé€»è¾‘
    â”œâ”€â”€ useKnowledgeSearch.ts        // æœç´¢ç­›é€‰é€»è¾‘
    â””â”€â”€ useKnowledgeValidation.ts    // è¡¨å•éªŒè¯é€»è¾‘
```

#### 2.3.2 æ•°æ®æ¨¡å‹è§„æ ¼

```typescript
// types/knowledge.ts
export type KnowledgeView = 'base' | 'area' | 'points'

export interface KnowledgeBase {
  id: string
  name: string
  description: string
  icon: string
  color: string
  areas: KnowledgeArea[]
  metadata: {
    createdAt: string
    updatedAt: string
    createdBy?: string
    version: string
  }
}

export interface KnowledgeArea {
  id: string
  name: string
  description: string
  color: string
  metadata: {
    createdAt: string
    updatedAt: string
    order: number
  }
}

export interface KnowledgePoint {
  id: string
  knowledgeBaseId: string
  areaId: string
  type: 'fill' | 'choice'
  question: string
  explanation: string
  note: string
  category: string
  difficulty: number
  tags: string[]
  
  // å¡«ç©ºé¢˜å­—æ®µ
  answer?: string
  
  // é€‰æ‹©é¢˜å­—æ®µ
  choiceType?: 'single' | 'multiple'
  options?: ChoiceOption[]
  correctAnswer?: string
  score?: number
  
  // å¤ä¹ æ•°æ®
  reviewData: {
    easeFactor: number
    interval: number
    repetitions: number
    nextReviewDate: string
    lastReviewDate: string | null
    totalReviews: number
    correctCount: number
    averageResponseTime: number
    masteryLevel: number
  }
  
  // å…ƒæ•°æ®
  metadata: {
    createdAt: string
    updatedAt: string
    version: number
    importedFrom?: string
  }
}

export interface ChoiceOption {
  key: string
  text: string
}
```

#### 2.3.3 çŠ¶æ€ç®¡ç†è§„æ ¼

```typescript
// stores/knowledge.ts
export const useKnowledgeStore = defineStore('knowledge', () => {
  // æ ¸å¿ƒçŠ¶æ€
  const currentView = ref<KnowledgeView>('base')
  const currentBase = ref<KnowledgeBase | null>(null)
  const currentArea = ref<KnowledgeArea | null>(null)
  
  // æ•°æ®çŠ¶æ€
  const knowledgeBases = ref<KnowledgeBase[]>([])
  const knowledgePoints = ref<KnowledgePoint[]>([])
  const filteredPoints = ref<KnowledgePoint[]>([])
  
  // UIçŠ¶æ€
  const expandedPoints = ref<Set<string>>(new Set())
  const selectedPoints = ref<Set<string>>(new Set())
  const searchQuery = ref<string>('')
  const selectedTags = ref<string[]>([])
  
  // åŠ è½½çŠ¶æ€
  const loading = ref({
    bases: false,
    areas: false,
    points: false
  })
  
  // è®¡ç®—å±æ€§
  const currentAreas = computed(() => {
    return currentBase.value?.areas || []
  })
  
  const currentPoints = computed(() => {
    if (!currentArea.value) return []
    return knowledgePoints.value.filter(
      point => point.areaId === currentArea.value!.id
    )
  })
  
  const availableTags = computed(() => {
    const tags = new Set<string>()
    currentPoints.value.forEach(point => {
      point.tags.forEach(tag => tags.add(tag))
    })
    return Array.from(tags).sort()
  })
  
  const knowledgeStatistics = computed(() => ({
    totalBases: knowledgeBases.value.length,
    totalAreas: knowledgeBases.value.reduce((sum, base) => sum + base.areas.length, 0),
    totalPoints: knowledgePoints.value.length,
    masteredPoints: knowledgePoints.value.filter(
      point => point.reviewData.masteryLevel >= 0.8
    ).length,
    newPoints: knowledgePoints.value.filter(
      point => point.reviewData.totalReviews === 0
    ).length
  }))
  
  // æ“ä½œæ–¹æ³•
  const switchView = (view: KnowledgeView, id?: string) => {
    currentView.value = view
    
    switch (view) {
      case 'base':
        currentBase.value = null
        currentArea.value = null
        break
      case 'area':
        if (id) {
          const base = knowledgeBases.value.find(b => b.id === id)
          if (base) currentBase.value = base
        }
        currentArea.value = null
        break
      case 'points':
        if (id && currentBase.value) {
          const area = currentBase.value.areas.find(a => a.id === id)
          if (area) currentArea.value = area
        }
        break
    }
  }
  
  const applyFilters = () => {
    let filtered = currentPoints.value
    
    // æœç´¢è¿‡æ»¤
    if (searchQuery.value) {
      const query = searchQuery.value.toLowerCase()
      filtered = filtered.filter(point =>
        point.question.toLowerCase().includes(query) ||
        point.answer?.toLowerCase().includes(query) ||
        point.tags.some(tag => tag.toLowerCase().includes(query))
      )
    }
    
    // æ ‡ç­¾è¿‡æ»¤
    if (selectedTags.value.length > 0) {
      filtered = filtered.filter(point =>
        selectedTags.value.some(tag => point.tags.includes(tag))
      )
    }
    
    filteredPoints.value = filtered
  }
  
  // CRUDæ“ä½œ
  const createKnowledgeBase = async (data: CreateKnowledgeBaseData) => {
    const newBase = await knowledgeService.createKnowledgeBase(data)
    knowledgeBases.value.push(newBase)
    return newBase
  }
  
  const updateKnowledgeBase = async (id: string, data: UpdateKnowledgeBaseData) => {
    const updated = await knowledgeService.updateKnowledgeBase(id, data)
    const index = knowledgeBases.value.findIndex(base => base.id === id)
    if (index >= 0) {
      knowledgeBases.value[index] = updated
    }
    if (currentBase.value?.id === id) {
      currentBase.value = updated
    }
    return updated
  }
  
  const deleteKnowledgeBase = async (id: string) => {
    await knowledgeService.deleteKnowledgeBase(id)
    knowledgeBases.value = knowledgeBases.value.filter(base => base.id !== id)
    
    // æ¸…ç†ç›¸å…³çŠ¶æ€
    if (currentBase.value?.id === id) {
      currentBase.value = null
      currentArea.value = null
      switchView('base')
    }
    
    // åˆ é™¤ç›¸å…³çŸ¥è¯†ç‚¹
    knowledgePoints.value = knowledgePoints.value.filter(
      point => point.knowledgeBaseId !== id
    )
  }
  
  return {
    // çŠ¶æ€
    currentView: readonly(currentView),
    currentBase: readonly(currentBase),
    currentArea: readonly(currentArea),
    knowledgeBases: readonly(knowledgeBases),
    filteredPoints: readonly(filteredPoints),
    expandedPoints: readonly(expandedPoints),
    searchQuery: readonly(searchQuery),
    loading: readonly(loading),
    
    // è®¡ç®—å±æ€§
    currentAreas,
    currentPoints,
    availableTags,
    knowledgeStatistics,
    
    // æ“ä½œ
    switchView,
    createKnowledgeBase,
    updateKnowledgeBase,
    deleteKnowledgeBase,
    applyFilters
  }
})
```

#### 2.3.4 APIæ¥å£è§„æ ¼

```typescript
// services/api/knowledge.ts
export interface KnowledgeAPI {
  // çŸ¥è¯†åº“æ¥å£
  getAllKnowledgeBases(): Promise<KnowledgeBase[]>
  getKnowledgeBase(id: string): Promise<KnowledgeBase>
  createKnowledgeBase(data: CreateKnowledgeBaseData): Promise<KnowledgeBase>
  updateKnowledgeBase(id: string, data: UpdateKnowledgeBaseData): Promise<KnowledgeBase>
  deleteKnowledgeBase(id: string): Promise<void>
  
  // çŸ¥è¯†åŒºæ¥å£
  createKnowledgeArea(baseId: string, data: CreateKnowledgeAreaData): Promise<KnowledgeArea>
  updateKnowledgeArea(baseId: string, areaId: string, data: UpdateKnowledgeAreaData): Promise<KnowledgeArea>
  deleteKnowledgeArea(baseId: string, areaId: string): Promise<void>
  
  // çŸ¥è¯†ç‚¹æ¥å£
  getAllKnowledgePoints(): Promise<KnowledgePoint[]>
  getKnowledgePointsByArea(areaId: string): Promise<KnowledgePoint[]>
  getKnowledgePoint(id: string): Promise<KnowledgePoint>
  createKnowledgePoint(data: CreateKnowledgePointData): Promise<KnowledgePoint>
  updateKnowledgePoint(id: string, data: UpdateKnowledgePointData): Promise<KnowledgePoint>
  deleteKnowledgePoint(id: string): Promise<void>
  batchDeleteKnowledgePoints(ids: string[]): Promise<void>
  
  // æœç´¢å’Œç­›é€‰æ¥å£
  searchKnowledgePoints(filter: KnowledgeSearchFilter): Promise<KnowledgePoint[]>
  getKnowledgeStatistics(): Promise<KnowledgeStatistics>
  
  // å¯¼å…¥å¯¼å‡ºæ¥å£
  importKnowledgeBase(file: File, options: ImportOptions): Promise<ImportResult>
  exportKnowledgeBase(baseId: string, format: ExportFormat): Promise<ExportResult>
}

// REST API ç«¯ç‚¹è®¾è®¡
const API_ENDPOINTS = {
  // çŸ¥è¯†åº“
  KNOWLEDGE_BASES: '/api/knowledge-bases',
  KNOWLEDGE_BASE: '/api/knowledge-bases/:id',
  
  // çŸ¥è¯†åŒº
  KNOWLEDGE_AREAS: '/api/knowledge-bases/:baseId/areas',
  KNOWLEDGE_AREA: '/api/knowledge-bases/:baseId/areas/:areaId',
  
  // çŸ¥è¯†ç‚¹
  KNOWLEDGE_POINTS: '/api/knowledge-points',
  KNOWLEDGE_POINT: '/api/knowledge-points/:id',
  KNOWLEDGE_POINTS_BY_AREA: '/api/knowledge-areas/:areaId/points',
  KNOWLEDGE_POINTS_SEARCH: '/api/knowledge-points/search',
  KNOWLEDGE_POINTS_BATCH: '/api/knowledge-points/batch',
  
  // ç»Ÿè®¡å’Œåˆ†æ
  KNOWLEDGE_STATISTICS: '/api/knowledge/statistics',
  
  // å¯¼å…¥å¯¼å‡º
  KNOWLEDGE_IMPORT: '/api/knowledge/import',
  KNOWLEDGE_EXPORT: '/api/knowledge/export/:baseId'
}
```

#### 2.3.5 ç»„ä»¶å®ç°è§„æ ¼

```vue
<!-- views/Knowledge/Knowledge.vue -->
<template>
  <div class="knowledge">
    <!-- é¢åŒ…å±‘å¯¼èˆª -->
    <BreadcrumbNav 
      :current-view="currentView"
      :current-base="currentBase"
      :current-area="currentArea"
      @navigate="handleNavigate"
    />
    
    <!-- å·¥å…·æ  -->
    <KnowledgeToolbar
      :current-view="currentView"
      :loading="loading"
      @create="handleCreate"
      @import="handleImport"
      @export="handleExport"
    />
    
    <!-- è§†å›¾å†…å®¹ -->
    <Transition name="view-switch" mode="out-in">
      <!-- çŸ¥è¯†åº“è§†å›¾ -->
      <KnowledgeBaseGrid
        v-if="currentView === 'base'"
        :knowledge-bases="knowledgeBases"
        :loading="loading.bases"
        @select="handleSelectBase"
        @edit="handleEditBase"
        @delete="handleDeleteBase"
      />
      
      <!-- çŸ¥è¯†åŒºè§†å›¾ -->
      <KnowledgeAreaGrid
        v-else-if="currentView === 'area'"
        :knowledge-areas="currentAreas"
        :current-base="currentBase"
        :loading="loading.areas"
        @select="handleSelectArea"
        @edit="handleEditArea"
        @delete="handleDeleteArea"
        @review="handleStartAreaReview"
      />
      
      <!-- çŸ¥è¯†ç‚¹è§†å›¾ -->
      <div v-else-if="currentView === 'points'" class="knowledge-points-view">
        <!-- æœç´¢å’Œç­›é€‰ -->
        <div class="knowledge-controls">
          <SearchBar
            v-model="searchQuery"
            placeholder="æœç´¢çŸ¥è¯†ç‚¹..."
            @search="handleSearch"
          />
          <FilterBar
            :available-tags="availableTags"
            :selected-tags="selectedTags"
            @update-tags="handleUpdateTags"
            @clear="handleClearFilters"
          />
        </div>
        
        <!-- çŸ¥è¯†ç‚¹åˆ—è¡¨ -->
        <KnowledgePointList
          :knowledge-points="filteredPoints"
          :expanded-points="expandedPoints"
          :selected-points="selectedPoints"
          :loading="loading.points"
          @toggle-expansion="handleToggleExpansion"
          @edit="handleEditPoint"
          @delete="handleDeletePoint"
          @batch-delete="handleBatchDeletePoints"
        />
      </div>
    </Transition>
    
    <!-- æ¨¡æ€æ¡† -->
    <CreateBaseModal
      v-model:visible="showCreateBaseModal"
      :edit-data="editingBase"
      @save="handleSaveBase"
    />
    
    <CreateAreaModal
      v-model:visible="showCreateAreaModal"
      :edit-data="editingArea"
      @save="handleSaveArea"
    />
    
    <PointEditor
      v-model:visible="showPointEditor"
      :edit-data="editingPoint"
      :current-base="currentBase"
      :current-area="currentArea"
      @save="handleSavePoint"
    />
    
    <ImportExportModal
      v-model:visible="showImportExportModal"
      :mode="importExportMode"
      @import="handleImportFile"
      @export="handleExportFile"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, onMounted, ref } from 'vue'
import { useKnowledgeStore } from '@/stores/knowledge'
import { useRouter } from 'vue-router'

const knowledgeStore = useKnowledgeStore()
const router = useRouter()

// è®¡ç®—å±æ€§
const currentView = computed(() => knowledgeStore.currentView)
const currentBase = computed(() => knowledgeStore.currentBase)
const currentArea = computed(() => knowledgeStore.currentArea)
const knowledgeBases = computed(() => knowledgeStore.knowledgeBases)
const currentAreas = computed(() => knowledgeStore.currentAreas)
const filteredPoints = computed(() => knowledgeStore.filteredPoints)
const availableTags = computed(() => knowledgeStore.availableTags)
const expandedPoints = computed(() => knowledgeStore.expandedPoints)
const loading = computed(() => knowledgeStore.loading)

// å“åº”å¼çŠ¶æ€
const selectedPoints = ref<Set<string>>(new Set())
const searchQuery = ref('')
const selectedTags = ref<string[]>([])

// æ¨¡æ€æ¡†çŠ¶æ€
const showCreateBaseModal = ref(false)
const showCreateAreaModal = ref(false)
const showPointEditor = ref(false)
const showImportExportModal = ref(false)
const importExportMode = ref<'import' | 'export'>('import')

// ç¼–è¾‘çŠ¶æ€
const editingBase = ref<KnowledgeBase | null>(null)
const editingArea = ref<KnowledgeArea | null>(null)
const editingPoint = ref<KnowledgePoint | null>(null)

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await knowledgeStore.loadKnowledgeBases()
  await knowledgeStore.loadKnowledgePoints()
})

// äº‹ä»¶å¤„ç†
const handleNavigate = (view: KnowledgeView, id?: string) => {
  knowledgeStore.switchView(view, id)
}

const handleSelectBase = (base: KnowledgeBase) => {
  knowledgeStore.switchView('area', base.id)
}

const handleSelectArea = (area: KnowledgeArea) => {
  knowledgeStore.switchView('points', area.id)
}

const handleCreate = (type: 'base' | 'area' | 'point') => {
  switch (type) {
    case 'base':
      editingBase.value = null
      showCreateBaseModal.value = true
      break
    case 'area':
      editingArea.value = null
      showCreateAreaModal.value = true
      break
    case 'point':
      editingPoint.value = null
      showPointEditor.value = true
      break
  }
}

const handleSaveBase = async (data: CreateKnowledgeBaseData) => {
  if (editingBase.value) {
    await knowledgeStore.updateKnowledgeBase(editingBase.value.id, data)
  } else {
    await knowledgeStore.createKnowledgeBase(data)
  }
  showCreateBaseModal.value = false
  editingBase.value = null
}

const handleStartAreaReview = async (area: KnowledgeArea) => {
  // å¯åŠ¨çŸ¥è¯†åŒºå¤ä¹ 
  router.push({
    name: 'Review',
    query: { mode: 'area', areaId: area.id }
  })
}

const handleSearch = (query: string) => {
  searchQuery.value = query
  knowledgeStore.updateSearchQuery(query)
}

const handleUpdateTags = (tags: string[]) => {
  selectedTags.value = tags
  knowledgeStore.updateSelectedTags(tags)
}

const handleClearFilters = () => {
  searchQuery.value = ''
  selectedTags.value = []
  knowledgeStore.clearFilters()
}
</script>
```

#### 2.3.6 æ€§èƒ½ä¼˜åŒ–è§„æ ¼

1. **è™šæ‹Ÿæ»šåŠ¨**: çŸ¥è¯†ç‚¹åˆ—è¡¨è¶…è¿‡100ä¸ªæ—¶ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
2. **æ‡’åŠ è½½**: çŸ¥è¯†ç‚¹å†…å®¹æŒ‰éœ€åŠ è½½ï¼Œå‡å°‘åˆå§‹æ¸²æŸ“æ—¶é—´
3. **ç¼“å­˜ç­–ç•¥**: çŸ¥è¯†åº“æ•°æ®ç¼“å­˜10åˆ†é’Ÿï¼ŒçŸ¥è¯†ç‚¹æœç´¢ç»“æœç¼“å­˜5åˆ†é’Ÿ
4. **é˜²æŠ–ä¼˜åŒ–**: æœç´¢è¾“å…¥300msé˜²æŠ–ï¼Œæ ‡ç­¾ç­›é€‰500msé˜²æŠ–
5. **åˆ†é¡µåŠ è½½**: çŸ¥è¯†ç‚¹åˆ—è¡¨æ”¯æŒåˆ†é¡µï¼Œæ¯é¡µ50ä¸ª
6. **å›¾ç‰‡æ‡’åŠ è½½**: çŸ¥è¯†ç‚¹ä¸­çš„å›¾ç‰‡æ”¯æŒæ‡’åŠ è½½
7. **é¢„åŠ è½½**: åˆ‡æ¢åˆ°çŸ¥è¯†åŒºè§†å›¾æ—¶é¢„åŠ è½½çŸ¥è¯†ç‚¹æ•°æ®

#### 2.3.7 ç”¨æˆ·äº¤äº’è§„æ ¼

1. **æ‹–æ‹½æ’åº**: çŸ¥è¯†åŒºå’ŒçŸ¥è¯†ç‚¹æ”¯æŒæ‹–æ‹½æ’åº
2. **æ‰¹é‡æ“ä½œ**: æ”¯æŒå¤šé€‰çŸ¥è¯†ç‚¹è¿›è¡Œæ‰¹é‡åˆ é™¤ã€ç§»åŠ¨
3. **å¿«æ·é”®**: 
   - `Ctrl+N`: æ–°å»ºçŸ¥è¯†ç‚¹
   - `Ctrl+F`: èšç„¦æœç´¢æ¡†
   - `Ctrl+A`: å…¨é€‰çŸ¥è¯†ç‚¹
   - `Delete`: åˆ é™¤é€‰ä¸­é¡¹
4. **å³é”®èœå•**: çŸ¥è¯†ç‚¹å¡ç‰‡æ”¯æŒå³é”®ä¸Šä¸‹æ–‡èœå•
5. **å®æ—¶åŒæ­¥**: å¤šæ ‡ç­¾é¡µæ•°æ®å®æ—¶åŒæ­¥

#### 2.3.8 æµ‹è¯•è§„æ ¼

```typescript
// å•å…ƒæµ‹è¯•è§„æ ¼
describe('Knowledge Store', () => {
  it('åº”è¯¥æ­£ç¡®åˆ‡æ¢è§†å›¾çŠ¶æ€', () => {
    // æµ‹è¯•è§†å›¾åˆ‡æ¢é€»è¾‘
  })
  
  it('åº”è¯¥æ­£ç¡®åº”ç”¨æœç´¢è¿‡æ»¤', () => {
    // æµ‹è¯•æœç´¢ç­›é€‰åŠŸèƒ½
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†CRUDæ“ä½œ', () => {
    // æµ‹è¯•åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤æ“ä½œ
  })
})

// é›†æˆæµ‹è¯•è§„æ ¼
describe('Knowledge Module Integration', () => {
  it('åº”è¯¥æ­£ç¡®å¤„ç†ä¸‰çº§å¯¼èˆª', () => {
    // æµ‹è¯•çŸ¥è¯†åº“â†’çŸ¥è¯†åŒºâ†’çŸ¥è¯†ç‚¹çš„å¯¼èˆªæµç¨‹
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†æ•°æ®åŒæ­¥', () => {
    // æµ‹è¯•æ•°æ®çš„ä¸€è‡´æ€§å’ŒåŒæ­¥
  })
})

// E2Eæµ‹è¯•è§„æ ¼
describe('Knowledge Management Flow', () => {
  it('ç”¨æˆ·å¯ä»¥åˆ›å»ºå®Œæ•´çš„çŸ¥è¯†ä½“ç³»', () => {
    // æµ‹è¯•å®Œæ•´çš„åˆ›å»ºæµç¨‹
  })
  
  it('ç”¨æˆ·å¯ä»¥æœç´¢å’Œç­›é€‰çŸ¥è¯†ç‚¹', () => {
    // æµ‹è¯•æœç´¢ç­›é€‰åŠŸèƒ½
  })
})
```

---

## ğŸ§  3. å¤ä¹ ç³»ç»Ÿæ¨¡å—åŠŸèƒ½è§„æ ¼

### 3.1 æ¨¡å—æ¦‚è¿°

å¤ä¹ ç³»ç»Ÿæ¨¡å—æ˜¯å®ç°æ™ºèƒ½å¤ä¹ è°ƒåº¦çš„æ ¸å¿ƒæ¨¡å—ï¼ŒåŸºäºæ”¹è¿›çš„SM-2ç®—æ³•å®ç°é—´éš”é‡å¤å­¦ä¹ ï¼Œæ”¯æŒå¤šç§å¤ä¹ æ¨¡å¼ã€è‡ªåŠ¨è¯„åˆ†ã€é”™é¢˜ç®¡ç†å’Œå­¦ä¹ ç»Ÿè®¡åˆ†æã€‚

### 3.2 ç°æœ‰å®ç°åˆ†æ

#### 3.2.1 æ ¸å¿ƒæ¶æ„åˆ†æ

**ä¸»æ§ç±»**: `ReviewManager`ç±» (2099è¡Œä»£ç )
- **èŒè´£**: å¤ä¹ ä¼šè¯ç®¡ç†ã€SM-2ç®—æ³•å®ç°ã€é¢˜ç›®æ¸²æŸ“ã€é”™é¢˜ç®¡ç†ã€ç»Ÿè®¡åˆ†æ
- **æ ¸å¿ƒçŠ¶æ€**:
  - `currentReviewList`: å½“å‰å¤ä¹ é¢˜ç›®åˆ—è¡¨
  - `currentIndex`: å½“å‰é¢˜ç›®ç´¢å¼•
  - `currentKnowledge`: å½“å‰çŸ¥è¯†ç‚¹
  - `reviewMode`: å¤ä¹ æ¨¡å¼æ ‡è¯†
  - `startTime`: å¼€å§‹æ—¶é—´æˆ³
  - `currentConfig`: å¤ä¹ é…ç½®å¯¹è±¡

#### 3.2.2 å¤ä¹ æ¨¡å¼ç³»ç»Ÿ

```javascript
// å¤šç§å¤ä¹ æ¨¡å¼æ”¯æŒ
reviewKnowledgeBase(baseId, options)    // çŸ¥è¯†åº“å¤ä¹ 
reviewKnowledgeArea(areaId, options)    // çŸ¥è¯†åŒºå¤ä¹ 
smartReview(options)                    // æ™ºèƒ½å¤ä¹ 
reviewMistakesByBase(baseId, options)   // çŸ¥è¯†åº“é”™é¢˜å¤ä¹ 
reviewMistakesByArea(areaId, options)   // çŸ¥è¯†åŒºé”™é¢˜å¤ä¹ 
reviewAllMistakes(options)              // å…¨éƒ¨é”™é¢˜å¤ä¹ 
reviewWeakness(options)                 // å¼±é¡¹å¼ºåŒ–å¤ä¹ 
customReview(customConfig)              // è‡ªå®šä¹‰å¤ä¹ 

// å¤ä¹ é…ç½®æ¨¡æ¿ç³»ç»Ÿ
window.QuestionListTemplates.knowledgeBaseReview()
window.QuestionListTemplates.knowledgeAreaReview()
window.QuestionListTemplates.smartReview()
window.QuestionListTemplates.mistakeReviewByBase()
```

#### 3.2.3 SM-2ç®—æ³•å®ç°

```javascript
// æ”¹è¿›çš„SM-2ç®—æ³•æ ¸å¿ƒ
calculateNextReview(easeFactor, interval, quality) {
  // quality: 1=é”™è¯¯, 2=æ¨¡ç³Š, 3=æ­£ç¡®
  
  if (quality === 1) {
    // é”™è¯¯ï¼šå¤§å¹…é™ä½ç†Ÿæ‚‰å› å­ï¼Œ6å°æ—¶åå¤ä¹ 
    return {
      interval: 1,
      easeFactor: Math.max(1.3, easeFactor - 0.3),
      nextReview: Date.now() + 6 * 60 * 60 * 1000
    };
  } else if (quality === 2) {
    // æ¨¡ç³Šï¼šè½»å¾®é™ä½ç†Ÿæ‚‰å› å­ï¼Œç¼©çŸ­é—´éš”
    return {
      interval: Math.max(1, Math.round(interval * 0.6)),
      easeFactor: Math.max(1.3, easeFactor - 0.1),
      nextReview: Date.now() + Math.max(1, Math.round(interval * 0.6)) * 24 * 60 * 60 * 1000
    };
  } else {
    // æ­£ç¡®ï¼šæé«˜ç†Ÿæ‚‰å› å­ï¼Œå»¶é•¿é—´éš”
    const newEaseFactor = Math.min(3.0, easeFactor + 0.15);
    let newInterval = interval === 1 ? 3 : Math.round(interval * newEaseFactor);
    
    return {
      interval: newInterval,
      easeFactor: newEaseFactor,
      nextReview: Date.now() + newInterval * 24 * 60 * 60 * 1000
    };
  }
}

// ä¸‰æ¡£è¯„åˆ†ç³»ç»Ÿ
1: 'é”™è¯¯' - ç«‹å³é‡æ–°å¤ä¹ ï¼Œå¤§å¹…é™ä½ç†Ÿæ‚‰å› å­
2: 'æ¨¡ç³Š' - çŸ­æœŸå†…å¤ä¹ ï¼Œè½»å¾®é™ä½ç†Ÿæ‚‰å› å­  
3: 'æ­£ç¡®' - æ­£å¸¸å»¶é•¿é—´éš”ï¼Œæé«˜ç†Ÿæ‚‰å› å­
```

#### 3.2.4 é¢˜ç›®æ¸²æŸ“ç³»ç»Ÿ

```javascript
// å¤šé¢˜å‹æ”¯æŒ
renderCurrentQuestion()     // ä¸»æ¸²æŸ“æ§åˆ¶å™¨
renderChoiceQuestion()      // é€‰æ‹©é¢˜ç•Œé¢æ¸²æŸ“
renderFillQuestion()        // å¡«ç©ºé¢˜ç•Œé¢æ¸²æŸ“

// é€‰æ‹©é¢˜ç‰¹æ€§
- å•é€‰é¢˜/å¤šé€‰é¢˜æ”¯æŒ
- A-Zé”®ç›˜å¿«æ·é”®é€‰æ‹©
- å®æ—¶ç­”æ¡ˆæ£€æŸ¥å’Œè‡ªåŠ¨è¯„åˆ†
- é€‰é¡¹æ ·å¼åŠ¨æ€æ›´æ–°

// å¡«ç©ºé¢˜ç‰¹æ€§  
- å¤šè¡Œæ–‡æœ¬è¾“å…¥æ”¯æŒ
- Ctrl+Enterå¿«é€Ÿæ˜¾ç¤ºç­”æ¡ˆ
- è‡ªåŠ¨é«˜åº¦è°ƒæ•´
- å®æ—¶ä¿å­˜ç”¨æˆ·ç­”æ¡ˆ
```

#### 3.2.5 é”™é¢˜ç®¡ç†ç³»ç»Ÿ

```javascript
// é”™é¢˜åˆ†ç±»å’Œç»Ÿè®¡
loadMistakesOverview()      // é”™é¢˜ç»Ÿè®¡æ¦‚è§ˆ
groupMistakesByArea()       // æŒ‰çŸ¥è¯†åŒºåˆ†ç»„
loadMistakesTabs()          // åˆ†ç±»æ ‡ç­¾ç”Ÿæˆ
loadAllMistakes()           // å…¨éƒ¨é”™é¢˜è§†å›¾
loadMistakesByArea()        // åˆ†åŒºé”™é¢˜è§†å›¾

// é”™é¢˜æ“ä½œ
addMistake()                // æ·»åŠ é”™é¢˜ï¼ˆè‡ªåŠ¨è§¦å‘ï¼‰
resolveMistake()            // æ ‡è®°ä¸ºå·²æŒæ¡
deleteMistake()             // åˆ é™¤é”™é¢˜
clearResolvedMistakes()     // æ¸…ç†å·²æŒæ¡é”™é¢˜

// é”™é¢˜å¤ä¹ 
reviewAreaMistakes()        // å¤ä¹ çŸ¥è¯†åŒºé”™é¢˜
startAllMistakesReview()    // å¤ä¹ å…¨éƒ¨é”™é¢˜
```

#### 3.2.6 ä¼šè¯ç®¡ç†ç³»ç»Ÿ

```javascript
// å¤ä¹ ä¼šè¯æ§åˆ¶
startReviewWithConfig()     // ç»Ÿä¸€ä¼šè¯å¯åŠ¨å™¨
getCurrentSessionInfo()     // è·å–ä¼šè¯ä¿¡æ¯
refreshCurrentSession()     // åˆ·æ–°ä¼šè¯
resetReviewState()          // é‡ç½®ä¼šè¯çŠ¶æ€

// è¿›åº¦ç®¡ç†
updateProgress()            // æ›´æ–°è¿›åº¦æ¡
updateNavigationButtons()   // æ›´æ–°å¯¼èˆªæŒ‰é’®
nextQuestion()              // ä¸‹ä¸€é¢˜
previousQuestion()          // ä¸Šä¸€é¢˜
completeReview()           // å®Œæˆå¤ä¹ 
```

#### 3.2.7 ç”¨æˆ·äº¤äº’ç³»ç»Ÿ

```javascript
// é”®ç›˜å¿«æ·é”®æ”¯æŒ
- å·¦å³ç®­å¤´ï¼šé¢˜ç›®å¯¼èˆª
- A-Zé”®ï¼šé€‰æ‹©é¢˜é€‰é¡¹é€‰æ‹©  
- Enterï¼šæäº¤é€‰æ‹©é¢˜ç­”æ¡ˆ
- Ctrl+Enterï¼šæ˜¾ç¤º/éšè—ç­”æ¡ˆ

// è¾“å…¥ç„¦ç‚¹ç®¡ç†
- é˜²æ­¢è¾“å…¥æ¡†å†…æŒ‰é”®å†²çª
- æ™ºèƒ½ç„¦ç‚¹çŠ¶æ€æ£€æµ‹
- äº‹ä»¶å†’æ³¡æ§åˆ¶

// ç¬”è®°ç³»ç»Ÿ
toggleNote()               // åˆ‡æ¢ç¬”è®°æ˜¾ç¤º
updateCurrentNote()        // æ›´æ–°ç¬”è®°å†…å®¹
```

#### 3.2.8 å­˜åœ¨é—®é¢˜

1. **å·¨å‹å•ä¸€ç±»**: 2099è¡Œä»£ç ï¼ŒèŒè´£è¿‡åº¦é›†ä¸­ï¼Œéš¾ä»¥ç»´æŠ¤
2. **å¤æ‚DOMæ“ä½œ**: å¤§é‡ç›´æ¥DOMæ“ä½œï¼Œæ€§èƒ½å·®ä¸”éš¾ä»¥æµ‹è¯•
3. **äº‹ä»¶ç®¡ç†æ··ä¹±**: å¤æ‚çš„äº‹ä»¶ç»‘å®šå’Œæ¸…ç†é€»è¾‘ï¼Œå®¹æ˜“å†…å­˜æ³„æ¼
4. **çŠ¶æ€ç®¡ç†åˆ†æ•£**: å¤šä¸ªå…¨å±€çŠ¶æ€å¯¹è±¡ï¼Œæ•°æ®ä¸€è‡´æ€§éš¾ä¿è¯
5. **ç®—æ³•ä¸UIè€¦åˆ**: SM-2ç®—æ³•ä¸ç•Œé¢æ¸²æŸ“æ··åˆï¼Œéš¾ä»¥ç‹¬ç«‹æµ‹è¯•
6. **ç¡¬ç¼–ç ä¾èµ–**: å¼ºä¾èµ–å…¨å±€å¯¹è±¡ï¼Œå¯æµ‹è¯•æ€§å’Œå¯ç»´æŠ¤æ€§å·®

### 3.3 åŠŸèƒ½è§„æ ¼å®šä¹‰

#### 3.3.1 Vueç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// å¤ä¹ ç³»ç»Ÿæ¨¡å—ç»„ä»¶æ ‘ç»“æ„
src/views/Review/
â”œâ”€â”€ Review.vue                           // ä¸»å®¹å™¨ç»„ä»¶
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ReviewModes/
â”‚   â”‚   â”œâ”€â”€ ReviewModeSelector.vue       // å¤ä¹ æ¨¡å¼é€‰æ‹©å™¨
â”‚   â”‚   â”œâ”€â”€ ModeCard.vue                 // æ¨¡å¼å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ SmartReviewConfig.vue        // æ™ºèƒ½å¤ä¹ é…ç½®
â”‚   â”‚   â””â”€â”€ CustomReviewConfig.vue       // è‡ªå®šä¹‰å¤ä¹ é…ç½®
â”‚   â”œâ”€â”€ ReviewSession/
â”‚   â”‚   â”œâ”€â”€ ReviewCard.vue               // å¤ä¹ å¡ç‰‡ä¸»ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ QuestionRenderer.vue         // é¢˜ç›®æ¸²æŸ“å™¨
â”‚   â”‚   â”œâ”€â”€ ChoiceQuestion.vue           // é€‰æ‹©é¢˜ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ FillQuestion.vue             // å¡«ç©ºé¢˜ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ AnswerSection.vue            // ç­”æ¡ˆåŒºåŸŸ
â”‚   â”‚   â”œâ”€â”€ RatingButtons.vue            // è¯„åˆ†æŒ‰é’®ç»„
â”‚   â”‚   â””â”€â”€ QuestionNote.vue             // é¢˜ç›®ç¬”è®°
â”‚   â”œâ”€â”€ Navigation/
â”‚   â”‚   â”œâ”€â”€ ReviewProgress.vue           // å¤ä¹ è¿›åº¦æ¡
â”‚   â”‚   â”œâ”€â”€ QuestionNavigation.vue       // é¢˜ç›®å¯¼èˆª
â”‚   â”‚   â”œâ”€â”€ SessionInfo.vue              // ä¼šè¯ä¿¡æ¯
â”‚   â”‚   â””â”€â”€ ReviewStats.vue              // å¤ä¹ ç»Ÿè®¡
â”‚   â”œâ”€â”€ Mistakes/
â”‚   â”‚   â”œâ”€â”€ MistakesOverview.vue         // é”™é¢˜æ¦‚è§ˆ
â”‚   â”‚   â”œâ”€â”€ MistakesTabs.vue             // é”™é¢˜åˆ†ç±»æ ‡ç­¾
â”‚   â”‚   â”œâ”€â”€ MistakesList.vue             // é”™é¢˜åˆ—è¡¨
â”‚   â”‚   â”œâ”€â”€ MistakeCard.vue              // é”™é¢˜å¡ç‰‡
â”‚   â”‚   â””â”€â”€ MistakeActions.vue           // é”™é¢˜æ“ä½œ
â”‚   â””â”€â”€ Results/
â”‚       â”œâ”€â”€ ReviewComplete.vue           // å¤ä¹ å®Œæˆé¡µ
â”‚       â”œâ”€â”€ SessionSummary.vue           // ä¼šè¯æ€»ç»“
â”‚       â”œâ”€â”€ PerformanceChart.vue         // è¡¨ç°å›¾è¡¨
â”‚       â””â”€â”€ NextReviewHint.vue           // ä¸‹æ¬¡å¤ä¹ æç¤º
â””â”€â”€ composables/
    â”œâ”€â”€ useReviewSession.ts              // å¤ä¹ ä¼šè¯é€»è¾‘
    â”œâ”€â”€ useSpacedRepetition.ts           // SM-2ç®—æ³•é€»è¾‘
    â”œâ”€â”€ useQuestionRenderer.ts           // é¢˜ç›®æ¸²æŸ“é€»è¾‘
    â”œâ”€â”€ useReviewModes.ts                // å¤ä¹ æ¨¡å¼é€»è¾‘
    â”œâ”€â”€ useMistakeManager.ts             // é”™é¢˜ç®¡ç†é€»è¾‘
    â”œâ”€â”€ useReviewStats.ts                // ç»Ÿè®¡åˆ†æé€»è¾‘
    â”œâ”€â”€ useKeyboardShortcuts.ts          // é”®ç›˜å¿«æ·é”®
    â””â”€â”€ useReviewNavigation.ts           // å¯¼èˆªæ§åˆ¶é€»è¾‘
```

#### 3.3.2 æ•°æ®æ¨¡å‹è§„æ ¼

```typescript
// types/review.ts
export type ReviewMode = 
  | 'smart' 
  | 'knowledge-base' 
  | 'knowledge-area' 
  | 'mistakes' 
  | 'weakness' 
  | 'custom'

export type QuestionType = 'fill' | 'choice'

export type ReviewRating = 1 | 2 | 3

export interface ReviewSession {
  id: string
  mode: ReviewMode
  config: ReviewConfig
  questions: ReviewQuestion[]
  currentIndex: number
  startTime: string
  endTime?: string
  status: 'active' | 'paused' | 'completed' | 'abandoned'
  metadata: {
    totalQuestions: number
    completedQuestions: number
    correctCount: number
    timeSpent: number
    averageResponseTime: number
  }
}

export interface ReviewConfig {
  mode: ReviewMode
  source: {
    type: 'knowledge-base' | 'knowledge-area' | 'mistakes' | 'smart' | 'custom'
    params: Record<string, any>
  }
  sorter: {
    type: 'random' | 'by-priority' | 'by-difficulty' | 'by-created-time'
    params?: Record<string, any>
  }
  filter?: {
    difficulty?: number[]
    tags?: string[]
    reviewStatus?: ('new' | 'learning' | 'mastered')[]
    questionType?: QuestionType[]
  }
  limit?: number
  options: {
    showAnswer: boolean
    autoRate: boolean
    enableHints: boolean
    shuffleOptions: boolean
  }
}

export interface ReviewQuestion {
  id: string
  knowledgeId: string
  type: QuestionType
  question: string
  
  // å¡«ç©ºé¢˜å­—æ®µ
  answer?: string
  
  // é€‰æ‹©é¢˜å­—æ®µ
  choiceType?: 'single' | 'multiple'
  options?: ChoiceOption[]
  correctAnswer?: string
  score?: number
  
  // å¤ä¹ ç›¸å…³
  explanation: string
  note: string
  difficulty: number
  tags: string[]
  
  // ä¼šè¯ä¸­çš„çŠ¶æ€
  userAnswer?: string
  rating?: ReviewRating
  isCorrect?: boolean
  responseTime?: number
  attempts: number
  isAnswered: boolean
  isSkipped: boolean
}

export interface SpacedRepetitionData {
  easeFactor: number
  interval: number
  repetitions: number
  nextReviewDate: string
  lastReviewDate: string | null
  totalReviews: number
  correctCount: number
  averageResponseTime: number
  masteryLevel: number
  
  // å­¦ä¹ æ›²çº¿æ•°æ®
  learningHistory: ReviewRecord[]
}

export interface ReviewRecord {
  id: string
  knowledgeId: string
  sessionId: string
  reviewDate: string
  rating: ReviewRating
  isCorrect: boolean
  responseTime: number
  userAnswer: string
  questionType: QuestionType
  difficulty: number
  
  // SM-2ç®—æ³•å¿«ç…§
  easeFactor: number
  interval: number
  nextReviewDate: string
}

export interface MistakeRecord {
  id: string
  knowledgeId: string
  sessionId: string
  addedDate: string
  reason: string
  userAnswer: string
  questionType: QuestionType
  
  // é”™é¢˜çŠ¶æ€
  isResolved: boolean
  resolvedDate?: string
  retryCount: number
  lastRetryDate?: string
  
  // åˆ†ç±»ä¿¡æ¯
  knowledgeBaseId: string
  areaId: string
  category: string
  tags: string[]
}

export interface ReviewStatistics {
  // åŸºç¡€ç»Ÿè®¡
  totalSessions: number
  totalQuestions: number
  totalTimeSpent: number
  
  // å‡†ç¡®ç‡ç»Ÿè®¡
  overallAccuracy: number
  recentAccuracy: number
  accuracyByDifficulty: Record<number, number>
  accuracyByType: Record<QuestionType, number>
  
  // è¿›åº¦ç»Ÿè®¡
  masteredCount: number
  learningCount: number
  newCount: number
  mistakeCount: number
  
  // å¤ä¹ é¢‘ç‡
  dailyReviewCount: number[]
  weeklyReviewCount: number[]
  monthlyReviewCount: number[]
  
  // å­¦ä¹ æ•ˆç‡
  averageSessionTime: number
  averageQuestionTime: number
  optimalReviewTime: number
  
  // çŸ¥è¯†ç‚¹åˆ†å¸ƒ
  difficultyDistribution: Record<number, number>
  categoryDistribution: Record<string, number>
  tagDistribution: Record<string, number>
  
  // é¢„æµ‹æ•°æ®
  nextReviewCount: number
  weeklyReviewPlan: ReviewPlan[]
  learningTrend: 'improving' | 'stable' | 'declining'
}

export interface ReviewPlan {
  date: string
  plannedReviews: number
  priority: 'high' | 'medium' | 'low'
  categories: string[]
}
```

#### 3.3.3 çŠ¶æ€ç®¡ç†è§„æ ¼

```typescript
// stores/review.ts
export const useReviewStore = defineStore('review', () => {
  // æ ¸å¿ƒçŠ¶æ€
  const currentSession = ref<ReviewSession | null>(null)
  const activeConfig = ref<ReviewConfig | null>(null)
  const reviewHistory = ref<ReviewRecord[]>([])
  const mistakeRecords = ref<MistakeRecord[]>([])
  
  // UIçŠ¶æ€
  const isReviewing = ref(false)
  const showAnswer = ref(false)
  const isAutoRating = ref(false)
  const isNavigationLocked = ref(false)
  
  // åŠ è½½çŠ¶æ€
  const loading = ref({
    session: false,
    questions: false,
    statistics: false
  })
  
  // è®¡ç®—å±æ€§
  const currentQuestion = computed(() => {
    if (!currentSession.value) return null
    const session = currentSession.value
    return session.questions[session.currentIndex] || null
  })
  
  const sessionProgress = computed(() => {
    if (!currentSession.value) return 0
    const session = currentSession.value
    return session.questions.length > 0 
      ? (session.currentIndex / session.questions.length) * 100 
      : 0
  })
  
  const sessionStats = computed(() => {
    if (!currentSession.value) return null
    
    const session = currentSession.value
    const completed = session.questions.slice(0, session.currentIndex)
    const correct = completed.filter(q => q.isCorrect).length
    const totalTime = Date.now() - new Date(session.startTime).getTime()
    
    return {
      totalQuestions: session.questions.length,
      completedQuestions: session.currentIndex,
      remainingQuestions: session.questions.length - session.currentIndex,
      correctCount: correct,
      accuracy: completed.length > 0 ? (correct / completed.length) * 100 : 0,
      timeSpent: totalTime,
      averageTimePerQuestion: completed.length > 0 ? totalTime / completed.length : 0,
      estimatedTimeRemaining: completed.length > 0 
        ? (totalTime / completed.length) * (session.questions.length - session.currentIndex)
        : 0
    }
  })
  
  const mistakeStatistics = computed(() => {
    const active = mistakeRecords.value.filter(m => !m.isResolved)
    const resolved = mistakeRecords.value.filter(m => m.isResolved)
    
    // æŒ‰çŸ¥è¯†åŒºåˆ†ç»„
    const byArea = active.reduce((acc, mistake) => {
      const area = mistake.category || 'æœªåˆ†ç±»'
      if (!acc[area]) acc[area] = []
      acc[area].push(mistake)
      return acc
    }, {} as Record<string, MistakeRecord[]>)
    
    // æŒ‰é¢˜å‹åˆ†ç»„
    const byType = active.reduce((acc, mistake) => {
      if (!acc[mistake.questionType]) acc[mistake.questionType] = 0
      acc[mistake.questionType]++
      return acc
    }, {} as Record<QuestionType, number>)
    
    return {
      totalMistakes: active.length,
      resolvedMistakes: resolved.length,
      byArea,
      byType,
      recentMistakes: active.filter(m => {
        const addedDate = new Date(m.addedDate)
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
        return addedDate >= weekAgo
      }).length
    }
  })
  
  // ä¼šè¯ç®¡ç†
  const startReviewSession = async (config: ReviewConfig) => {
    loading.value.session = true
    try {
      // ç”Ÿæˆé¢˜ç›®åˆ—è¡¨
      const questions = await questionGenerator.generateQuestions(config)
      
      if (questions.length === 0) {
        throw new Error('æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„é¢˜ç›®')
      }
      
      // åˆ›å»ºæ–°ä¼šè¯
      const session: ReviewSession = {
        id: generateSessionId(),
        mode: config.mode,
        config,
        questions,
        currentIndex: 0,
        startTime: new Date().toISOString(),
        status: 'active',
        metadata: {
          totalQuestions: questions.length,
          completedQuestions: 0,
          correctCount: 0,
          timeSpent: 0,
          averageResponseTime: 0
        }
      }
      
      currentSession.value = session
      activeConfig.value = config
      isReviewing.value = true
      showAnswer.value = false
      
      // ä¿å­˜ä¼šè¯åˆ°å†å²
      await reviewService.saveSession(session)
      
      return session
    } finally {
      loading.value.session = false
    }
  }
  
  const submitAnswer = async (answer: string, rating: ReviewRating) => {
    if (!currentSession.value || !currentQuestion.value) return
    
    const question = currentQuestion.value
    const responseTime = Date.now() - new Date(currentSession.value.startTime).getTime()
    
    // æ›´æ–°é¢˜ç›®çŠ¶æ€
    question.userAnswer = answer
    question.rating = rating
    question.responseTime = responseTime
    question.isAnswered = true
    question.attempts++
    
    // åˆ¤æ–­æ­£ç¡®æ€§
    const isCorrect = await questionValidator.validateAnswer(question, answer)
    question.isCorrect = isCorrect
    
    // æ›´æ–°çŸ¥è¯†ç‚¹çš„å¤ä¹ æ•°æ®
    await updateKnowledgeReviewData(question.knowledgeId, rating, isCorrect)
    
    // è®°å½•å¤ä¹ å†å²
    const record: ReviewRecord = {
      id: generateRecordId(),
      knowledgeId: question.knowledgeId,
      sessionId: currentSession.value.id,
      reviewDate: new Date().toISOString(),
      rating,
      isCorrect,
      responseTime,
      userAnswer: answer,
      questionType: question.type,
      difficulty: question.difficulty,
      easeFactor: 0, // ä»çŸ¥è¯†ç‚¹æ•°æ®è·å–
      interval: 0,
      nextReviewDate: ''
    }
    
    reviewHistory.value.push(record)
    await reviewService.saveReviewRecord(record)
    
    // å¦‚æœæ˜¯é”™è¯¯ç­”æ¡ˆï¼Œæ·»åŠ åˆ°é”™é¢˜æœ¬
    if (!isCorrect) {
      await addMistakeRecord(question, answer)
    }
    
    // æ›´æ–°ä¼šè¯ç»Ÿè®¡
    updateSessionMetadata()
  }
  
  const nextQuestion = () => {
    if (!currentSession.value) return
    
    if (currentSession.value.currentIndex < currentSession.value.questions.length - 1) {
      currentSession.value.currentIndex++
      showAnswer.value = false
    } else {
      completeSession()
    }
  }
  
  const previousQuestion = () => {
    if (!currentSession.value) return
    
    if (currentSession.value.currentIndex > 0) {
      currentSession.value.currentIndex--
      showAnswer.value = false
    }
  }
  
  const completeSession = async () => {
    if (!currentSession.value) return
    
    currentSession.value.status = 'completed'
    currentSession.value.endTime = new Date().toISOString()
    
    // ä¿å­˜å®Œæˆçš„ä¼šè¯
    await reviewService.updateSession(currentSession.value)
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    await updateReviewStatistics()
    
    isReviewing.value = false
  }
  
  const pauseSession = async () => {
    if (!currentSession.value) return
    
    currentSession.value.status = 'paused'
    await reviewService.updateSession(currentSession.value)
    
    isReviewing.value = false
  }
  
  const resumeSession = () => {
    if (!currentSession.value) return
    
    currentSession.value.status = 'active'
    isReviewing.value = true
  }
  
  // SM-2ç®—æ³•å®ç°
  const updateKnowledgeReviewData = async (
    knowledgeId: string, 
    rating: ReviewRating, 
    isCorrect: boolean
  ) => {
    const knowledge = await knowledgeService.getKnowledge(knowledgeId)
    if (!knowledge) return
    
    const spacedRepetition = useSpacedRepetition()
    const newData = spacedRepetition.calculateNext(
      knowledge.reviewData,
      rating,
      isCorrect
    )
    
    await knowledgeService.updateReviewData(knowledgeId, newData)
  }
  
  // é”™é¢˜ç®¡ç†
  const addMistakeRecord = async (question: ReviewQuestion, userAnswer: string) => {
    const mistake: MistakeRecord = {
      id: generateMistakeId(),
      knowledgeId: question.knowledgeId,
      sessionId: currentSession.value!.id,
      addedDate: new Date().toISOString(),
      reason: `ç”¨æˆ·ç­”æ¡ˆ: ${userAnswer}`,
      userAnswer,
      questionType: question.type,
      isResolved: false,
      retryCount: 0,
      knowledgeBaseId: '', // ä»çŸ¥è¯†ç‚¹è·å–
      areaId: '',
      category: '',
      tags: question.tags
    }
    
    mistakeRecords.value.push(mistake)
    await reviewService.saveMistakeRecord(mistake)
  }
  
  const resolveMistake = async (mistakeId: string) => {
    const mistake = mistakeRecords.value.find(m => m.id === mistakeId)
    if (!mistake) return
    
    mistake.isResolved = true
    mistake.resolvedDate = new Date().toISOString()
    
    await reviewService.updateMistakeRecord(mistake)
  }
  
  const deleteMistake = async (mistakeId: string) => {
    mistakeRecords.value = mistakeRecords.value.filter(m => m.id !== mistakeId)
    await reviewService.deleteMistakeRecord(mistakeId)
  }
  
  // ç»Ÿè®¡åˆ†æ
  const getReviewStatistics = async (): Promise<ReviewStatistics> => {
    return await reviewService.getStatistics()
  }
  
  const generateReviewPlan = async (days: number = 7): Promise<ReviewPlan[]> => {
    return await reviewService.generatePlan(days)
  }
  
  return {
    // çŠ¶æ€
    currentSession: readonly(currentSession),
    activeConfig: readonly(activeConfig),
    reviewHistory: readonly(reviewHistory),
    mistakeRecords: readonly(mistakeRecords),
    isReviewing: readonly(isReviewing),
    showAnswer: readonly(showAnswer),
    loading: readonly(loading),
    
    // è®¡ç®—å±æ€§
    currentQuestion,
    sessionProgress,
    sessionStats,
    mistakeStatistics,
    
    // æ“ä½œ
    startReviewSession,
    submitAnswer,
    nextQuestion,
    previousQuestion,
    completeSession,
    pauseSession,
    resumeSession,
    addMistakeRecord,
    resolveMistake,
    deleteMistake,
    getReviewStatistics,
    generateReviewPlan
  }
})
```

#### 3.3.4 Composablesè§„æ ¼

```typescript
// composables/useSpacedRepetition.ts
export const useSpacedRepetition = () => {
  /**
   * æ”¹è¿›çš„SM-2ç®—æ³•å®ç°
   * åŸºäºåŸå§‹SM-2ç®—æ³•ï¼Œä½†é’ˆå¯¹ä¸‰æ¡£è¯„åˆ†ç³»ç»Ÿè¿›è¡Œäº†ä¼˜åŒ–
   */
  const calculateNext = (
    currentData: SpacedRepetitionData,
    rating: ReviewRating,
    isCorrect: boolean
  ): SpacedRepetitionData => {
    const { easeFactor, interval, repetitions } = currentData
    
    let newEaseFactor = easeFactor
    let newInterval = interval
    let newRepetitions = repetitions
    
    switch (rating) {
      case 1: // é”™è¯¯
        // å¤§å¹…é™ä½ç†Ÿæ‚‰å› å­ï¼Œé‡ç½®é—´éš”
        newEaseFactor = Math.max(1.3, easeFactor - 0.3)
        newInterval = 1
        newRepetitions = 0
        break
        
      case 2: // æ¨¡ç³Š
        // è½»å¾®é™ä½ç†Ÿæ‚‰å› å­ï¼Œç¼©çŸ­é—´éš”
        newEaseFactor = Math.max(1.3, easeFactor - 0.1)
        newInterval = Math.max(1, Math.round(interval * 0.6))
        break
        
      case 3: // æ­£ç¡®
        // æé«˜ç†Ÿæ‚‰å› å­ï¼Œå»¶é•¿é—´éš”
        newEaseFactor = Math.min(3.0, easeFactor + 0.15)
        
        if (newRepetitions === 0) {
          newInterval = 1
        } else if (newRepetitions === 1) {
          newInterval = 3
        } else {
          newInterval = Math.round(interval * newEaseFactor)
        }
        newRepetitions += 1
        break
    }
    
    // è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
    const nextReviewDate = new Date()
    if (rating === 1) {
      // é”™è¯¯ç­”æ¡ˆï¼š6å°æ—¶åå¤ä¹ 
      nextReviewDate.setHours(nextReviewDate.getHours() + 6)
    } else {
      // å…¶ä»–æƒ…å†µï¼šæŒ‰é—´éš”å¤©æ•°è®¡ç®—
      nextReviewDate.setDate(nextReviewDate.getDate() + newInterval)
    }
    
    return {
      ...currentData,
      easeFactor: newEaseFactor,
      interval: newInterval,
      repetitions: newRepetitions,
      nextReviewDate: nextReviewDate.toISOString(),
      lastReviewDate: new Date().toISOString(),
      totalReviews: currentData.totalReviews + 1,
      correctCount: currentData.correctCount + (isCorrect ? 1 : 0),
      masteryLevel: calculateMasteryLevel(currentData.totalReviews + 1, currentData.correctCount + (isCorrect ? 1 : 0))
    }
  }
  
  const calculateMasteryLevel = (totalReviews: number, correctCount: number): number => {
    if (totalReviews === 0) return 0
    const accuracy = correctCount / totalReviews
    
    // è€ƒè™‘å¤ä¹ æ¬¡æ•°å’Œå‡†ç¡®ç‡çš„ç»¼åˆè¯„åˆ†
    if (totalReviews >= 5 && accuracy >= 0.9) return 1.0
    if (totalReviews >= 3 && accuracy >= 0.8) return 0.8
    if (totalReviews >= 2 && accuracy >= 0.7) return 0.6
    if (accuracy >= 0.5) return 0.4
    return 0.2
  }
  
  const getDueReviews = (knowledgeList: KnowledgePoint[]): KnowledgePoint[] => {
    const now = new Date()
    return knowledgeList.filter(knowledge => {
      const nextReview = new Date(knowledge.reviewData.nextReviewDate)
      return nextReview <= now
    })
  }
  
  const getOptimalReviewCount = (totalKnowledge: number): number => {
    // åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ï¼Œå»ºè®®æ¯æ—¥å¤ä¹ é‡
    return Math.min(50, Math.max(10, Math.round(totalKnowledge * 0.1)))
  }
  
  return {
    calculateNext,
    calculateMasteryLevel,
    getDueReviews,
    getOptimalReviewCount
  }
}

// composables/useKeyboardShortcuts.ts
export const useKeyboardShortcuts = (reviewStore: any) => {
  const shortcuts = ref<Map<string, () => void>>(new Map())
  
  const registerShortcut = (key: string, handler: () => void) => {
    shortcuts.value.set(key, handler)
  }
  
  const unregisterShortcut = (key: string) => {
    shortcuts.value.delete(key)
  }
  
  const handleKeyPress = (event: KeyboardEvent) => {
    const { key, ctrlKey, altKey, shiftKey } = event
    
    // æ„å»ºå¿«æ·é”®å­—ç¬¦ä¸²
    let shortcutKey = ''
    if (ctrlKey) shortcutKey += 'Ctrl+'
    if (altKey) shortcutKey += 'Alt+'
    if (shiftKey) shortcutKey += 'Shift+'
    shortcutKey += key
    
    const handler = shortcuts.value.get(shortcutKey)
    if (handler) {
      event.preventDefault()
      handler()
    }
  }
  
  const initReviewShortcuts = () => {
    // åŸºç¡€å¯¼èˆª
    registerShortcut('ArrowLeft', () => reviewStore.previousQuestion())
    registerShortcut('ArrowRight', () => reviewStore.nextQuestion())
    
    // ç­”æ¡ˆæ§åˆ¶
    registerShortcut('Ctrl+Enter', () => reviewStore.toggleAnswer())
    registerShortcut(' ', () => reviewStore.toggleAnswer()) // ç©ºæ ¼é”®
    
    // è¯„åˆ†å¿«æ·é”®
    registerShortcut('1', () => reviewStore.submitRating(1))
    registerShortcut('2', () => reviewStore.submitRating(2))
    registerShortcut('3', () => reviewStore.submitRating(3))
    
    // é€‰æ‹©é¢˜é€‰é¡¹ï¼ˆA-Zï¼‰
    for (let i = 0; i < 26; i++) {
      const letter = String.fromCharCode(65 + i) // A-Z
      registerShortcut(letter, () => reviewStore.selectOption(letter))
    }
    
    // ä¼šè¯æ§åˆ¶
    registerShortcut('Escape', () => reviewStore.pauseSession())
    registerShortcut('Ctrl+r', () => reviewStore.refreshSession())
  }
  
  onMounted(() => {
    document.addEventListener('keydown', handleKeyPress)
    initReviewShortcuts()
  })
  
  onUnmounted(() => {
    document.removeEventListener('keydown', handleKeyPress)
    shortcuts.value.clear()
  })
  
  return {
    registerShortcut,
    unregisterShortcut,
    initReviewShortcuts
  }
}
```

#### 3.3.5 APIæ¥å£è§„æ ¼

```typescript
// services/api/review.ts
export interface ReviewAPI {
  // å¤ä¹ ä¼šè¯æ¥å£
  createSession(config: ReviewConfig): Promise<ReviewSession>
  getSession(sessionId: string): Promise<ReviewSession>
  updateSession(sessionId: string, updates: Partial<ReviewSession>): Promise<ReviewSession>
  deleteSession(sessionId: string): Promise<void>
  getUserSessions(userId: string, limit?: number): Promise<ReviewSession[]>
  
  // é¢˜ç›®ç”Ÿæˆæ¥å£
  generateQuestions(config: ReviewConfig): Promise<ReviewQuestion[]>
  getRecommendedQuestions(userId: string, count: number): Promise<ReviewQuestion[]>
  
  // å¤ä¹ è®°å½•æ¥å£
  saveReviewRecord(record: ReviewRecord): Promise<ReviewRecord>
  getReviewHistory(userId: string, filters?: ReviewHistoryFilter): Promise<ReviewRecord[]>
  getReviewAnalytics(userId: string, timeRange: TimeRange): Promise<ReviewAnalytics>
  
  // é”™é¢˜ç®¡ç†æ¥å£
  saveMistakeRecord(mistake: MistakeRecord): Promise<MistakeRecord>
  updateMistakeRecord(mistakeId: string, updates: Partial<MistakeRecord>): Promise<MistakeRecord>
  deleteMistakeRecord(mistakeId: string): Promise<void>
  getMistakesByUser(userId: string): Promise<MistakeRecord[]>
  getMistakesByArea(areaId: string): Promise<MistakeRecord[]>
  
  // ç»Ÿè®¡åˆ†ææ¥å£
  getReviewStatistics(userId: string): Promise<ReviewStatistics>
  getLearningCurve(userId: string, knowledgeId?: string): Promise<LearningCurveData>
  getWeaknessAnalysis(userId: string): Promise<WeaknessReport>
  generateReviewPlan(userId: string, days: number): Promise<ReviewPlan[]>
  
  // é—´éš”é‡å¤æ¥å£
  updateSpacedRepetitionData(knowledgeId: string, data: SpacedRepetitionData): Promise<void>
  getNextReviewDate(knowledgeId: string): Promise<string>
  getDueReviews(userId: string): Promise<KnowledgePoint[]>
}

// REST API ç«¯ç‚¹è®¾è®¡
const REVIEW_API_ENDPOINTS = {
  // å¤ä¹ ä¼šè¯
  SESSIONS: '/api/review/sessions',
  SESSION: '/api/review/sessions/:sessionId',
  USER_SESSIONS: '/api/review/users/:userId/sessions',
  
  // é¢˜ç›®ç”Ÿæˆ
  GENERATE_QUESTIONS: '/api/review/questions/generate',
  RECOMMENDED_QUESTIONS: '/api/review/questions/recommended/:userId',
  
  // å¤ä¹ è®°å½•
  REVIEW_RECORDS: '/api/review/records',
  REVIEW_HISTORY: '/api/review/users/:userId/history',
  REVIEW_ANALYTICS: '/api/review/users/:userId/analytics',
  
  // é”™é¢˜ç®¡ç†
  MISTAKES: '/api/review/mistakes',
  MISTAKE: '/api/review/mistakes/:mistakeId',
  USER_MISTAKES: '/api/review/users/:userId/mistakes',
  AREA_MISTAKES: '/api/review/areas/:areaId/mistakes',
  
  // ç»Ÿè®¡åˆ†æ
  STATISTICS: '/api/review/users/:userId/statistics',
  LEARNING_CURVE: '/api/review/users/:userId/learning-curve',
  WEAKNESS_ANALYSIS: '/api/review/users/:userId/weakness',
  REVIEW_PLAN: '/api/review/users/:userId/plan',
  
  // é—´éš”é‡å¤
  SPACED_REPETITION: '/api/review/spaced-repetition/:knowledgeId',
  DUE_REVIEWS: '/api/review/users/:userId/due-reviews'
}
```

#### 3.3.6 ç»„ä»¶å®ç°è§„æ ¼

```vue
<!-- views/Review/Review.vue -->
<template>
  <div class="review">
    <!-- å¤ä¹ æ¨¡å¼é€‰æ‹© -->
    <ReviewModeSelector
      v-if="!isReviewing"
      @start-review="handleStartReview"
    />
    
    <!-- å¤ä¹ å¡ç‰‡ -->
    <ReviewCard
      v-else-if="currentQuestion"
      :question="currentQuestion"
      :session="currentSession"
      :show-answer="showAnswer"
      @submit-answer="handleSubmitAnswer"
      @toggle-answer="handleToggleAnswer"
      @next-question="handleNextQuestion"
      @previous-question="handlePreviousQuestion"
    />
    
    <!-- å¤ä¹ å®Œæˆ -->
    <ReviewComplete
      v-else-if="currentSession?.status === 'completed'"
      :session="currentSession"
      @start-new-review="handleStartNewReview"
      @view-mistakes="handleViewMistakes"
    />
    
    <!-- å¤ä¹ è¿›åº¦ -->
    <ReviewProgress
      v-if="isReviewing"
      :progress="sessionProgress"
      :stats="sessionStats"
    />
    
    <!-- å¿«æ·é”®æç¤º -->
    <KeyboardShortcuts v-if="isReviewing" />
  </div>
</template>

<script setup lang="ts">
import { computed, onMounted } from 'vue'
import { useReviewStore } from '@/stores/review'
import { useKeyboardShortcuts } from '@/composables/useKeyboardShortcuts'

const reviewStore = useReviewStore()
const keyboardShortcuts = useKeyboardShortcuts(reviewStore)

// è®¡ç®—å±æ€§
const isReviewing = computed(() => reviewStore.isReviewing)
const currentSession = computed(() => reviewStore.currentSession)
const currentQuestion = computed(() => reviewStore.currentQuestion)
const showAnswer = computed(() => reviewStore.showAnswer)
const sessionProgress = computed(() => reviewStore.sessionProgress)
const sessionStats = computed(() => reviewStore.sessionStats)

// äº‹ä»¶å¤„ç†
const handleStartReview = async (config: ReviewConfig) => {
  try {
    await reviewStore.startReviewSession(config)
  } catch (error) {
    console.error('Failed to start review:', error)
  }
}

const handleSubmitAnswer = async (answer: string, rating: ReviewRating) => {
  await reviewStore.submitAnswer(answer, rating)
}

const handleToggleAnswer = () => {
  reviewStore.showAnswer = !reviewStore.showAnswer
}

const handleNextQuestion = () => {
  reviewStore.nextQuestion()
}

const handlePreviousQuestion = () => {
  reviewStore.previousQuestion()
}

const handleStartNewReview = () => {
  reviewStore.resetSession()
}

const handleViewMistakes = () => {
  // è·³è½¬åˆ°é”™é¢˜æœ¬é¡µé¢
  router.push('/mistakes')
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  // æ£€æŸ¥æ˜¯å¦æœ‰æœªå®Œæˆçš„ä¼šè¯
  if (currentSession.value?.status === 'paused') {
    reviewStore.resumeSession()
  }
})
</script>

<style scoped>
.review {
  display: flex;
  flex-direction: column;
  height: 100vh;
  padding: 20px;
  background: var(--gradient-bg);
}

.review-card {
  flex: 1;
  display: flex;
  flex-direction: column;
  max-width: 800px;
  margin: 0 auto;
}
</style>
```

#### 3.3.7 æ€§èƒ½ä¼˜åŒ–è§„æ ¼

1. **ç®—æ³•ä¼˜åŒ–**:
   - SM-2ç®—æ³•è®¡ç®—ä½¿ç”¨Web Workerï¼Œé¿å…ä¸»çº¿ç¨‹é˜»å¡
   - é¢˜ç›®ç”Ÿæˆé‡‡ç”¨æµå¼å¤„ç†ï¼Œæ”¯æŒå¤§é‡é¢˜ç›®çš„é«˜æ•ˆç”Ÿæˆ
   - å¤ä¹ æ•°æ®æ›´æ–°ä½¿ç”¨æ‰¹é‡æ“ä½œï¼Œå‡å°‘APIè°ƒç”¨æ¬¡æ•°

2. **æ¸²æŸ“ä¼˜åŒ–**:
   - é¢˜ç›®åˆ‡æ¢ä½¿ç”¨TransitionåŠ¨ç”»ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
   - å¤§é‡é€‰é¡¹çš„é€‰æ‹©é¢˜ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
   - å›¾ç‰‡å’Œåª’ä½“å†…å®¹æ”¯æŒæ‡’åŠ è½½

3. **ç¼“å­˜ç­–ç•¥**:
   - å¤ä¹ ä¼šè¯æ•°æ®æœ¬åœ°ç¼“å­˜30åˆ†é’Ÿ
   - é”™é¢˜æ•°æ®ç¼“å­˜15åˆ†é’Ÿ
   - ç»Ÿè®¡æ•°æ®ç¼“å­˜1å°æ—¶ï¼Œæ”¯æŒåå°æ›´æ–°

4. **å†…å­˜ç®¡ç†**:
   - è‡ªåŠ¨æ¸…ç†å·²å®Œæˆçš„å¤ä¹ ä¼šè¯æ•°æ®
   - å¤§å‹é¢˜ç›®åˆ—è¡¨ä½¿ç”¨åˆ†é¡µåŠ è½½
   - åŠæ—¶æ¸…ç†äº‹ä»¶ç›‘å¬å™¨å’Œå®šæ—¶å™¨

#### 3.3.8 ç”¨æˆ·ä½“éªŒè§„æ ¼

1. **å“åº”å¼è®¾è®¡**: æ”¯æŒæ¡Œé¢ç«¯ã€å¹³æ¿å’Œæ‰‹æœºç«¯çš„å¤ä¹ ä½“éªŒ
2. **ç¦»çº¿æ”¯æŒ**: å¤ä¹ ä¼šè¯æ”¯æŒç¦»çº¿æ¨¡å¼ï¼Œç½‘ç»œæ¢å¤åè‡ªåŠ¨åŒæ­¥
3. **è¿›åº¦ä¿å­˜**: è‡ªåŠ¨ä¿å­˜å¤ä¹ è¿›åº¦ï¼Œæ„å¤–å…³é—­åå¯æ¢å¤
4. **æ™ºèƒ½æé†’**: åŸºäºå¤ä¹ è®¡åˆ’çš„æ¨é€é€šçŸ¥
5. **æ— éšœç¢æ”¯æŒ**: å®Œæ•´çš„å±å¹•é˜…è¯»å™¨æ”¯æŒå’Œé”®ç›˜å¯¼èˆª
6. **ä¸»é¢˜é€‚é…**: æ”¯æŒæ·±è‰²æ¨¡å¼å’Œé«˜å¯¹æ¯”åº¦æ¨¡å¼

#### 3.3.9 æµ‹è¯•è§„æ ¼

```typescript
// ç®—æ³•æµ‹è¯•
describe('Spaced Repetition Algorithm', () => {
  it('åº”è¯¥æ­£ç¡®è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´', () => {
    // æµ‹è¯•SM-2ç®—æ³•çš„å„ç§è¯„åˆ†æƒ…å†µ
  })
  
  it('åº”è¯¥æ­£ç¡®æ›´æ–°ç†Ÿæ‚‰å› å­', () => {
    // æµ‹è¯•ç†Ÿæ‚‰å› å­çš„è¾¹ç•Œå€¼å¤„ç†
  })
})

// ç»„ä»¶æµ‹è¯•
describe('ReviewCard Component', () => {
  it('åº”è¯¥æ­£ç¡®æ¸²æŸ“ä¸åŒç±»å‹çš„é¢˜ç›®', () => {
    // æµ‹è¯•é€‰æ‹©é¢˜å’Œå¡«ç©ºé¢˜çš„æ¸²æŸ“
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†ç”¨æˆ·äº¤äº’', () => {
    // æµ‹è¯•ç­”é¢˜ã€è¯„åˆ†ã€å¯¼èˆªç­‰äº¤äº’
  })
})

// é›†æˆæµ‹è¯•
describe('Review Session Flow', () => {
  it('åº”è¯¥å®Œæ•´æ”¯æŒå¤ä¹ ä¼šè¯æµç¨‹', () => {
    // æµ‹è¯•ä»å¼€å§‹åˆ°å®Œæˆçš„å®Œæ•´æµç¨‹
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†é”™é¢˜è®°å½•', () => {
    // æµ‹è¯•é”™é¢˜çš„è‡ªåŠ¨è®°å½•å’Œç®¡ç†
  })
})
```

---

## ğŸ“ 4. é”™é¢˜æœ¬æ¨¡å—åŠŸèƒ½è§„æ ¼

### 4.1 æ¨¡å—æ¦‚è¿°

é”™é¢˜æœ¬æ¨¡å—æ˜¯æ™ºèƒ½å­¦ä¹ ç³»ç»Ÿçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œè´Ÿè´£è‡ªåŠ¨æ”¶é›†å­¦ä¹ è¿‡ç¨‹ä¸­çš„é”™è¯¯ç­”æ¡ˆï¼Œæä¾›åˆ†ç±»ç®¡ç†ã€æ·±åº¦åˆ†æå’Œé’ˆå¯¹æ€§å¤ä¹ åŠŸèƒ½ï¼Œå¸®åŠ©ç”¨æˆ·è¯†åˆ«è–„å¼±ç¯èŠ‚å¹¶åˆ¶å®šä¸ªæ€§åŒ–æ”¹è¿›æ–¹æ¡ˆã€‚

### 4.2 ç°æœ‰å®ç°åˆ†æ

#### 4.2.1 æ ¸å¿ƒæ¶æ„åˆ†æ

**é”™é¢˜æ•°æ®ç»“æ„**:
```javascript
// ç°æœ‰é”™é¢˜è®°å½•æ ¼å¼
{
  id: string,                    // é”™é¢˜å”¯ä¸€æ ‡è¯†
  knowledgeId: string,           // å…³è”çš„çŸ¥è¯†ç‚¹ID
  count: number,                 // é”™è¯¯æ¬¡æ•°
  firstMistakeDate: timestamp,   // é¦–æ¬¡é”™è¯¯æ—¶é—´
  lastMistakeDate: timestamp,    // æœ€è¿‘é”™è¯¯æ—¶é—´
  reasons: string[],             // é”™è¯¯åŸå› åˆ—è¡¨
  isResolved: boolean           // æ˜¯å¦å·²æŒæ¡
}
```

**é”™é¢˜ç®¡ç†åŠŸèƒ½**:
```javascript
// storage.js ä¸­çš„é”™é¢˜æ“ä½œ
getMistakes()                  // è·å–æ‰€æœ‰é”™é¢˜
addMistake(knowledgeId, data)  // æ·»åŠ é”™é¢˜è®°å½•
resolveMistake(knowledgeId)    // æ ‡è®°ä¸ºå·²æŒæ¡
deleteMistake(knowledgeId)     // åˆ é™¤é”™é¢˜

// review.js ä¸­çš„é”™é¢˜ç•Œé¢
loadMistakesOverview()         // é”™é¢˜ç»Ÿè®¡æ¦‚è§ˆ
loadMistakesTabs()             // åˆ†ç±»æ ‡ç­¾
loadAllMistakes()              // æ‰€æœ‰é”™é¢˜è§†å›¾
loadMistakesByArea()           // æŒ‰çŸ¥è¯†åŒºåˆ†ç»„
renderMistakeCard(mistake)     // é”™é¢˜å¡ç‰‡æ¸²æŸ“
```

#### 4.2.2 é”™é¢˜æ”¶é›†æœºåˆ¶

```javascript
// è‡ªåŠ¨é”™é¢˜è®°å½•ï¼ˆåœ¨å¤ä¹ è¯„åˆ†æ—¶è§¦å‘ï¼‰
if (rating === 1) { // è¯„åˆ†ä¸º"é”™è¯¯"æ—¶
  const success = window.storageManager.addMistake(knowledgeId, {
    reason: `ç”¨æˆ·ç­”æ¡ˆ: ${userAnswer}`,
    questionType: questionType
  });
}
```

#### 4.2.3 é”™é¢˜ç•Œé¢ç³»ç»Ÿ

**HTMLç»“æ„**:
```html
<section id="mistakes" class="content-section">
  <!-- é”™é¢˜ç»Ÿè®¡æ¦‚è§ˆ -->
  <div class="mistakes-overview" id="mistakes-overview"></div>
  
  <!-- çŸ¥è¯†åŒºåˆ†ç±»æ ‡ç­¾ -->
  <div class="mistakes-filter">
    <div class="filter-tabs" id="mistakes-filter-tabs"></div>
  </div>
  
  <!-- é”™é¢˜åˆ—è¡¨å®¹å™¨ -->
  <div class="mistakes-container">
    <div class="mistakes-view" id="mistakes-view-all"></div>
    <div class="mistakes-areas" id="mistakes-areas"></div>
  </div>
</section>
```

**é”™é¢˜å¡ç‰‡æ¸²æŸ“**:
```javascript
renderMistakeCard(mistake) {
  return `
    <div class="mistake-card">
      <div class="mistake-card-header">
        <div class="mistake-count">é”™è¯¯ ${mistake.count} æ¬¡</div>
        <div class="mistake-date">æœ€è¿‘é”™è¯¯: ${formatDate(mistake.lastMistakeDate)}</div>
      </div>
      <div class="knowledge-card-title">
        <h4>${question}</h4>
      </div>
      <div class="knowledge-card-actions">
        <button onclick="reviewMistake()">å¤ä¹ </button>
        <button onclick="resolveMistake()">æ ‡è®°å·²æŒæ¡</button>
        <button onclick="deleteMistake()">åˆ é™¤</button>
      </div>
    </div>
  `;
}
```

#### 4.2.4 æ¯›ç»ç’ƒçº¢è‰²ä¸»é¢˜

```css
.mistake-card {
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(20px);
  border: 1px solid rgba(231, 76, 60, 0.1);
  border-left: 4px solid #e74c3c;    // çº¢è‰²å·¦è¾¹æ¡†
  box-shadow: 0 4px 20px rgba(231, 76, 60, 0.08);
}

.mistake-count {
  background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
  color: white;
  border-radius: 20px;
}
```

#### 4.2.5 å­˜åœ¨é—®é¢˜

1. **åŠŸèƒ½å±€é™æ€§**: é”™é¢˜æ•°æ®ç»“æ„ç®€å•ï¼Œç¼ºä¹æ·±åº¦åˆ†æç»´åº¦
2. **åˆ†æä¸è¶³**: ä»…æœ‰åŸºç¡€ç»Ÿè®¡ï¼Œç¼ºä¹é”™è¯¯æ¨¡å¼è¯†åˆ«å’Œå­¦ä¹ å»ºè®®
3. **å¤ä¹ æ•ˆæœ**: æ²¡æœ‰é”™é¢˜å¤ä¹ æ•ˆæœè·Ÿè¸ªå’Œå·©å›ºæœºåˆ¶
4. **è§†è§‰åé¦ˆ**: é”™é¢˜ä¸¥é‡ç¨‹åº¦å’Œæ”¹è¿›è¶‹åŠ¿ç¼ºä¹ç›´è§‚å±•ç¤º
5. **æ™ºèƒ½æ¨è**: ç¼ºä¹åŸºäºé”™é¢˜æ¨¡å¼çš„ä¸ªæ€§åŒ–å­¦ä¹ è·¯å¾„æ¨è

### 4.3 åŠŸèƒ½è§„æ ¼å®šä¹‰

#### 4.3.1 Vueç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// é”™é¢˜æœ¬æ¨¡å—ç»„ä»¶æ ‘ç»“æ„
src/views/Mistakes/
â”œâ”€â”€ Mistakes.vue                         // ä¸»å®¹å™¨ç»„ä»¶
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Overview/
â”‚   â”‚   â”œâ”€â”€ MistakesOverview.vue         // é”™é¢˜ç»Ÿè®¡æ¦‚è§ˆ
â”‚   â”‚   â”œâ”€â”€ MistakesStats.vue            // è¯¦ç»†ç»Ÿè®¡å›¾è¡¨
â”‚   â”‚   â”œâ”€â”€ WeaknessAnalysis.vue         // è–„å¼±ç‚¹åˆ†æ
â”‚   â”‚   â””â”€â”€ ImprovementTrend.vue         // æ”¹è¿›è¶‹åŠ¿å›¾
â”‚   â”œâ”€â”€ Filter/
â”‚   â”‚   â”œâ”€â”€ MistakesFilter.vue           // é”™é¢˜ç­›é€‰å™¨
â”‚   â”‚   â”œâ”€â”€ CategoryTabs.vue             // åˆ†ç±»æ ‡ç­¾
â”‚   â”‚   â”œâ”€â”€ DifficultyFilter.vue         // éš¾åº¦ç­›é€‰
â”‚   â”‚   â”œâ”€â”€ TimeRangeFilter.vue          // æ—¶é—´èŒƒå›´ç­›é€‰
â”‚   â”‚   â””â”€â”€ TypeFilter.vue               // é¢˜å‹ç­›é€‰
â”‚   â”œâ”€â”€ List/
â”‚   â”‚   â”œâ”€â”€ MistakesList.vue             // é”™é¢˜åˆ—è¡¨å®¹å™¨
â”‚   â”‚   â”œâ”€â”€ MistakeCard.vue              // é”™é¢˜å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ MistakeDetail.vue            // é”™é¢˜è¯¦æƒ…å¼¹çª—
â”‚   â”‚   â”œâ”€â”€ BatchActions.vue             // æ‰¹é‡æ“ä½œå·¥å…·
â”‚   â”‚   â””â”€â”€ EmptyState.vue               // ç©ºçŠ¶æ€å±•ç¤º
â”‚   â”œâ”€â”€ Analysis/
â”‚   â”‚   â”œâ”€â”€ ErrorPatternChart.vue        // é”™è¯¯æ¨¡å¼å›¾è¡¨
â”‚   â”‚   â”œâ”€â”€ WeaknessHeatmap.vue          // è–„å¼±ç‚¹çƒ­åŠ›å›¾
â”‚   â”‚   â”œâ”€â”€ LearningCurve.vue            // å­¦ä¹ æ›²çº¿
â”‚   â”‚   â””â”€â”€ RecommendationPanel.vue      // å­¦ä¹ å»ºè®®é¢æ¿
â”‚   â””â”€â”€ Actions/
â”‚       â”œâ”€â”€ ReviewActions.vue            // å¤ä¹ æ“ä½œç»„
â”‚       â”œâ”€â”€ BatchReview.vue              // æ‰¹é‡å¤ä¹ 
â”‚       â”œâ”€â”€ ExportMistakes.vue           // é”™é¢˜å¯¼å‡º
â”‚       â””â”€â”€ ClearResolved.vue            // æ¸…ç†å·²æŒæ¡
â””â”€â”€ composables/
    â”œâ”€â”€ useMistakesData.ts               // é”™é¢˜æ•°æ®ç®¡ç†
    â”œâ”€â”€ useMistakesFilter.ts             // ç­›é€‰é€»è¾‘
    â”œâ”€â”€ useMistakesAnalysis.ts           // é”™è¯¯åˆ†æé€»è¾‘
    â”œâ”€â”€ useMistakesReview.ts             // é”™é¢˜å¤ä¹ é€»è¾‘
    â”œâ”€â”€ useWeaknessDetection.ts          // è–„å¼±ç‚¹æ£€æµ‹
    â””â”€â”€ useLearningRecommendation.ts     // å­¦ä¹ å»ºè®®ç”Ÿæˆ
```

#### 4.3.2 æ•°æ®æ¨¡å‹è§„æ ¼

```typescript
// types/mistakes.ts
export interface MistakeRecord {
  id: string
  knowledgeId: string
  sessionId: string
  
  // åŸºç¡€ä¿¡æ¯
  question: string
  correctAnswer: string
  userAnswer: string
  explanation: string
  
  // é”™è¯¯åˆ†ç±»
  errorType: ErrorType
  errorPattern: ErrorPattern
  difficultyLevel: number
  questionType: QuestionType
  
  // æ—¶é—´ä¿¡æ¯
  firstMistakeDate: string
  lastMistakeDate: string
  occurrenceCount: number
  
  // çŸ¥è¯†åˆ†ç±»
  knowledgeBaseId: string
  knowledgeAreaId: string
  knowledgeAreaName: string
  category: string
  tags: string[]
  
  // é”™è¯¯åˆ†æ
  errorReasons: ErrorReason[]
  confidenceLevel: number
  responseTime: number
  
  // çŠ¶æ€ç®¡ç†
  status: MistakeStatus
  isResolved: boolean
  resolvedDate?: string
  retryCount: number
  lastRetryDate?: string
  masteryLevel: number
  
  // å¤ä¹ è®°å½•
  reviewHistory: MistakeReviewRecord[]
  nextReviewDate: string
  reviewPriority: number
  
  // å…³è”æ•°æ®
  relatedMistakes: string[]
  similarMistakes: string[]
  prerequisiteKnowledge: string[]
}

export type ErrorType = 
  | 'conceptual'      // æ¦‚å¿µç†è§£é”™è¯¯
  | 'procedural'      // æ“ä½œæµç¨‹é”™è¯¯
  | 'careless'        // ç²—å¿ƒå¤§æ„é”™è¯¯
  | 'knowledge-gap'   // çŸ¥è¯†ç¼ºå¤±é”™è¯¯
  | 'misunderstanding' // è¯¯è§£é”™è¯¯
  | 'memory-lapse'    // è®°å¿†é—å¿˜é”™è¯¯

export type ErrorPattern = 
  | 'consistent'      // æŒç»­æ€§é”™è¯¯
  | 'occasional'      // å¶å‘æ€§é”™è¯¯
  | 'regressive'      // é€€åŒ–æ€§é”™è¯¯
  | 'improving'       // æ”¹å–„ä¸­é”™è¯¯

export type MistakeStatus = 
  | 'active'          // æ´»è·ƒé”™é¢˜
  | 'reviewing'       // å¤ä¹ ä¸­
  | 'consolidating'   // å·©å›ºä¸­
  | 'resolved'        // å·²è§£å†³
  | 'archived'        // å·²å½’æ¡£

export interface ErrorReason {
  id: string
  type: ErrorType
  description: string
  severity: number
  frequency: number
  detectedAt: string
  confidence: number
}

export interface MistakeReviewRecord {
  id: string
  reviewDate: string
  reviewType: 'manual' | 'scheduled' | 'intensive'
  isCorrect: boolean
  responseTime: number
  confidenceRating: number
  notes: string
  improvements: string[]
}

export interface MistakesStatistics {
  // åŸºç¡€ç»Ÿè®¡
  totalMistakes: number
  activeMistakes: number
  resolvedMistakes: number
  todayMistakes: number
  weekMistakes: number
  
  // åˆ†ç±»ç»Ÿè®¡
  mistakesByType: Record<ErrorType, number>
  mistakesByPattern: Record<ErrorPattern, number>
  mistakesByDifficulty: Record<number, number>
  mistakesByArea: Record<string, number>
  mistakesByCategory: Record<string, number>
  
  // è¶‹åŠ¿åˆ†æ
  mistakeTrend: TrendData[]
  improvementRate: number
  averageResolutionTime: number
  retrySuccessRate: number
  
  // è–„å¼±ç‚¹åˆ†æ
  weakestAreas: WeaknessItem[]
  commonErrorPatterns: ErrorPatternItem[]
  persistentMistakes: MistakeRecord[]
  
  // å¤ä¹ æ•ˆæœ
  reviewEffectiveness: number
  averageRetryCount: number
  masteryProgression: ProgressionData[]
}

export interface WeaknessItem {
  area: string
  category: string
  mistakeCount: number
  averageDifficulty: number
  improvementPotential: number
  recommendedActions: string[]
  priority: 'high' | 'medium' | 'low'
}

export interface ErrorPatternItem {
  pattern: ErrorPattern
  type: ErrorType
  frequency: number
  affectedAreas: string[]
  description: string
  recommendations: string[]
}

export interface LearningRecommendation {
  id: string
  type: 'study-plan' | 'practice-focus' | 'concept-review' | 'skill-building'
  title: string
  description: string
  priority: number
  estimatedTime: number
  difficulty: number
  
  // ç›®æ ‡çŸ¥è¯†ç‚¹
  targetKnowledgeIds: string[]
  targetAreas: string[]
  
  // æ¨èåŸå› 
  reasons: string[]
  expectedOutcomes: string[]
  
  // æ‰§è¡Œè®¡åˆ’
  steps: RecommendationStep[]
  schedule: RecommendationSchedule
  
  // è¯„ä¼°æŒ‡æ ‡
  successCriteria: string[]
  progressMetrics: string[]
}

export interface RecommendationStep {
  id: string
  title: string
  description: string
  type: 'study' | 'practice' | 'review' | 'test'
  estimatedTime: number
  resources: string[]
  prerequisites: string[]
}

export interface MistakesFilter {
  // æ—¶é—´ç­›é€‰
  timeRange: TimeRange
  startDate?: string
  endDate?: string
  
  // åˆ†ç±»ç­›é€‰
  areas: string[]
  categories: string[]
  tags: string[]
  
  // çŠ¶æ€ç­›é€‰
  statuses: MistakeStatus[]
  errorTypes: ErrorType[]
  errorPatterns: ErrorPattern[]
  
  // éš¾åº¦ç­›é€‰
  difficultyRange: [number, number]
  
  // å¤ä¹ ç­›é€‰
  retryCountRange: [number, number]
  masteryLevelRange: [number, number]
  
  // æ’åºé€‰é¡¹
  sortBy: 'date' | 'frequency' | 'difficulty' | 'priority' | 'mastery'
  sortOrder: 'asc' | 'desc'
  
  // æœç´¢
  searchQuery: string
}
```

#### 4.3.3 çŠ¶æ€ç®¡ç†è§„æ ¼

```typescript
// stores/mistakes.ts
export const useMistakesStore = defineStore('mistakes', () => {
  // æ ¸å¿ƒçŠ¶æ€
  const mistakeRecords = ref<MistakeRecord[]>([])
  const mistakesStatistics = ref<MistakesStatistics | null>(null)
  const learningRecommendations = ref<LearningRecommendation[]>([])
  
  // ç­›é€‰çŠ¶æ€
  const activeFilter = ref<MistakesFilter>({
    timeRange: 'all',
    areas: [],
    categories: [],
    tags: [],
    statuses: ['active'],
    errorTypes: [],
    errorPatterns: [],
    difficultyRange: [1, 5],
    retryCountRange: [0, 10],
    masteryLevelRange: [0, 1],
    sortBy: 'date',
    sortOrder: 'desc',
    searchQuery: ''
  })
  
  // UIçŠ¶æ€
  const selectedMistakes = ref<Set<string>>(new Set())
  const viewMode = ref<'list' | 'grid' | 'analysis'>('list')
  const showResolved = ref(false)
  
  // åŠ è½½çŠ¶æ€
  const loading = ref({
    mistakes: false,
    statistics: false,
    analysis: false,
    recommendations: false
  })
  
  // è®¡ç®—å±æ€§
  const filteredMistakes = computed(() => {
    let filtered = mistakeRecords.value
    
    // çŠ¶æ€è¿‡æ»¤
    if (!showResolved.value) {
      filtered = filtered.filter(m => !m.isResolved)
    }
    
    // çŸ¥è¯†åŒºè¿‡æ»¤
    if (activeFilter.value.areas.length > 0) {
      filtered = filtered.filter(m => 
        activeFilter.value.areas.includes(m.knowledgeAreaName)
      )
    }
    
    // åˆ†ç±»è¿‡æ»¤
    if (activeFilter.value.categories.length > 0) {
      filtered = filtered.filter(m => 
        activeFilter.value.categories.includes(m.category)
      )
    }
    
    // é”™è¯¯ç±»å‹è¿‡æ»¤
    if (activeFilter.value.errorTypes.length > 0) {
      filtered = filtered.filter(m => 
        activeFilter.value.errorTypes.includes(m.errorType)
      )
    }
    
    // éš¾åº¦èŒƒå›´è¿‡æ»¤
    const [minDifficulty, maxDifficulty] = activeFilter.value.difficultyRange
    filtered = filtered.filter(m => 
      m.difficultyLevel >= minDifficulty && m.difficultyLevel <= maxDifficulty
    )
    
    // æœç´¢è¿‡æ»¤
    if (activeFilter.value.searchQuery) {
      const query = activeFilter.value.searchQuery.toLowerCase()
      filtered = filtered.filter(m => 
        m.question.toLowerCase().includes(query) ||
        m.category.toLowerCase().includes(query) ||
        m.tags.some(tag => tag.toLowerCase().includes(query))
      )
    }
    
    // æ’åº
    return sortMistakes(filtered, activeFilter.value.sortBy, activeFilter.value.sortOrder)
  })
  
  const mistakesByArea = computed(() => {
    return filteredMistakes.value.reduce((acc, mistake) => {
      const area = mistake.knowledgeAreaName
      if (!acc[area]) acc[area] = []
      acc[area].push(mistake)
      return acc
    }, {} as Record<string, MistakeRecord[]>)
  })
  
  const mistakesByType = computed(() => {
    return filteredMistakes.value.reduce((acc, mistake) => {
      if (!acc[mistake.errorType]) acc[mistake.errorType] = 0
      acc[mistake.errorType]++
      return acc
    }, {} as Record<ErrorType, number>)
  })
  
  const weakestAreas = computed(() => {
    if (!mistakesStatistics.value) return []
    return mistakesStatistics.value.weakestAreas
      .filter(area => area.priority === 'high')
      .slice(0, 5)
  })
  
  const priorityMistakes = computed(() => {
    return filteredMistakes.value
      .filter(m => m.reviewPriority >= 7)
      .sort((a, b) => b.reviewPriority - a.reviewPriority)
      .slice(0, 10)
  })
  
  // æ•°æ®æ“ä½œ
  const loadMistakes = async (forceRefresh = false) => {
    if (loading.value.mistakes) return
    
    loading.value.mistakes = true
    try {
      const mistakes = await mistakesService.getUserMistakes(forceRefresh)
      mistakeRecords.value = mistakes
    } finally {
      loading.value.mistakes = false
    }
  }
  
  const addMistake = async (mistakeData: Omit<MistakeRecord, 'id'>) => {
    const newMistake = await mistakesService.addMistake(mistakeData)
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçŸ¥è¯†ç‚¹çš„é”™é¢˜
    const existingIndex = mistakeRecords.value.findIndex(
      m => m.knowledgeId === newMistake.knowledgeId
    )
    
    if (existingIndex >= 0) {
      // æ›´æ–°ç°æœ‰é”™é¢˜è®°å½•
      const existing = mistakeRecords.value[existingIndex]
      existing.occurrenceCount++
      existing.lastMistakeDate = newMistake.lastMistakeDate
      existing.errorReasons.push(...newMistake.errorReasons)
    } else {
      // æ·»åŠ æ–°é”™é¢˜è®°å½•
      mistakeRecords.value.push(newMistake)
    }
    
    // é‡æ–°åŠ è½½ç»Ÿè®¡æ•°æ®
    await loadStatistics(true)
    
    return newMistake
  }
  
  const resolveMistake = async (mistakeId: string) => {
    const mistake = mistakeRecords.value.find(m => m.id === mistakeId)
    if (!mistake) return
    
    mistake.isResolved = true
    mistake.status = 'resolved'
    mistake.resolvedDate = new Date().toISOString()
    
    await mistakesService.updateMistake(mistakeId, {
      isResolved: true,
      status: 'resolved',
      resolvedDate: mistake.resolvedDate
    })
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    await loadStatistics(true)
  }
  
  const deleteMistake = async (mistakeId: string) => {
    mistakeRecords.value = mistakeRecords.value.filter(m => m.id !== mistakeId)
    await mistakesService.deleteMistake(mistakeId)
    await loadStatistics(true)
  }
  
  const batchResolveMistakes = async (mistakeIds: string[]) => {
    const updates = mistakeIds.map(id => ({
      id,
      updates: {
        isResolved: true,
        status: 'resolved' as MistakeStatus,
        resolvedDate: new Date().toISOString()
      }
    }))
    
    await mistakesService.batchUpdateMistakes(updates)
    
    // æ›´æ–°æœ¬åœ°çŠ¶æ€
    mistakeIds.forEach(id => {
      const mistake = mistakeRecords.value.find(m => m.id === id)
      if (mistake) {
        mistake.isResolved = true
        mistake.status = 'resolved'
        mistake.resolvedDate = new Date().toISOString()
      }
    })
    
    selectedMistakes.value.clear()
    await loadStatistics(true)
  }
  
  const startMistakeReview = async (mistakeIds: string[], reviewType: 'intensive' | 'normal' = 'normal') => {
    const reviewConfig: ReviewConfig = {
      mode: 'mistakes',
      source: {
        type: 'mistakes',
        params: { mistakeIds }
      },
      sorter: {
        type: reviewType === 'intensive' ? 'by-priority' : 'random'
      },
      options: {
        showAnswer: false,
        autoRate: false,
        enableHints: true,
        shuffleOptions: reviewType === 'normal'
      }
    }
    
    // å¯åŠ¨å¤ä¹ ä¼šè¯
    const reviewStore = useReviewStore()
    await reviewStore.startReviewSession(reviewConfig)
  }
  
  // ç»Ÿè®¡åˆ†æ
  const loadStatistics = async (forceRefresh = false) => {
    if (loading.value.statistics) return
    
    loading.value.statistics = true
    try {
      const stats = await mistakesService.getStatistics(forceRefresh)
      mistakesStatistics.value = stats
    } finally {
      loading.value.statistics = false
    }
  }
  
  const generateRecommendations = async () => {
    if (loading.value.recommendations) return
    
    loading.value.recommendations = true
    try {
      const recommendations = await mistakesService.generateLearningRecommendations()
      learningRecommendations.value = recommendations
    } finally {
      loading.value.recommendations = false
    }
  }
  
  // ç­›é€‰æ“ä½œ
  const updateFilter = (filterUpdates: Partial<MistakesFilter>) => {
    activeFilter.value = { ...activeFilter.value, ...filterUpdates }
  }
  
  const resetFilter = () => {
    activeFilter.value = {
      timeRange: 'all',
      areas: [],
      categories: [],
      tags: [],
      statuses: ['active'],
      errorTypes: [],
      errorPatterns: [],
      difficultyRange: [1, 5],
      retryCountRange: [0, 10],
      masteryLevelRange: [0, 1],
      sortBy: 'date',
      sortOrder: 'desc',
      searchQuery: ''
    }
  }
  
  // æ‰¹é‡æ“ä½œ
  const selectMistake = (mistakeId: string) => {
    selectedMistakes.value.add(mistakeId)
  }
  
  const deselectMistake = (mistakeId: string) => {
    selectedMistakes.value.delete(mistakeId)
  }
  
  const selectAllMistakes = () => {
    filteredMistakes.value.forEach(m => selectedMistakes.value.add(m.id))
  }
  
  const clearSelection = () => {
    selectedMistakes.value.clear()
  }
  
  // è¾…åŠ©å‡½æ•°
  const sortMistakes = (mistakes: MistakeRecord[], sortBy: string, order: 'asc' | 'desc') => {
    return mistakes.sort((a, b) => {
      let comparison = 0
      
      switch (sortBy) {
        case 'date':
          comparison = new Date(a.lastMistakeDate).getTime() - new Date(b.lastMistakeDate).getTime()
          break
        case 'frequency':
          comparison = a.occurrenceCount - b.occurrenceCount
          break
        case 'difficulty':
          comparison = a.difficultyLevel - b.difficultyLevel
          break
        case 'priority':
          comparison = a.reviewPriority - b.reviewPriority
          break
        case 'mastery':
          comparison = a.masteryLevel - b.masteryLevel
          break
        default:
          comparison = 0
      }
      
      return order === 'desc' ? -comparison : comparison
    })
  }
  
  return {
    // çŠ¶æ€
    mistakeRecords: readonly(mistakeRecords),
    mistakesStatistics: readonly(mistakesStatistics),
    learningRecommendations: readonly(learningRecommendations),
    activeFilter: readonly(activeFilter),
    selectedMistakes: readonly(selectedMistakes),
    viewMode: readonly(viewMode),
    showResolved: readonly(showResolved),
    loading: readonly(loading),
    
    // è®¡ç®—å±æ€§
    filteredMistakes,
    mistakesByArea,
    mistakesByType,
    weakestAreas,
    priorityMistakes,
    
    // æ“ä½œ
    loadMistakes,
    addMistake,
    resolveMistake,
    deleteMistake,
    batchResolveMistakes,
    startMistakeReview,
    loadStatistics,
    generateRecommendations,
    updateFilter,
    resetFilter,
    selectMistake,
    deselectMistake,
    selectAllMistakes,
    clearSelection
  }
})
```

#### 4.3.4 Composablesè§„æ ¼

```typescript
// composables/useMistakesAnalysis.ts
export const useMistakesAnalysis = () => {
  /**
   * é”™è¯¯æ¨¡å¼æ£€æµ‹ç®—æ³•
   * åŸºäºæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œè¯†åˆ«ç”¨æˆ·çš„é”™è¯¯æ¨¡å¼å’Œå­¦ä¹ éšœç¢
   */
  const detectErrorPatterns = (mistakes: MistakeRecord[]): ErrorPatternItem[] => {
    const patterns: ErrorPatternItem[] = []
    
    // åˆ†æé”™è¯¯ç±»å‹é¢‘ç‡
    const typeFrequency = mistakes.reduce((acc, mistake) => {
      acc[mistake.errorType] = (acc[mistake.errorType] || 0) + 1
      return acc
    }, {} as Record<ErrorType, number>)
    
    // æ£€æµ‹æŒç»­æ€§é”™è¯¯æ¨¡å¼
    const persistentErrors = mistakes.filter(m => m.occurrenceCount >= 3)
    if (persistentErrors.length > 0) {
      patterns.push({
        pattern: 'consistent',
        type: 'conceptual',
        frequency: persistentErrors.length,
        affectedAreas: [...new Set(persistentErrors.map(m => m.knowledgeAreaName))],
        description: 'åœ¨æŸäº›æ¦‚å¿µä¸Šå­˜åœ¨æŒç»­æ€§é”™è¯¯',
        recommendations: [
          'éœ€è¦é‡æ–°å­¦ä¹ ç›¸å…³åŸºç¡€æ¦‚å¿µ',
          'å»ºè®®å¯»æ±‚ä¸“é¡¹è¾…å¯¼',
          'å¢åŠ æ¦‚å¿µç†è§£ç±»ç»ƒä¹ '
        ]
      })
    }
    
    // æ£€æµ‹ç²—å¿ƒå¤§æ„æ¨¡å¼
    const carelessErrors = mistakes.filter(m => 
      m.errorType === 'careless' && m.responseTime < 30000
    )
    if (carelessErrors.length > mistakes.length * 0.3) {
      patterns.push({
        pattern: 'occasional',
        type: 'careless',
        frequency: carelessErrors.length,
        affectedAreas: [...new Set(carelessErrors.map(m => m.knowledgeAreaName))],
        description: 'ç­”é¢˜é€Ÿåº¦è¿‡å¿«ï¼Œå®¹æ˜“å‡ºç°ç²—å¿ƒé”™è¯¯',
        recommendations: [
          'æ”¾æ…¢ç­”é¢˜é€Ÿåº¦ï¼Œä»”ç»†å®¡é¢˜',
          'å»ºç«‹æ£€æŸ¥ç­”æ¡ˆçš„ä¹ æƒ¯',
          'ä¸“æ³¨åŠ›è®­ç»ƒç»ƒä¹ '
        ]
      })
    }
    
    return patterns
  }
  
  /**
   * è–„å¼±ç‚¹åˆ†æç®—æ³•
   * åŸºäºé”™è¯¯é¢‘ç‡ã€éš¾åº¦åˆ†å¸ƒå’ŒçŸ¥è¯†å›¾è°±ï¼Œè¯†åˆ«ç”¨æˆ·çš„è–„å¼±çŸ¥è¯†é¢†åŸŸ
   */
  const analyzeWeaknesses = (mistakes: MistakeRecord[]): WeaknessItem[] => {
    const weaknesses: WeaknessItem[] = []
    
    // æŒ‰çŸ¥è¯†åŒºåˆ†ç»„ç»Ÿè®¡
    const areaStats = mistakes.reduce((acc, mistake) => {
      const area = mistake.knowledgeAreaName
      if (!acc[area]) {
        acc[area] = {
          mistakes: [],
          totalErrors: 0,
          avgDifficulty: 0,
          avgRetryCount: 0
        }
      }
      
      acc[area].mistakes.push(mistake)
      acc[area].totalErrors += mistake.occurrenceCount
      acc[area].avgDifficulty += mistake.difficultyLevel
      acc[area].avgRetryCount += mistake.retryCount
      
      return acc
    }, {} as Record<string, any>)
    
    // è®¡ç®—æ¯ä¸ªåŒºåŸŸçš„è–„å¼±åº¦
    Object.entries(areaStats).forEach(([area, stats]) => {
      const mistakeCount = stats.mistakes.length
      const avgDifficulty = stats.avgDifficulty / mistakeCount
      const avgRetryCount = stats.avgRetryCount / mistakeCount
      
      // è–„å¼±åº¦è¯„åˆ†ç®—æ³•
      const weaknessScore = (mistakeCount * 0.4) + (avgDifficulty * 0.3) + (avgRetryCount * 0.3)
      
      if (weaknessScore > 3.0) {
        const priority = weaknessScore > 6.0 ? 'high' : weaknessScore > 4.5 ? 'medium' : 'low'
        
        weaknesses.push({
          area,
          category: stats.mistakes[0].category,
          mistakeCount,
          averageDifficulty: avgDifficulty,
          improvementPotential: Math.min(1.0, weaknessScore / 10),
          recommendedActions: generateRecommendedActions(stats.mistakes),
          priority
        })
      }
    })
    
    return weaknesses.sort((a, b) => b.improvementPotential - a.improvementPotential)
  }
  
  /**
   * å­¦ä¹ å»ºè®®ç”Ÿæˆç®—æ³•
   * åŸºäºé”™è¯¯åˆ†æå’Œå­¦ä¹ ç†è®ºï¼Œç”Ÿæˆä¸ªæ€§åŒ–çš„å­¦ä¹ å»ºè®®
   */
  const generateLearningRecommendations = (
    mistakes: MistakeRecord[],
    weaknesses: WeaknessItem[]
  ): LearningRecommendation[] => {
    const recommendations: LearningRecommendation[] = []
    
    // ä¸ºæ¯ä¸ªé«˜ä¼˜å…ˆçº§è–„å¼±ç‚¹ç”Ÿæˆå»ºè®®
    weaknesses.filter(w => w.priority === 'high').forEach((weakness, index) => {
      recommendations.push({
        id: `weakness-${index}`,
        type: 'concept-review',
        title: `å¼ºåŒ– ${weakness.area} æ¦‚å¿µç†è§£`,
        description: `é’ˆå¯¹ ${weakness.area} é¢†åŸŸçš„ ${weakness.mistakeCount} ä¸ªé”™é¢˜è¿›è¡Œä¸“é¡¹å¤ä¹ `,
        priority: 9 - index,
        estimatedTime: weakness.mistakeCount * 15, // æ¯ä¸ªé”™é¢˜15åˆ†é’Ÿ
        difficulty: Math.round(weakness.averageDifficulty),
        targetKnowledgeIds: [],
        targetAreas: [weakness.area],
        reasons: [
          `è¯¥é¢†åŸŸé”™è¯¯ç‡è¾ƒé«˜ (${weakness.mistakeCount} ä¸ªé”™é¢˜)`,
          `å¹³å‡éš¾åº¦ ${weakness.averageDifficulty.toFixed(1)}/5`,
          `æ”¹è¿›æ½œåŠ›: ${(weakness.improvementPotential * 100).toFixed(0)}%`
        ],
        expectedOutcomes: [
          'å‡å°‘è¯¥é¢†åŸŸçš„é”™è¯¯ç‡',
          'æé«˜æ¦‚å¿µç†è§£æ·±åº¦',
          'å¢å¼ºè§£é¢˜ä¿¡å¿ƒ'
        ],
        steps: [
          {
            id: 'step-1',
            title: 'å›é¡¾åŸºç¡€æ¦‚å¿µ',
            description: 'é‡æ–°å­¦ä¹ ç›¸å…³ç†è®ºçŸ¥è¯†',
            type: 'study',
            estimatedTime: 30,
            resources: ['æ•™æ', 'è§†é¢‘æ•™ç¨‹'],
            prerequisites: []
          },
          {
            id: 'step-2',
            title: 'é”™é¢˜ä¸“é¡¹å¤ä¹ ',
            description: 'é‡åšæ‰€æœ‰ç›¸å…³é”™é¢˜',
            type: 'practice',
            estimatedTime: weakness.mistakeCount * 10,
            resources: ['é”™é¢˜æœ¬'],
            prerequisites: ['step-1']
          },
          {
            id: 'step-3',
            title: 'å¼ºåŒ–ç»ƒä¹ ',
            description: 'å®ŒæˆåŒç±»å‹é¢˜ç›®ç»ƒä¹ ',
            type: 'practice',
            estimatedTime: 40,
            resources: ['ç»ƒä¹ é¢˜åº“'],
            prerequisites: ['step-2']
          },
          {
            id: 'step-4',
            title: 'è‡ªæˆ‘æµ‹è¯•',
            description: 'è¿›è¡Œé˜¶æ®µæ€§æµ‹è¯•éªŒè¯',
            type: 'test',
            estimatedTime: 20,
            resources: ['æµ‹è¯•é¢˜'],
            prerequisites: ['step-3']
          }
        ],
        schedule: {
          totalDays: 7,
          dailyTime: 30,
          frequency: 'daily',
          flexibility: 'moderate'
        },
        successCriteria: [
          'é”™é¢˜å¤ä¹ å‡†ç¡®ç‡è¾¾åˆ° 90%',
          'æ–°é¢˜ç›®å‡†ç¡®ç‡è¾¾åˆ° 85%',
          'ç­”é¢˜ä¿¡å¿ƒåº¦æå‡åˆ° 4/5'
        ],
        progressMetrics: [
          'å¤ä¹ è¿›åº¦',
          'å‡†ç¡®ç‡è¶‹åŠ¿',
          'ä¿¡å¿ƒåº¦å˜åŒ–'
        ]
      })
    })
    
    // æ£€æµ‹æ˜¯å¦éœ€è¦åŸºç¡€çŸ¥è¯†è¡¥å¼º
    const conceptualErrors = mistakes.filter(m => m.errorType === 'conceptual').length
    if (conceptualErrors > mistakes.length * 0.4) {
      recommendations.push({
        id: 'foundation-strengthening',
        type: 'concept-review',
        title: 'åŸºç¡€çŸ¥è¯†ä½“ç³»è¡¥å¼º',
        description: 'ç³»ç»Ÿæ€§åœ°å¤ä¹ å’Œå·©å›ºåŸºç¡€æ¦‚å¿µ',
        priority: 10,
        estimatedTime: 120,
        difficulty: 3,
        targetKnowledgeIds: [],
        targetAreas: [...new Set(mistakes.map(m => m.knowledgeAreaName))],
        reasons: [
          `æ¦‚å¿µæ€§é”™è¯¯å æ¯” ${((conceptualErrors / mistakes.length) * 100).toFixed(0)}%`,
          'éœ€è¦é‡æ–°æ„å»ºçŸ¥è¯†æ¡†æ¶',
          'åŸºç¡€ä¸ç‰¢å›ºå½±å“åç»­å­¦ä¹ '
        ],
        expectedOutcomes: [
          'å»ºç«‹å®Œæ•´çš„çŸ¥è¯†ä½“ç³»',
          'æé«˜æ¦‚å¿µç†è§£å‡†ç¡®æ€§',
          'å‡å°‘åŸºç¡€æ€§é”™è¯¯'
        ],
        steps: [],
        schedule: {
          totalDays: 14,
          dailyTime: 45,
          frequency: 'daily',
          flexibility: 'strict'
        },
        successCriteria: [
          'åŸºç¡€æ¦‚å¿µæµ‹è¯•è¾¾åˆ° 95%',
          'æ¦‚å¿µæ€§é”™è¯¯å‡å°‘ 50%'
        ],
        progressMetrics: [
          'æ¦‚å¿µæŒæ¡åº¦',
          'é”™è¯¯ç±»å‹åˆ†å¸ƒå˜åŒ–'
        ]
      })
    }
    
    return recommendations.sort((a, b) => b.priority - a.priority)
  }
  
  const generateRecommendedActions = (mistakes: MistakeRecord[]): string[] => {
    const actions: string[] = []
    
    const avgDifficulty = mistakes.reduce((sum, m) => sum + m.difficultyLevel, 0) / mistakes.length
    
    if (avgDifficulty > 4) {
      actions.push('é™ä½éš¾åº¦ï¼Œä»åŸºç¡€é¢˜å¼€å§‹ç»ƒä¹ ')
    }
    
    const hasConceptualErrors = mistakes.some(m => m.errorType === 'conceptual')
    if (hasConceptualErrors) {
      actions.push('é‡æ–°å­¦ä¹ ç›¸å…³ç†è®ºæ¦‚å¿µ')
    }
    
    const hasCarelessErrors = mistakes.some(m => m.errorType === 'careless')
    if (hasCarelessErrors) {
      actions.push('æé«˜ä¸“æ³¨åº¦ï¼Œå‡æ…¢ç­”é¢˜é€Ÿåº¦')
    }
    
    const avgRetryCount = mistakes.reduce((sum, m) => sum + m.retryCount, 0) / mistakes.length
    if (avgRetryCount < 2) {
      actions.push('å¢åŠ å¤ä¹ é¢‘ç‡ï¼Œå¼ºåŒ–è®°å¿†')
    }
    
    return actions
  }
  
  return {
    detectErrorPatterns,
    analyzeWeaknesses,
    generateLearningRecommendations
  }
}

// composables/useWeaknessDetection.ts
export const useWeaknessDetection = () => {
  /**
   * å®æ—¶è–„å¼±ç‚¹æ£€æµ‹
   * åœ¨ç”¨æˆ·å¤ä¹ è¿‡ç¨‹ä¸­å®æ—¶æ£€æµ‹å’Œæ›´æ–°è–„å¼±ç‚¹ä¿¡æ¯
   */
  const detectWeaknesses = (reviewHistory: ReviewRecord[], timeWindow = 30): WeaknessDetection => {
    const recentHistory = reviewHistory.filter(record => {
      const recordDate = new Date(record.reviewDate)
      const cutoffDate = new Date(Date.now() - timeWindow * 24 * 60 * 60 * 1000)
      return recordDate >= cutoffDate
    })
    
    // è®¡ç®—å‡†ç¡®ç‡è¶‹åŠ¿
    const accuracyTrend = calculateAccuracyTrend(recentHistory)
    
    // è¯†åˆ«å›°éš¾çŸ¥è¯†ç‚¹
    const difficultAreas = identifyDifficultAreas(recentHistory)
    
    // æ£€æµ‹å­¦ä¹ åœæ»
    const learningPlateau = detectLearningPlateau(recentHistory)
    
    return {
      accuracyTrend,
      difficultAreas,
      learningPlateau,
      recommendations: generateImprovementPlan(difficultAreas, accuracyTrend)
    }
  }
  
  const calculateAccuracyTrend = (history: ReviewRecord[]): AccuracyTrend => {
    const windowSize = 10 // æ¯10é“é¢˜ä¸ºä¸€ä¸ªçª—å£
    const windows: number[] = []
    
    for (let i = 0; i < history.length; i += windowSize) {
      const window = history.slice(i, i + windowSize)
      const accuracy = window.filter(r => r.isCorrect).length / window.length
      windows.push(accuracy)
    }
    
    // è®¡ç®—è¶‹åŠ¿æ–œç‡
    const slope = calculateSlope(windows)
    
    return {
      currentAccuracy: windows[windows.length - 1] || 0,
      trend: slope > 0.05 ? 'improving' : slope < -0.05 ? 'declining' : 'stable',
      windows,
      slope
    }
  }
  
  const identifyDifficultAreas = (history: ReviewRecord[]): DifficultArea[] => {
    const areaStats = history.reduce((acc, record) => {
      // éœ€è¦ä»çŸ¥è¯†ç‚¹IDè·å–åŒºåŸŸä¿¡æ¯
      const area = 'default' // è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“æŸ¥è¯¢
      
      if (!acc[area]) {
        acc[area] = { correct: 0, total: 0, avgTime: 0 }
      }
      
      acc[area].total++
      if (record.isCorrect) acc[area].correct++
      acc[area].avgTime += record.responseTime
      
      return acc
    }, {} as Record<string, any>)
    
    return Object.entries(areaStats)
      .map(([area, stats]) => ({
        area,
        accuracy: stats.correct / stats.total,
        averageTime: stats.avgTime / stats.total,
        difficulty: 1 - (stats.correct / stats.total),
        sampleSize: stats.total
      }))
      .filter(area => area.accuracy < 0.7 && area.sampleSize >= 5)
      .sort((a, b) => a.accuracy - b.accuracy)
  }
  
  const detectLearningPlateau = (history: ReviewRecord[]): LearningPlateau | null => {
    const recentAccuracy = calculateRecentAccuracy(history, 20)
    const previousAccuracy = calculateRecentAccuracy(history.slice(0, -20), 20)
    
    const improvement = recentAccuracy - previousAccuracy
    
    if (Math.abs(improvement) < 0.05 && history.length > 40) {
      return {
        detected: true,
        duration: estimatePlateauDuration(history),
        currentLevel: recentAccuracy,
        suggestions: [
          'å°è¯•ä¸åŒçš„å­¦ä¹ ç­–ç•¥',
          'å¢åŠ é¢˜ç›®éš¾åº¦',
          'ä¼‘æ¯ä¸€æ®µæ—¶é—´å†ç»§ç»­',
          'å¯»æ±‚é¢å¤–çš„å­¦ä¹ èµ„æº'
        ]
      }
    }
    
    return null
  }
  
  return {
    detectWeaknesses,
    calculateAccuracyTrend,
    identifyDifficultAreas,
    detectLearningPlateau
  }
}
```

#### 4.3.5 APIæ¥å£è§„æ ¼

```typescript
// services/api/mistakes.ts
export interface MistakesAPI {
  // é”™é¢˜ç®¡ç†æ¥å£
  getUserMistakes(userId: string, filters?: MistakesFilter): Promise<MistakeRecord[]>
  addMistake(mistake: Omit<MistakeRecord, 'id'>): Promise<MistakeRecord>
  updateMistake(mistakeId: string, updates: Partial<MistakeRecord>): Promise<MistakeRecord>
  deleteMistake(mistakeId: string): Promise<void>
  batchUpdateMistakes(updates: Array<{id: string, updates: Partial<MistakeRecord>}>): Promise<void>
  
  // é”™è¯¯åˆ†ææ¥å£
  getStatistics(userId: string): Promise<MistakesStatistics>
  getErrorPatterns(userId: string): Promise<ErrorPatternItem[]>
  getWeaknessAnalysis(userId: string): Promise<WeaknessItem[]>
  
  // å­¦ä¹ å»ºè®®æ¥å£
  generateLearningRecommendations(userId: string): Promise<LearningRecommendation[]>
  getRecommendationProgress(userId: string, recommendationId: string): Promise<RecommendationProgress>
  updateRecommendationProgress(userId: string, recommendationId: string, progress: Partial<RecommendationProgress>): Promise<void>
  
  // é”™é¢˜å¤ä¹ æ¥å£
  createMistakeReviewSession(mistakeIds: string[], options: ReviewOptions): Promise<ReviewSession>
  recordMistakeReviewResult(mistakeId: string, result: MistakeReviewRecord): Promise<void>
  
  // å¯¼å…¥å¯¼å‡ºæ¥å£
  exportMistakes(userId: string, format: 'json' | 'csv' | 'pdf'): Promise<ExportResult>
  generateMistakeReport(userId: string, options: ReportOptions): Promise<ReportResult>
}

// REST API ç«¯ç‚¹è®¾è®¡
const MISTAKES_API_ENDPOINTS = {
  // é”™é¢˜ç®¡ç†
  USER_MISTAKES: '/api/mistakes/users/:userId',
  MISTAKE: '/api/mistakes/:mistakeId',
  BATCH_UPDATE: '/api/mistakes/batch',
  
  // ç»Ÿè®¡åˆ†æ
  STATISTICS: '/api/mistakes/users/:userId/statistics',
  ERROR_PATTERNS: '/api/mistakes/users/:userId/patterns',
  WEAKNESS_ANALYSIS: '/api/mistakes/users/:userId/weakness',
  
  // å­¦ä¹ å»ºè®®
  RECOMMENDATIONS: '/api/mistakes/users/:userId/recommendations',
  RECOMMENDATION_PROGRESS: '/api/mistakes/users/:userId/recommendations/:recommendationId/progress',
  
  // é”™é¢˜å¤ä¹ 
  REVIEW_SESSION: '/api/mistakes/review/sessions',
  REVIEW_RESULT: '/api/mistakes/:mistakeId/review-result',
  
  // å¯¼å…¥å¯¼å‡º
  EXPORT: '/api/mistakes/users/:userId/export',
  REPORT: '/api/mistakes/users/:userId/report'
}
```

#### 4.3.6 ç»„ä»¶å®ç°è§„æ ¼

```vue
<!-- views/Mistakes/Mistakes.vue -->
<template>
  <div class="mistakes">
    <!-- é¡µé¢å¤´éƒ¨ -->
    <div class="mistakes-header">
      <h1 class="page-title">é”™é¢˜æœ¬</h1>
      <div class="header-actions">
        <BatchActions
          v-if="selectedMistakes.size > 0"
          :selected-count="selectedMistakes.size"
          @batch-review="handleBatchReview"
          @batch-resolve="handleBatchResolve"
          @batch-delete="handleBatchDelete"
        />
        <div v-else class="quick-actions">
          <button @click="startAllMistakesReview" class="btn btn-primary">
            <Icon name="play" />
            å¤ä¹ å…¨éƒ¨é”™é¢˜
          </button>
          <button @click="generateReport" class="btn btn-secondary">
            <Icon name="chart" />
            ç”ŸæˆæŠ¥å‘Š
          </button>
        </div>
      </div>
    </div>
    
    <!-- ç»Ÿè®¡æ¦‚è§ˆ -->
    <MistakesOverview
      :statistics="mistakesStatistics"
      :loading="loading.statistics"
      @view-analysis="showAnalysisPanel = true"
    />
    
    <!-- è–„å¼±ç‚¹åˆ†æ -->
    <WeaknessAnalysis
      v-if="weakestAreas.length > 0"
      :weaknesses="weakestAreas"
      :recommendations="learningRecommendations"
      @start-improvement="handleStartImprovement"
    />
    
    <!-- ç­›é€‰å’Œæœç´¢ -->
    <MistakesFilter
      :filter="activeFilter"
      :available-areas="availableAreas"
      :available-categories="availableCategories"
      @update-filter="updateFilter"
      @reset-filter="resetFilter"
    />
    
    <!-- è§†å›¾åˆ‡æ¢ -->
    <div class="view-controls">
      <div class="view-modes">
        <button
          :class="['view-mode-btn', { active: viewMode === 'list' }]"
          @click="viewMode = 'list'"
        >
          <Icon name="list" />
          åˆ—è¡¨
        </button>
        <button
          :class="['view-mode-btn', { active: viewMode === 'grid' }]"
          @click="viewMode = 'grid'"
        >
          <Icon name="grid" />
          ç½‘æ ¼
        </button>
        <button
          :class="['view-mode-btn', { active: viewMode === 'analysis' }]"
          @click="viewMode = 'analysis'"
        >
          <Icon name="chart" />
          åˆ†æ
        </button>
      </div>
      
      <div class="display-options">
        <label class="checkbox-label">
          <input
            v-model="showResolved"
            type="checkbox"
            class="checkbox"
          />
          æ˜¾ç¤ºå·²æŒæ¡
        </label>
      </div>
    </div>
    
    <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
    <div class="mistakes-content">
      <!-- é”™é¢˜åˆ—è¡¨è§†å›¾ -->
      <MistakesList
        v-if="viewMode === 'list'"
        :mistakes="filteredMistakes"
        :selected="selectedMistakes"
        :loading="loading.mistakes"
        @select="handleSelectMistake"
        @review="handleReviewMistake"
        @resolve="handleResolveMistake"
        @delete="handleDeleteMistake"
        @view-detail="showMistakeDetail"
      />
      
      <!-- é”™é¢˜ç½‘æ ¼è§†å›¾ -->
      <MistakesGrid
        v-else-if="viewMode === 'grid'"
        :mistakes-by-area="mistakesByArea"
        :loading="loading.mistakes"
        @review-area="handleReviewAreaMistakes"
        @select-mistake="handleSelectMistake"
      />
      
      <!-- åˆ†æè§†å›¾ -->
      <MistakesAnalysis
        v-else-if="viewMode === 'analysis'"
        :statistics="mistakesStatistics"
        :error-patterns="errorPatterns"
        :learning-curve="learningCurve"
        :loading="loading.analysis"
      />
    </div>
    
    <!-- é”™é¢˜è¯¦æƒ…å¼¹çª— -->
    <MistakeDetail
      v-if="selectedMistakeDetail"
      :mistake="selectedMistakeDetail"
      :visible="showDetailModal"
      @close="showDetailModal = false"
      @review="handleReviewMistake"
      @resolve="handleResolveMistake"
      @add-note="handleAddNote"
    />
    
    <!-- å­¦ä¹ å»ºè®®é¢æ¿ -->
    <RecommendationPanel
      v-if="showAnalysisPanel"
      :recommendations="learningRecommendations"
      :visible="showAnalysisPanel"
      @close="showAnalysisPanel = false"
      @start-plan="handleStartLearningPlan"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { useMistakesStore } from '@/stores/mistakes'
import { useReviewStore } from '@/stores/review'

const mistakesStore = useMistakesStore()
const reviewStore = useReviewStore()

// å“åº”å¼çŠ¶æ€
const showDetailModal = ref(false)
const showAnalysisPanel = ref(false)
const selectedMistakeDetail = ref<MistakeRecord | null>(null)
const errorPatterns = ref<ErrorPatternItem[]>([])
const learningCurve = ref<any[]>([])

// è®¡ç®—å±æ€§
const filteredMistakes = computed(() => mistakesStore.filteredMistakes)
const mistakesByArea = computed(() => mistakesStore.mistakesByArea)
const mistakesStatistics = computed(() => mistakesStore.mistakesStatistics)
const selectedMistakes = computed(() => mistakesStore.selectedMistakes)
const activeFilter = computed(() => mistakesStore.activeFilter)
const weakestAreas = computed(() => mistakesStore.weakestAreas)
const learningRecommendations = computed(() => mistakesStore.learningRecommendations)
const loading = computed(() => mistakesStore.loading)
const viewMode = computed({
  get: () => mistakesStore.viewMode,
  set: (value) => mistakesStore.viewMode = value
})
const showResolved = computed({
  get: () => mistakesStore.showResolved,
  set: (value) => mistakesStore.showResolved = value
})

// å¯ç”¨ç­›é€‰é€‰é¡¹
const availableAreas = computed(() => 
  [...new Set(mistakesStore.mistakeRecords.map(m => m.knowledgeAreaName))]
)
const availableCategories = computed(() => 
  [...new Set(mistakesStore.mistakeRecords.map(m => m.category))]
)

// äº‹ä»¶å¤„ç†
const handleSelectMistake = (mistakeId: string, selected: boolean) => {
  if (selected) {
    mistakesStore.selectMistake(mistakeId)
  } else {
    mistakesStore.deselectMistake(mistakeId)
  }
}

const handleReviewMistake = async (mistakeId: string) => {
  await mistakesStore.startMistakeReview([mistakeId], 'normal')
}

const handleResolveMistake = async (mistakeId: string) => {
  await mistakesStore.resolveMistake(mistakeId)
}

const handleDeleteMistake = async (mistakeId: string) => {
  if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªé”™é¢˜å—ï¼Ÿ')) {
    await mistakesStore.deleteMistake(mistakeId)
  }
}

const handleBatchReview = async () => {
  const mistakeIds = Array.from(selectedMistakes.value)
  await mistakesStore.startMistakeReview(mistakeIds, 'intensive')
}

const handleBatchResolve = async () => {
  const mistakeIds = Array.from(selectedMistakes.value)
  if (confirm(`ç¡®å®šè¦å°† ${mistakeIds.length} ä¸ªé”™é¢˜æ ‡è®°ä¸ºå·²æŒæ¡å—ï¼Ÿ`)) {
    await mistakesStore.batchResolveMistakes(mistakeIds)
  }
}

const handleBatchDelete = async () => {
  const mistakeIds = Array.from(selectedMistakes.value)
  if (confirm(`ç¡®å®šè¦åˆ é™¤ ${mistakeIds.length} ä¸ªé”™é¢˜å—ï¼Ÿ`)) {
    for (const id of mistakeIds) {
      await mistakesStore.deleteMistake(id)
    }
  }
}

const handleReviewAreaMistakes = async (area: string) => {
  const areaMistakes = mistakesByArea.value[area] || []
  const mistakeIds = areaMistakes.map(m => m.id)
  await mistakesStore.startMistakeReview(mistakeIds, 'normal')
}

const showMistakeDetail = (mistake: MistakeRecord) => {
  selectedMistakeDetail.value = mistake
  showDetailModal.value = true
}

const handleStartImprovement = async (weakness: WeaknessItem) => {
  // å®ç°æ”¹è¿›è®¡åˆ’å¯åŠ¨é€»è¾‘
  console.log('Starting improvement plan for:', weakness)
}

const handleStartLearningPlan = async (recommendation: LearningRecommendation) => {
  // å®ç°å­¦ä¹ è®¡åˆ’å¯åŠ¨é€»è¾‘
  console.log('Starting learning plan:', recommendation)
}

const startAllMistakesReview = async () => {
  const activeMistakes = filteredMistakes.value.filter(m => !m.isResolved)
  if (activeMistakes.length === 0) {
    alert('æ²¡æœ‰å¯å¤ä¹ çš„é”™é¢˜')
    return
  }
  
  const mistakeIds = activeMistakes.map(m => m.id)
  await mistakesStore.startMistakeReview(mistakeIds, 'normal')
}

const generateReport = async () => {
  // å®ç°æŠ¥å‘Šç”Ÿæˆé€»è¾‘
  console.log('Generating report...')
}

const updateFilter = (filterUpdates: Partial<MistakesFilter>) => {
  mistakesStore.updateFilter(filterUpdates)
}

const resetFilter = () => {
  mistakesStore.resetFilter()
}

const handleAddNote = async (mistakeId: string, note: string) => {
  // å®ç°æ·»åŠ ç¬”è®°é€»è¾‘
  console.log('Adding note to mistake:', mistakeId, note)
}

// ç”Ÿå‘½å‘¨æœŸ
onMounted(async () => {
  await Promise.all([
    mistakesStore.loadMistakes(),
    mistakesStore.loadStatistics(),
    mistakesStore.generateRecommendations()
  ])
})
</script>

<style scoped>
.mistakes {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 24px;
  min-height: 100vh;
  background: var(--gradient-bg);
}

.mistakes-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.page-title {
  color: var(--text-primary);
  font-size: 2rem;
  font-weight: 600;
  margin: 0;
}

.header-actions {
  display: flex;
  gap: 12px;
}

.quick-actions {
  display: flex;
  gap: 12px;
}

.view-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 20px;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  border: 1px solid rgba(231, 76, 60, 0.1);
}

.view-modes {
  display: flex;
  gap: 8px;
}

.view-mode-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  border: 1px solid rgba(231, 76, 60, 0.2);
  border-radius: 8px;
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.3s ease;
}

.view-mode-btn:hover {
  background: rgba(231, 76, 60, 0.1);
  color: var(--text-primary);
}

.view-mode-btn.active {
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  color: white;
  border-color: #c0392b;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  color: var(--text-secondary);
  cursor: pointer;
}

.mistakes-content {
  flex: 1;
}
</style>
```

#### 4.3.7 æ€§èƒ½ä¼˜åŒ–è§„æ ¼

1. **æ•°æ®å¤„ç†ä¼˜åŒ–**:
   - é”™é¢˜åˆ†æä½¿ç”¨Web Workerï¼Œé¿å…ä¸»çº¿ç¨‹é˜»å¡
   - å¤§é‡é”™é¢˜åˆ—è¡¨ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼Œæ”¯æŒ1000+é”™é¢˜æµç•…å±•ç¤º
   - ç»Ÿè®¡å›¾è¡¨ä½¿ç”¨Canvasæ¸²æŸ“ï¼Œæå‡æ€§èƒ½

2. **ç¼“å­˜ç­–ç•¥**:
   - é”™é¢˜æ•°æ®æœ¬åœ°ç¼“å­˜15åˆ†é’Ÿ
   - ç»Ÿè®¡åˆ†æç»“æœç¼“å­˜30åˆ†é’Ÿ
   - å­¦ä¹ å»ºè®®ç¼“å­˜1å°æ—¶ï¼Œæ”¯æŒåå°æ›´æ–°

3. **æ™ºèƒ½åŠ è½½**:
   - é”™é¢˜åˆ—è¡¨åˆ†é¡µåŠ è½½ï¼Œæ¯é¡µ50æ¡
   - å›¾è¡¨æ•°æ®æŒ‰éœ€åŠ è½½
   - è¯¦æƒ…ä¿¡æ¯æ‡’åŠ è½½

4. **å†…å­˜ç®¡ç†**:
   - è‡ªåŠ¨æ¸…ç†è¿‡æœŸçš„é”™é¢˜åˆ†ææ•°æ®
   - å›¾è¡¨ç»„ä»¶é”€æ¯æ—¶é‡Šæ”¾èµ„æº
   - é¿å…å†…å­˜æ³„æ¼çš„å“åº”å¼æ•°æ®ç®¡ç†

#### 4.3.8 ç”¨æˆ·ä½“éªŒè§„æ ¼

1. **è§†è§‰åé¦ˆ**:
   - æ¯›ç»ç’ƒçº¢è‰²ä¸»é¢˜ï¼Œçªå‡ºé”™é¢˜çš„è­¦ç¤ºæ€§
   - é”™è¯¯ä¸¥é‡ç¨‹åº¦ç”¨é¢œè‰²æ·±æµ…è¡¨ç¤º
   - æ”¹è¿›è¶‹åŠ¿ç”¨åŠ¨ç”»æ•ˆæœå±•ç¤º

2. **äº¤äº’ä¼˜åŒ–**:
   - æ‰¹é‡æ“ä½œæ”¯æŒï¼Œæé«˜ç®¡ç†æ•ˆç‡
   - æ‹–æ‹½é€‰æ‹©é”™é¢˜
   - å³é”®èœå•å¿«é€Ÿæ“ä½œ

3. **å­¦ä¹ å¼•å¯¼**:
   - æ™ºèƒ½å­¦ä¹ å»ºè®®æ¨é€
   - è–„å¼±ç‚¹å¯è§†åŒ–çƒ­åŠ›å›¾
   - å­¦ä¹ è¿›åº¦è·Ÿè¸ª

4. **å“åº”å¼é€‚é…**:
   - ç§»åŠ¨ç«¯ä¼˜åŒ–çš„é”™é¢˜å¡ç‰‡å¸ƒå±€
   - è§¦æ‘¸å‹å¥½çš„äº¤äº’è®¾è®¡
   - é€‚é…ä¸åŒå±å¹•å°ºå¯¸çš„å›¾è¡¨å±•ç¤º

#### 4.3.9 æµ‹è¯•è§„æ ¼

```typescript
// ç»„ä»¶æµ‹è¯•
describe('MistakeCard Component', () => {
  it('åº”è¯¥æ­£ç¡®æ¸²æŸ“é”™é¢˜ä¿¡æ¯', () => {
    // æµ‹è¯•é”™é¢˜å¡ç‰‡çš„åŸºæœ¬æ¸²æŸ“
  })
  
  it('åº”è¯¥æ­£ç¡®å¤„ç†æ“ä½œæŒ‰é’®ç‚¹å‡»', () => {
    // æµ‹è¯•å¤ä¹ ã€æ ‡è®°å·²æŒæ¡ã€åˆ é™¤ç­‰æ“ä½œ
  })
})

// åˆ†æç®—æ³•æµ‹è¯•
describe('Mistakes Analysis', () => {
  it('åº”è¯¥æ­£ç¡®æ£€æµ‹é”™è¯¯æ¨¡å¼', () => {
    // æµ‹è¯•é”™è¯¯æ¨¡å¼æ£€æµ‹ç®—æ³•
  })
  
  it('åº”è¯¥ç”Ÿæˆåˆç†çš„å­¦ä¹ å»ºè®®', () => {
    // æµ‹è¯•å­¦ä¹ å»ºè®®ç”Ÿæˆç®—æ³•
  })
})

// é›†æˆæµ‹è¯•
describe('Mistakes Module Integration', () => {
  it('åº”è¯¥æ­£ç¡®åŒæ­¥é”™é¢˜æ•°æ®', () => {
    // æµ‹è¯•é”™é¢˜æ•°æ®çš„åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤
  })
  
  it('åº”è¯¥æ­£ç¡®å¯åŠ¨é”™é¢˜å¤ä¹ ', () => {
    // æµ‹è¯•é”™é¢˜å¤ä¹ çš„å®Œæ•´æµç¨‹
  })
})
```

---

## âœï¸ 5. ç¬”è®°ç¼–è¾‘æ¨¡å—åŠŸèƒ½è§„æ ¼

### 5.1 æ¨¡å—æ¦‚è¿°

ç¬”è®°ç¼–è¾‘æ¨¡å—æ˜¯çŸ¥è¯†ç®¡ç†ç³»ç»Ÿçš„å¯è§†åŒ–ç¼–è¾‘å™¨ï¼Œæä¾›ä¸‰çº§çŸ¥è¯†æ¶æ„çš„ç›´è§‚ç¼–è¾‘ã€å¤šç§é¢˜å‹æ”¯æŒã€å®æ—¶é¢„è§ˆå’Œæ‰¹é‡å¯¼å…¥å¯¼å‡ºåŠŸèƒ½ï¼Œè®©ç”¨æˆ·èƒ½å¤Ÿé«˜æ•ˆåœ°æ„å»ºå’Œç®¡ç†çŸ¥è¯†ä½“ç³»ã€‚

### 5.2 ç°æœ‰å®ç°åˆ†æ

#### 5.2.1 æ ¸å¿ƒæ¶æ„åˆ†æ

**ä¸»æ§ç±»**: `NotesManager`ç±» (1126è¡Œä»£ç )
- **èŒè´£**: å¯è§†åŒ–çŸ¥è¯†ç»“æ„ç¼–è¾‘ã€æ ‘çŠ¶å¯¼èˆªã€è¡¨å•ç¼–è¾‘å™¨ã€æ•°æ®å¯¼å…¥å¯¼å‡º
- **æ ¸å¿ƒçŠ¶æ€**:
  - `currentData`: ç¬”è®°æ•°æ®ç»“æ„ï¼ˆçŸ¥è¯†åº“æ•°ç»„ï¼‰
  - `currentSelection`: å½“å‰é€‰ä¸­çš„é¡¹ç›®
  - `selectionType`: é€‰ä¸­ç±»å‹ï¼ˆ'knowledgeBase'|'area'|'point'ï¼‰

#### 5.2.2 çŸ¥è¯†ç»“æ„ç¼–è¾‘ç³»ç»Ÿ

```javascript
// ä¸‰çº§æ¶æ„æ•°æ®ç»“æ„
currentData: {
  knowledgeBases: [
    {
      id: string,
      name: string,
      description: string,
      icon: string,
      color: string,
      areas: [
        {
          id: string,
          name: string,
          description: string,
          color: string,
          knowledgePoints: [
            {
              id: string,
              type: 'choice'|'fill',
              question: string,
              answer: string,
              explanation: string,
              options: ChoiceOption[],
              correctAnswer: string,
              choiceType: 'single'|'multiple',
              tags: string[],
              difficulty: 1-4
            }
          ]
        }
      ]
    }
  ]
}
```

#### 5.2.3 ç¼–è¾‘å™¨åŠŸèƒ½æ¨¡å—

**æ ‘çŠ¶å¯¼èˆªç³»ç»Ÿ**:
```javascript
renderTree()                    // æ¸²æŸ“å®Œæ•´æ ‘çŠ¶ç»“æ„
renderKnowledgeBase(kb)         // æ¸²æŸ“çŸ¥è¯†åº“èŠ‚ç‚¹
renderKnowledgeArea(area)       // æ¸²æŸ“çŸ¥è¯†åŒºèŠ‚ç‚¹
renderKnowledgePoint(point)     // æ¸²æŸ“çŸ¥è¯†ç‚¹èŠ‚ç‚¹
selectKnowledgeBase(id)         // é€‰æ‹©çŸ¥è¯†åº“
selectKnowledgeArea(kbId, areaId) // é€‰æ‹©çŸ¥è¯†åŒº
selectKnowledgePoint(kbId, areaId, pointId) // é€‰æ‹©çŸ¥è¯†ç‚¹
```

**è¡¨å•ç¼–è¾‘å™¨ç³»ç»Ÿ**:
```javascript
renderKnowledgeBaseEditor(kb)   // çŸ¥è¯†åº“ç¼–è¾‘è¡¨å•
renderKnowledgeAreaEditor(area) // çŸ¥è¯†åŒºç¼–è¾‘è¡¨å•
renderKnowledgePointEditor(point) // çŸ¥è¯†ç‚¹ç¼–è¾‘è¡¨å•
renderChoiceOptions(point)      // é€‰æ‹©é¢˜é€‰é¡¹ç¼–è¾‘
toggleCorrectAnswer(key)        // åˆ‡æ¢æ­£ç¡®ç­”æ¡ˆ
addChoiceOption()              // æ·»åŠ é€‰é¡¹
removeChoiceOption()           // åˆ é™¤é€‰é¡¹
```

#### 5.2.4 é€‰æ‹©é¢˜ç¼–è¾‘å™¨

```javascript
// é€‰æ‹©é¢˜é€‰é¡¹ç»“æ„
{
  options: [
    { key: 'A', text: 'é€‰é¡¹Aå†…å®¹' },
    { key: 'B', text: 'é€‰é¡¹Bå†…å®¹' },
    { key: 'C', text: 'é€‰é¡¹Cå†…å®¹' },
    { key: 'D', text: 'é€‰é¡¹Då†…å®¹' }
  ],
  correctAnswer: 'A,C',         // å¤šé€‰ç”¨é€—å·åˆ†éš”
  choiceType: 'single'|'multiple'
}

// é€‰æ‹©é¢˜ç¼–è¾‘åŠŸèƒ½
- åŠ¨æ€æ·»åŠ /åˆ é™¤é€‰é¡¹ï¼ˆæœ€å°‘ä¿ç•™2ä¸ªï¼‰
- å•é€‰/å¤šé€‰æ¨¡å¼åˆ‡æ¢
- å¯è§†åŒ–æ­£ç¡®ç­”æ¡ˆæ ‡è®°
- é€‰é¡¹å†…å®¹å®æ—¶ç¼–è¾‘
```

#### 5.2.5 å¯¼å…¥å¯¼å‡ºç³»ç»Ÿ

```javascript
// JSONæ ¼å¼å¯¼å…¥å¯¼å‡º
handleImport()                  // å¤„ç†JSONæ–‡ä»¶å¯¼å…¥
handleExport()                  // å¯¼å‡ºä¸ºJSONæ ¼å¼
importToMainSystem()            // å¯¼å…¥åˆ°ä¸»çŸ¥è¯†åº“ç³»ç»Ÿ

// Markdownæ ¼å¼æ”¯æŒ
convertToMarkdown(data)         // è½¬æ¢ä¸ºMarkdownæ ¼å¼
parseMarkdown(content)          // è§£æMarkdownæ–‡ä»¶
mergeData(importData)           // åˆå¹¶å¯¼å…¥æ•°æ®
```

#### 5.2.6 ç•Œé¢å¸ƒå±€ç³»ç»Ÿ

```html
<!-- å·¦å³åˆ†æ å¸ƒå±€ -->
<div class="notes-container">
  <!-- å·¦ä¾§æ ‘çŠ¶å¯¼èˆª -->
  <div class="notes-sidebar">
    <div class="toolbar">ğŸ“š æ–°å»ºçŸ¥è¯†åº“</div>
    <div class="tree-view" id="treeView"><!-- æ ‘çŠ¶ç»“æ„ --></div>
  </div>
  
  <!-- å³ä¾§ç¼–è¾‘å™¨ -->
  <div class="notes-main">
    <div class="notes-header"><!-- æ ‡é¢˜å’Œè·¯å¾„ --></div>
    <div class="notes-editor" id="editorContent"><!-- è¡¨å•ç¼–è¾‘å™¨ --></div>
  </div>
</div>
```

#### 5.2.7 å­˜åœ¨é—®é¢˜

1. **ä»£ç ç»“æ„**: å•ä½“ç±»è®¾è®¡ï¼Œç¼ºä¹æ¨¡å—åŒ–å’Œç»„ä»¶åŒ–
2. **çŠ¶æ€ç®¡ç†**: ç›´æ¥DOMæ“ä½œï¼Œç¼ºä¹å“åº”å¼æ•°æ®ç®¡ç†
3. **ç”¨æˆ·ä½“éªŒ**: è¡¨å•ç¼–è¾‘å™¨è¾ƒä¸ºç®€é™‹ï¼Œç¼ºä¹å¯Œæ–‡æœ¬ç¼–è¾‘
4. **æ•°æ®éªŒè¯**: ç¼ºä¹å®Œæ•´çš„è¡¨å•éªŒè¯å’Œé”™è¯¯å¤„ç†
5. **åä½œåŠŸèƒ½**: ç¼ºä¹ç‰ˆæœ¬æ§åˆ¶å’Œå¤šäººåä½œæ”¯æŒ
6. **æ€§èƒ½ä¼˜åŒ–**: å¤§å‹çŸ¥è¯†åº“çš„æ¸²æŸ“æ€§èƒ½æœ‰å¾…ä¼˜åŒ–

### 5.3 Vueé‡æ„æ–¹æ¡ˆ

#### 5.3.1 ç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// ç¬”è®°ç¼–è¾‘æ¨¡å—ç»„ä»¶æ ‘ç»“æ„
src/views/Notes/
â”œâ”€â”€ Notes.vue                               // ä¸»å®¹å™¨ç»„ä»¶
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Navigation/
â”‚   â”‚   â”œâ”€â”€ NotesNavigation.vue             // å·¦ä¾§å¯¼èˆªå®¹å™¨
â”‚   â”‚   â”œâ”€â”€ TreeView.vue                    // æ ‘çŠ¶è§†å›¾ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ TreeNode.vue                    // æ ‘èŠ‚ç‚¹ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ KnowledgeBaseNode.vue           // çŸ¥è¯†åº“èŠ‚ç‚¹
â”‚   â”‚   â”œâ”€â”€ KnowledgeAreaNode.vue           // çŸ¥è¯†åŒºèŠ‚ç‚¹
â”‚   â”‚   â”œâ”€â”€ KnowledgePointNode.vue          // çŸ¥è¯†ç‚¹èŠ‚ç‚¹
â”‚   â”‚   â””â”€â”€ NodeActions.vue                 // èŠ‚ç‚¹æ“ä½œæŒ‰é’®
â”‚   â”œâ”€â”€ Editor/
â”‚   â”‚   â”œâ”€â”€ NotesEditor.vue                 // ç¼–è¾‘å™¨å®¹å™¨
â”‚   â”‚   â”œâ”€â”€ EditorToolbar.vue               // ç¼–è¾‘å™¨å·¥å…·æ 
â”‚   â”‚   â”œâ”€â”€ KnowledgeBaseEditor.vue         // çŸ¥è¯†åº“ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ KnowledgeAreaEditor.vue         // çŸ¥è¯†åŒºç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ KnowledgePointEditor.vue        // çŸ¥è¯†ç‚¹ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ QuestionEditor.vue              // é¢˜ç›®ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ ChoiceEditor.vue                // é€‰æ‹©é¢˜ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ FillEditor.vue                  // å¡«ç©ºé¢˜ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ OptionsEditor.vue               // é€‰é¡¹ç¼–è¾‘å™¨
â”‚   â”‚   â”œâ”€â”€ TagsEditor.vue                  // æ ‡ç­¾ç¼–è¾‘å™¨
â”‚   â”‚   â””â”€â”€ DifficultySelector.vue          // éš¾åº¦é€‰æ‹©å™¨
â”‚   â”œâ”€â”€ Preview/
â”‚   â”‚   â”œâ”€â”€ NotesPreview.vue                // é¢„è§ˆå®¹å™¨
â”‚   â”‚   â”œâ”€â”€ QuestionPreview.vue             // é¢˜ç›®é¢„è§ˆ
â”‚   â”‚   â”œâ”€â”€ ChoicePreview.vue               // é€‰æ‹©é¢˜é¢„è§ˆ
â”‚   â”‚   â”œâ”€â”€ FillPreview.vue                 // å¡«ç©ºé¢˜é¢„è§ˆ
â”‚   â”‚   â””â”€â”€ StructurePreview.vue            // ç»“æ„é¢„è§ˆ
â”‚   â”œâ”€â”€ Import/
â”‚   â”‚   â”œâ”€â”€ ImportDialog.vue                // å¯¼å…¥å¯¹è¯æ¡†
â”‚   â”‚   â”œâ”€â”€ ImportUploader.vue              // æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ImportPreview.vue               // å¯¼å…¥é¢„è§ˆ
â”‚   â”‚   â”œâ”€â”€ FormatSelector.vue              // æ ¼å¼é€‰æ‹©å™¨
â”‚   â”‚   â””â”€â”€ ImportProgress.vue              // å¯¼å…¥è¿›åº¦
â”‚   â”œâ”€â”€ Export/
â”‚   â”‚   â”œâ”€â”€ ExportDialog.vue                // å¯¼å‡ºå¯¹è¯æ¡†
â”‚   â”‚   â”œâ”€â”€ ExportOptions.vue               // å¯¼å‡ºé€‰é¡¹
â”‚   â”‚   â”œâ”€â”€ ExportPreview.vue               // å¯¼å‡ºé¢„è§ˆ
â”‚   â”‚   â””â”€â”€ ExportProgress.vue              // å¯¼å‡ºè¿›åº¦
â”‚   â””â”€â”€ Common/
â”‚       â”œâ”€â”€ ColorPicker.vue                 // é¢œè‰²é€‰æ‹©å™¨
â”‚       â”œâ”€â”€ IconSelector.vue                // å›¾æ ‡é€‰æ‹©å™¨
â”‚       â”œâ”€â”€ ValidationMessage.vue           // éªŒè¯ä¿¡æ¯
â”‚       â”œâ”€â”€ LoadingState.vue                // åŠ è½½çŠ¶æ€
â”‚       â”œâ”€â”€ EmptyState.vue                  // ç©ºçŠ¶æ€
â”‚       â””â”€â”€ ConfirmDialog.vue               // ç¡®è®¤å¯¹è¯æ¡†
â””â”€â”€ composables/
    â”œâ”€â”€ useNotesData.ts                     // ç¬”è®°æ•°æ®ç®¡ç†
    â”œâ”€â”€ useNotesNavigation.ts               // å¯¼èˆªé€»è¾‘
    â”œâ”€â”€ useNotesEditor.ts                   // ç¼–è¾‘å™¨é€»è¾‘
    â”œâ”€â”€ useQuestionEditor.ts                // é¢˜ç›®ç¼–è¾‘é€»è¾‘
    â”œâ”€â”€ useChoiceOptions.ts                 // é€‰æ‹©é¢˜é€‰é¡¹ç®¡ç†
    â”œâ”€â”€ useNotesValidation.ts               // è¡¨å•éªŒè¯
    â”œâ”€â”€ useNotesImport.ts                   // å¯¼å…¥é€»è¾‘
    â”œâ”€â”€ useNotesExport.ts                   // å¯¼å‡ºé€»è¾‘
    â”œâ”€â”€ useNotesPreview.ts                  // é¢„è§ˆé€»è¾‘
    â””â”€â”€ useNotesKeyboard.ts                 // é”®ç›˜å¿«æ·é”®
```

#### 5.3.2 æ•°æ®æ¨¡å‹è§„æ ¼

```typescript
// types/notes.ts
export interface NotesData {
  knowledgeBases: NotesKnowledgeBase[]
  version: string
  createdAt: string
  updatedAt: string
  metadata: NotesMetadata
}

export interface NotesKnowledgeBase {
  id: string
  name: string
  description: string
  icon: string
  color: string
  createdAt: string
  updatedAt: string
  areas: NotesKnowledgeArea[]
  metadata: KnowledgeBaseMetadata
  settings: KnowledgeBaseSettings
}

export interface NotesKnowledgeArea {
  id: string
  name: string
  description: string
  color: string
  createdAt: string
  updatedAt: string
  knowledgePoints: NotesKnowledgePoint[]
  metadata: KnowledgeAreaMetadata
  order: number
}

export interface NotesKnowledgePoint {
  id: string
  type: QuestionType
  question: string
  answer: string
  explanation: string
  tags: string[]
  difficulty: number
  createdAt: string
  updatedAt: string
  
  // é€‰æ‹©é¢˜ç‰¹æœ‰å±æ€§
  options?: ChoiceOption[]
  correctAnswer?: string
  choiceType?: 'single' | 'multiple'
  
  // å¡«ç©ºé¢˜ç‰¹æœ‰å±æ€§
  fillType?: 'text' | 'number' | 'formula'
  caseSensitive?: boolean
  
  // å…ƒæ•°æ®
  metadata: KnowledgePointMetadata
  statistics: KnowledgePointStatistics
  
  // å…³è”æ•°æ®
  relatedPoints: string[]
  prerequisites: string[]
  references: Reference[]
}

export type QuestionType = 'choice' | 'fill' | 'essay' | 'code' | 'image'

export interface ChoiceOption {
  key: string
  text: string
  explanation?: string
  image?: string
  order: number
  metadata?: OptionMetadata
}

export interface NotesMetadata {
  author: string
  version: string
  lastBackup: string
  totalKnowledgeBases: number
  totalKnowledgeAreas: number
  totalKnowledgePoints: number
  fileSize: number
  checksum: string
}

export interface KnowledgeBaseMetadata {
  createdBy: string
  lastEditedBy: string
  editCount: number
  exportCount: number
  isPublic: boolean
  tags: string[]
  category: string
  subject: string
}

export interface NotesSettings {
  // ç¼–è¾‘å™¨è®¾ç½®
  editor: {
    autoSave: boolean
    autoSaveInterval: number
    showPreview: boolean
    enableValidation: boolean
    defaultQuestionType: QuestionType
    defaultDifficulty: number
  }
  
  // å¯¼å…¥å¯¼å‡ºè®¾ç½®
  export: {
    includeMetadata: boolean
    includeStatistics: boolean
    defaultFormat: 'json' | 'markdown' | 'csv'
    compression: boolean
  }
  
  // ç•Œé¢è®¾ç½®
  ui: {
    theme: 'light' | 'dark' | 'auto'
    sidebarWidth: number
    showTreeLines: boolean
    compactMode: boolean
    language: string
  }
  
  // éªŒè¯è®¾ç½®
  validation: {
    requireQuestion: boolean
    requireAnswer: boolean
    requireExplanation: boolean
    minChoiceOptions: number
    maxChoiceOptions: number
    allowEmptyTags: boolean
  }
}

export interface NotesValidationRules {
  knowledgeBase: {
    name: ValidationRule
    description: ValidationRule
    icon: ValidationRule
    color: ValidationRule
  }
  
  knowledgeArea: {
    name: ValidationRule
    description: ValidationRule
    color: ValidationRule
  }
  
  knowledgePoint: {
    question: ValidationRule
    answer: ValidationRule
    explanation: ValidationRule
    tags: ValidationRule
    difficulty: ValidationRule
    options: ValidationRule
    correctAnswer: ValidationRule
  }
}

export interface ValidationRule {
  required: boolean
  minLength?: number
  maxLength?: number
  pattern?: RegExp
  custom?: (value: any) => boolean | string
}

export interface NotesFilter {
  searchQuery: string
  questionTypes: QuestionType[]
  difficulties: number[]
  tags: string[]
  dateRange: {
    start?: string
    end?: string
  }
  sortBy: 'name' | 'created' | 'updated' | 'difficulty'
  sortOrder: 'asc' | 'desc'
  includeEmpty: boolean
}

export interface ImportOptions {
  format: 'json' | 'markdown' | 'csv' | 'xlsx'
  mergeStrategy: 'replace' | 'merge' | 'append'
  validateData: boolean
  backupBeforeImport: boolean
  encoding: string
  skipErrors: boolean
}

export interface ExportOptions {
  format: 'json' | 'markdown' | 'csv' | 'pdf' | 'docx'
  includeMetadata: boolean
  includeStatistics: boolean
  includeImages: boolean
  compression: boolean
  password?: string
  template?: string
}

export interface NotesBackup {
  id: string
  timestamp: string
  version: string
  data: NotesData
  metadata: {
    size: number
    checksum: string
    notes: string
  }
}
```

#### 5.3.3 çŠ¶æ€ç®¡ç†è§„æ ¼

```typescript
// stores/notes.ts
export const useNotesStore = defineStore('notes', () => {
  // æ ¸å¿ƒçŠ¶æ€
  const notesData = ref<NotesData>({
    knowledgeBases: [],
    version: '2.0.0',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    metadata: getDefaultMetadata()
  })
  
  const currentSelection = ref<{
    type: 'knowledgeBase' | 'area' | 'point' | null
    item: any
    path: string[]
  }>({
    type: null,
    item: null,
    path: []
  })
  
  const settings = ref<NotesSettings>(getDefaultSettings())
  const filter = ref<NotesFilter>(getDefaultFilter())
  
  // UIçŠ¶æ€
  const sidebarCollapsed = ref(false)
  const previewMode = ref(false)
  const validationErrors = ref<Record<string, string[]>>({})
  const isDirty = ref(false)
  const autoSaveTimer = ref<NodeJS.Timeout | null>(null)
  
  // åŠ è½½çŠ¶æ€
  const loading = ref({
    data: false,
    save: false,
    import: false,
    export: false,
    validation: false
  })
  
  // è®¡ç®—å±æ€§
  const filteredKnowledgeBases = computed(() => {
    let filtered = notesData.value.knowledgeBases
    
    // æœç´¢è¿‡æ»¤
    if (filter.value.searchQuery) {
      const query = filter.value.searchQuery.toLowerCase()
      filtered = filtered.filter(kb => 
        kb.name.toLowerCase().includes(query) ||
        kb.description.toLowerCase().includes(query) ||
        kb.areas.some(area => 
          area.name.toLowerCase().includes(query) ||
          area.knowledgePoints.some(point => 
            point.question.toLowerCase().includes(query)
          )
        )
      )
    }
    
    // é¢˜å‹è¿‡æ»¤
    if (filter.value.questionTypes.length > 0) {
      filtered = filtered.map(kb => ({
        ...kb,
        areas: kb.areas.map(area => ({
          ...area,
          knowledgePoints: area.knowledgePoints.filter(point =>
            filter.value.questionTypes.includes(point.type)
          )
        })).filter(area => area.knowledgePoints.length > 0)
      })).filter(kb => kb.areas.length > 0)
    }
    
    return filtered
  })
  
  const totalStatistics = computed(() => {
    const stats = {
      knowledgeBases: notesData.value.knowledgeBases.length,
      knowledgeAreas: 0,
      knowledgePoints: 0,
      questionTypes: {} as Record<QuestionType, number>,
      difficulties: {} as Record<number, number>
    }
    
    notesData.value.knowledgeBases.forEach(kb => {
      stats.knowledgeAreas += kb.areas.length
      
      kb.areas.forEach(area => {
        stats.knowledgePoints += area.knowledgePoints.length
        
        area.knowledgePoints.forEach(point => {
          // ç»Ÿè®¡é¢˜å‹
          if (!stats.questionTypes[point.type]) {
            stats.questionTypes[point.type] = 0
          }
          stats.questionTypes[point.type]++
          
          // ç»Ÿè®¡éš¾åº¦
          if (!stats.difficulties[point.difficulty]) {
            stats.difficulties[point.difficulty] = 0
          }
          stats.difficulties[point.difficulty]++
        })
      })
    })
    
    return stats
  })
  
  const validationStatus = computed(() => {
    const errors = Object.values(validationErrors.value).flat()
    return {
      isValid: errors.length === 0,
      errorCount: errors.length,
      hasWarnings: errors.some(error => error.includes('warning'))
    }
  })
  
  // æ•°æ®æ“ä½œ
  const loadNotesData = async () => {
    if (loading.value.data) return
    
    loading.value.data = true
    try {
      const savedData = localStorage.getItem('memorin-notes')
      if (savedData) {
        notesData.value = JSON.parse(savedData)
      }
    } catch (error) {
      console.error('Failed to load notes data:', error)
    } finally {
      loading.value.data = false
    }
  }
  
  const saveNotesData = async (forceImmediate = false) => {
    if (loading.value.save && !forceImmediate) return
    
    loading.value.save = true
    try {
      notesData.value.updatedAt = new Date().toISOString()
      localStorage.setItem('memorin-notes', JSON.stringify(notesData.value))
      isDirty.value = false
    } catch (error) {
      console.error('Failed to save notes data:', error)
      throw error
    } finally {
      loading.value.save = false
    }
  }
  
  const createKnowledgeBase = () => {
    const newKb: NotesKnowledgeBase = {
      id: generateId(),
      name: 'æ–°çŸ¥è¯†åº“',
      description: '',
      icon: 'ğŸ“š',
      color: '#667eea',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      areas: [],
      metadata: getDefaultKbMetadata(),
      settings: getDefaultKbSettings()
    }
    
    notesData.value.knowledgeBases.push(newKb)
    selectKnowledgeBase(newKb.id)
    markDirty()
    
    return newKb
  }
  
  const createKnowledgeArea = (knowledgeBaseId: string) => {
    const kb = findKnowledgeBase(knowledgeBaseId)
    if (!kb) return null
    
    const newArea: NotesKnowledgeArea = {
      id: generateId(),
      name: 'æ–°çŸ¥è¯†åŒº',
      description: '',
      color: '#667eea',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      knowledgePoints: [],
      metadata: getDefaultAreaMetadata(),
      order: kb.areas.length
    }
    
    kb.areas.push(newArea)
    kb.updatedAt = new Date().toISOString()
    selectKnowledgeArea(knowledgeBaseId, newArea.id)
    markDirty()
    
    return newArea
  }
  
  const createKnowledgePoint = (knowledgeBaseId: string, areaId: string) => {
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    if (!area) return null
    
    const newPoint: NotesKnowledgePoint = {
      id: generateId(),
      type: settings.value.editor.defaultQuestionType,
      question: '',
      answer: '',
      explanation: '',
      tags: [],
      difficulty: settings.value.editor.defaultDifficulty,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      metadata: getDefaultPointMetadata(),
      statistics: getDefaultPointStatistics(),
      relatedPoints: [],
      prerequisites: [],
      references: []
    }
    
    // æ ¹æ®é¢˜å‹åˆå§‹åŒ–ç‰¹æœ‰å±æ€§
    if (newPoint.type === 'choice') {
      newPoint.options = [
        { key: 'A', text: '', order: 0 },
        { key: 'B', text: '', order: 1 },
        { key: 'C', text: '', order: 2 },
        { key: 'D', text: '', order: 3 }
      ]
      newPoint.choiceType = 'single'
      newPoint.correctAnswer = ''
    }
    
    area.knowledgePoints.push(newPoint)
    area.updatedAt = new Date().toISOString()
    selectKnowledgePoint(knowledgeBaseId, areaId, newPoint.id)
    markDirty()
    
    return newPoint
  }
  
  // æ›´æ–°æ“ä½œ
  const updateKnowledgeBase = (id: string, updates: Partial<NotesKnowledgeBase>) => {
    const kb = findKnowledgeBase(id)
    if (!kb) return false
    
    Object.assign(kb, updates, { updatedAt: new Date().toISOString() })
    markDirty()
    return true
  }
  
  const updateKnowledgeArea = (knowledgeBaseId: string, areaId: string, updates: Partial<NotesKnowledgeArea>) => {
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    if (!area) return false
    
    Object.assign(area, updates, { updatedAt: new Date().toISOString() })
    
    // æ›´æ–°çˆ¶çº§çŸ¥è¯†åº“çš„æ›´æ–°æ—¶é—´
    const kb = findKnowledgeBase(knowledgeBaseId)
    if (kb) kb.updatedAt = new Date().toISOString()
    
    markDirty()
    return true
  }
  
  const updateKnowledgePoint = (knowledgeBaseId: string, areaId: string, pointId: string, updates: Partial<NotesKnowledgePoint>) => {
    const point = findKnowledgePoint(knowledgeBaseId, areaId, pointId)
    if (!point) return false
    
    Object.assign(point, updates, { updatedAt: new Date().toISOString() })
    
    // æ›´æ–°çˆ¶çº§çš„æ›´æ–°æ—¶é—´
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    if (area) area.updatedAt = new Date().toISOString()
    
    const kb = findKnowledgeBase(knowledgeBaseId)
    if (kb) kb.updatedAt = new Date().toISOString()
    
    markDirty()
    return true
  }
  
  // åˆ é™¤æ“ä½œ
  const deleteKnowledgeBase = (id: string) => {
    const index = notesData.value.knowledgeBases.findIndex(kb => kb.id === id)
    if (index === -1) return false
    
    notesData.value.knowledgeBases.splice(index, 1)
    
    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„ï¼Œæ¸…ç©ºé€‰æ‹©
    if (currentSelection.value.type === 'knowledgeBase' && currentSelection.value.item?.id === id) {
      clearSelection()
    }
    
    markDirty()
    return true
  }
  
  const deleteKnowledgeArea = (knowledgeBaseId: string, areaId: string) => {
    const kb = findKnowledgeBase(knowledgeBaseId)
    if (!kb) return false
    
    const index = kb.areas.findIndex(area => area.id === areaId)
    if (index === -1) return false
    
    kb.areas.splice(index, 1)
    kb.updatedAt = new Date().toISOString()
    
    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„ï¼Œæ¸…ç©ºé€‰æ‹©
    if (currentSelection.value.type === 'area' && currentSelection.value.item?.id === areaId) {
      clearSelection()
    }
    
    markDirty()
    return true
  }
  
  const deleteKnowledgePoint = (knowledgeBaseId: string, areaId: string, pointId: string) => {
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    if (!area) return false
    
    const index = area.knowledgePoints.findIndex(point => point.id === pointId)
    if (index === -1) return false
    
    area.knowledgePoints.splice(index, 1)
    area.updatedAt = new Date().toISOString()
    
    // æ›´æ–°çˆ¶çº§çŸ¥è¯†åº“çš„æ›´æ–°æ—¶é—´
    const kb = findKnowledgeBase(knowledgeBaseId)
    if (kb) kb.updatedAt = new Date().toISOString()
    
    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„ï¼Œæ¸…ç©ºé€‰æ‹©
    if (currentSelection.value.type === 'point' && currentSelection.value.item?.id === pointId) {
      clearSelection()
    }
    
    markDirty()
    return true
  }
  
  // é€‰æ‹©æ“ä½œ
  const selectKnowledgeBase = (id: string) => {
    const kb = findKnowledgeBase(id)
    if (!kb) return false
    
    currentSelection.value = {
      type: 'knowledgeBase',
      item: kb,
      path: [kb.name]
    }
    
    return true
  }
  
  const selectKnowledgeArea = (knowledgeBaseId: string, areaId: string) => {
    const kb = findKnowledgeBase(knowledgeBaseId)
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    if (!kb || !area) return false
    
    currentSelection.value = {
      type: 'area',
      item: area,
      path: [kb.name, area.name]
    }
    
    return true
  }
  
  const selectKnowledgePoint = (knowledgeBaseId: string, areaId: string, pointId: string) => {
    const kb = findKnowledgeBase(knowledgeBaseId)
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    const point = findKnowledgePoint(knowledgeBaseId, areaId, pointId)
    if (!kb || !area || !point) return false
    
    currentSelection.value = {
      type: 'point',
      item: point,
      path: [kb.name, area.name, point.question || 'æ–°çŸ¥è¯†ç‚¹']
    }
    
    return true
  }
  
  const clearSelection = () => {
    currentSelection.value = {
      type: null,
      item: null,
      path: []
    }
  }
  
  // è¾…åŠ©å‡½æ•°
  const findKnowledgeBase = (id: string) => {
    return notesData.value.knowledgeBases.find(kb => kb.id === id)
  }
  
  const findKnowledgeArea = (knowledgeBaseId: string, areaId: string) => {
    const kb = findKnowledgeBase(knowledgeBaseId)
    return kb?.areas.find(area => area.id === areaId)
  }
  
  const findKnowledgePoint = (knowledgeBaseId: string, areaId: string, pointId: string) => {
    const area = findKnowledgeArea(knowledgeBaseId, areaId)
    return area?.knowledgePoints.find(point => point.id === pointId)
  }
  
  const markDirty = () => {
    isDirty.value = true
    startAutoSave()
  }
  
  const startAutoSave = () => {
    if (!settings.value.editor.autoSave) return
    
    if (autoSaveTimer.value) {
      clearTimeout(autoSaveTimer.value)
    }
    
    autoSaveTimer.value = setTimeout(() => {
      saveNotesData()
    }, settings.value.editor.autoSaveInterval)
  }
  
  const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }
  
  return {
    // çŠ¶æ€
    notesData: readonly(notesData),
    currentSelection: readonly(currentSelection),
    settings: readonly(settings),
    filter: readonly(filter),
    sidebarCollapsed: readonly(sidebarCollapsed),
    previewMode: readonly(previewMode),
    validationErrors: readonly(validationErrors),
    isDirty: readonly(isDirty),
    loading: readonly(loading),
    
    // è®¡ç®—å±æ€§
    filteredKnowledgeBases,
    totalStatistics,
    validationStatus,
    
    // æ“ä½œ
    loadNotesData,
    saveNotesData,
    createKnowledgeBase,
    createKnowledgeArea,
    createKnowledgePoint,
    updateKnowledgeBase,
    updateKnowledgeArea,
    updateKnowledgePoint,
    deleteKnowledgeBase,
    deleteKnowledgeArea,
    deleteKnowledgePoint,
    selectKnowledgeBase,
    selectKnowledgeArea,
    selectKnowledgePoint,
    clearSelection,
    markDirty
  }
})
```

---

## ğŸ“Š 6. ç»Ÿè®¡åˆ†ææ¨¡å—åŠŸèƒ½è§„æ ¼

### 6.1 æ¨¡å—æ¦‚è¿°

*å¾…å®Œæˆ*

---

## ğŸ”— 7. è·¨æ¨¡å—åŠŸèƒ½è§„æ ¼

### 7.1 æ•°æ®åŒæ­¥æœºåˆ¶

*å¾…å®Œæˆ*

### 7.2 è·¯ç”±å¯¼èˆªç³»ç»Ÿ

*å¾…å®Œæˆ*

### 7.3 å…¨å±€çŠ¶æ€ç®¡ç†

*å¾…å®Œæˆ*

---

**æ–‡æ¡£çŠ¶æ€**: ğŸ”„ **è¿›è¡Œä¸­**  
**å·²å®Œæˆæ¨¡å—**: ä»ªè¡¨ç›˜æ¨¡å—åŠŸèƒ½è§„æ ¼ âœ…  
**å½“å‰è¿›åº¦**: 1/6 æ ¸å¿ƒæ¨¡å—å®Œæˆ  
**ä¸‹ä¸€æ­¥**: çŸ¥è¯†ç®¡ç†æ¨¡å—åŠŸèƒ½è§„æ ¼è®¾è®¡ 

# Task-4.6: ç»Ÿè®¡åˆ†ææ¨¡å—åŠŸèƒ½è§„æ ¼è®¾è®¡

## ğŸ“Š ç°æœ‰å®ç°åˆ†æ

### 1. ä»£ç ç»“æ„åˆ†æ

#### StatisticsManagerç±»åˆ†æ (488è¡Œ)
```javascript
// ç°æœ‰æ¶æ„é—®é¢˜
class StatisticsManager {
    constructor() {
        this.charts = {};           // å›¾è¡¨å®ä¾‹ç®¡ç†æ··ä¹±
        this.chartColors = {};      // ç¡¬ç¼–ç é¢œè‰²é…ç½®
    }
    
    // æ ¸å¿ƒæ–¹æ³•èŒè´£æ··åˆ
    loadStatistics()              // ç»Ÿä¸€åŠ è½½å…¥å£
    renderProgressChart()         // å­¦ä¹ è¿›åº¦ç¯å½¢å›¾
    renderAccuracyChart()         // æ­£ç¡®ç‡è¶‹åŠ¿çº¿å›¾
    renderCategoryChart()         // åˆ†ç±»ç»Ÿè®¡æŸ±çŠ¶å›¾
    renderDetailedStats()         // HTMLå­—ç¬¦ä¸²æ‹¼æ¥æ¸²æŸ“
    getDetailedReport()           // æ•°æ®åˆ†æè®¡ç®—
    exportReport()                // JSONæŠ¥å‘Šå¯¼å‡º
    getCategoryStats()            // åˆ†ç±»æ•°æ®ç»Ÿè®¡
    getDifficultyStats()          // éš¾åº¦åˆ†å¸ƒç»Ÿè®¡
    getEfficiencyData()           // å­¦ä¹ æ•ˆç‡è®¡ç®—
}
```

#### æ ¸å¿ƒåŠŸèƒ½è¯†åˆ«
1. **æ•°æ®å¯è§†åŒ–**: Chart.jsé›†æˆï¼Œ3ç§å›¾è¡¨ç±»å‹
2. **ç»Ÿè®¡åˆ†æ**: å¤šç»´åº¦æ•°æ®åˆ†æå’Œè¶‹åŠ¿è®¡ç®—
3. **æŠ¥å‘Šç”Ÿæˆ**: è¯¦ç»†å­¦ä¹ æŠ¥å‘Šå’Œæ•°æ®å¯¼å‡º
4. **æ•ˆç‡è¯„ä¼°**: å­¦ä¹ æ•ˆç‡å’ŒæŒæ¡åº¦è¯„ä¼°

### 2. ç°æœ‰åŠŸèƒ½ç‰¹æ€§

#### å›¾è¡¨ç³»ç»Ÿ
- **å­¦ä¹ è¿›åº¦å›¾**: ç¯å½¢å›¾æ˜¾ç¤ºå·²æŒæ¡/éœ€å¤ä¹ /æ–°çŸ¥è¯†åˆ†å¸ƒ
- **æ­£ç¡®ç‡è¶‹åŠ¿**: åŒè½´çº¿å›¾æ˜¾ç¤º14å¤©æ­£ç¡®ç‡å’Œå¤ä¹ æ¬¡æ•°è¶‹åŠ¿  
- **åˆ†ç±»ç»Ÿè®¡**: æŸ±çŠ¶å›¾æ˜¾ç¤ºå„åˆ†ç±»çš„æ€»æ•°å’ŒæŒæ¡æƒ…å†µ

#### æ•°æ®åˆ†æç»´åº¦
```javascript
// å­¦ä¹ æ€»è§ˆç»Ÿè®¡
{
    totalKnowledge: æ€»çŸ¥è¯†ç‚¹æ•°,
    totalReviews: æ€»å¤ä¹ æ¬¡æ•°,
    overallAccuracy: æ•´ä½“æ­£ç¡®ç‡,
    mastered: å·²æŒæ¡çŸ¥è¯†ç‚¹,
    masteryRate: æŒæ¡ç‡ç™¾åˆ†æ¯”,
    avgDifficulty: å¹³å‡éš¾åº¦,
    totalMistakes: é”™é¢˜æ€»æ•°,
    efficiency: å­¦ä¹ æ•ˆç‡,
    avgTimeSpent: å¹³å‡ç”¨æ—¶
}

// åˆ†ç±»ç»Ÿè®¡åˆ†æ
categoryStats[category] = {
    total: æ€»æ•°,
    reviewed: å·²å¤ä¹ æ•°,
    correct: æ­£ç¡®æ•°,
    mastered: å·²æŒæ¡æ•°,
    accuracy: æ­£ç¡®ç‡,
    avgDifficulty: å¹³å‡éš¾åº¦
}

// éš¾åº¦åˆ†å¸ƒç»Ÿè®¡
difficultyStats[1-5] = {
    total: è¯¥éš¾åº¦æ€»æ•°,
    mastered: è¯¥éš¾åº¦å·²æŒæ¡æ•°
}
```

#### æ•ˆç‡è®¡ç®—ç®—æ³•
```javascript
// å­¦ä¹ æ•ˆç‡å…¬å¼
const efficiency = avgTimeSpent > 0 ? 
    Math.round((accuracy / Math.min(avgTimeSpent, 120)) * 100) : 0;
```

### 3. ç°æœ‰æ¶æ„é—®é¢˜

#### ğŸ”´ é«˜ä¼˜å…ˆçº§é—®é¢˜
- **èŒè´£æ··ä¹±**: å›¾è¡¨æ¸²æŸ“ã€æ•°æ®åˆ†æã€DOMæ“ä½œè€¦åˆåœ¨å•ä¸ªç±»ä¸­
- **ä¾èµ–æ··ä¹±**: å¼ºä¾èµ–window.storageManagerç­‰å…¨å±€å¯¹è±¡
- **UIç¡¬ç¼–ç **: HTMLæ¨¡æ¿é€šè¿‡å­—ç¬¦ä¸²æ‹¼æ¥ç”Ÿæˆï¼Œéš¾ä»¥ç»´æŠ¤
- **ç±»å‹å®‰å…¨ç¼ºå¤±**: æ— TypeScriptç±»å‹å®šä¹‰å’Œæ ¡éªŒ

#### ğŸŸ¡ ä¸­ä¼˜å…ˆçº§é—®é¢˜  
- **å›¾è¡¨ç®¡ç†**: æ‰‹åŠ¨ç®¡ç†Chart.jså®ä¾‹é”€æ¯å’Œé‡å»º
- **æ•°æ®æ›´æ–°**: æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—ï¼Œç¼ºä¹ç¼“å­˜ä¼˜åŒ–
- **å¯æ‰©å±•æ€§å·®**: æ–°å¢å›¾è¡¨ç±»å‹éœ€è¦ä¿®æ”¹æ ¸å¿ƒç±»

#### ğŸŸ¢ ä½ä¼˜å…ˆçº§é—®é¢˜
- **æ ·å¼è€¦åˆ**: å›¾è¡¨é¢œè‰²ç¡¬ç¼–ç ï¼Œæ— æ³•é€‚é…ä¸»é¢˜åˆ‡æ¢
- **æŠ¥å‘Šæ ¼å¼å•ä¸€**: ä»…æ”¯æŒJSONå¯¼å‡ºï¼Œç¼ºä¹PDF/Excelç­‰æ ¼å¼

---

## ğŸ¯ Vueé‡æ„æ¶æ„è®¾è®¡

### 1. ç»„ä»¶æ ‘æ¶æ„

```yaml
StatisticsView.vue                    # ç»Ÿè®¡åˆ†æé¡µé¢å®¹å™¨
â”œâ”€â”€ overview/                         # æ¦‚è§ˆæ¨¡å—
â”‚   â”œâ”€â”€ StatsSummary.vue             # å­¦ä¹ æ€»è§ˆå¡ç‰‡ç½‘æ ¼  
â”‚   â”œâ”€â”€ QuickActions.vue             # å¿«æ·æ“ä½œæŒ‰é’®ç»„
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ StatCard.vue             # ç»Ÿè®¡å¡ç‰‡ç»„ä»¶
â”‚       â””â”€â”€ TrendIndicator.vue        # è¶‹åŠ¿æŒ‡ç¤ºå™¨
â”œâ”€â”€ charts/                          # å›¾è¡¨æ¨¡å—
â”‚   â”œâ”€â”€ ChartsContainer.vue          # å›¾è¡¨å®¹å™¨å¸ƒå±€
â”‚   â”œâ”€â”€ ProgressChart.vue            # å­¦ä¹ è¿›åº¦ç¯å½¢å›¾
â”‚   â”œâ”€â”€ AccuracyChart.vue            # æ­£ç¡®ç‡è¶‹åŠ¿å›¾
â”‚   â”œâ”€â”€ CategoryChart.vue            # åˆ†ç±»ç»Ÿè®¡å›¾
â”‚   â”œâ”€â”€ DifficultyChart.vue          # éš¾åº¦åˆ†å¸ƒå›¾
â”‚   â”œâ”€â”€ EfficiencyChart.vue          # æ•ˆç‡é›·è¾¾å›¾
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ ChartWrapper.vue         # å›¾è¡¨åŒ…è£…å™¨
â”‚       â”œâ”€â”€ ChartControls.vue        # å›¾è¡¨æ§åˆ¶å™¨
â”‚       â””â”€â”€ ChartLegend.vue          # è‡ªå®šä¹‰å›¾ä¾‹
â”œâ”€â”€ analysis/                        # åˆ†ææ¨¡å—
â”‚   â”œâ”€â”€ AnalysisPanel.vue            # åˆ†æé¢æ¿å®¹å™¨
â”‚   â”œâ”€â”€ TrendAnalysis.vue            # è¶‹åŠ¿åˆ†æ
â”‚   â”œâ”€â”€ WeaknessAnalysis.vue         # è–„å¼±ç‚¹åˆ†æ
â”‚   â”œâ”€â”€ RecommendationEngine.vue     # æ¨èå¼•æ“
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ AnalysisCard.vue         # åˆ†æå¡ç‰‡
â”‚       â”œâ”€â”€ InsightItem.vue          # æ´å¯Ÿæ¡ç›®
â”‚       â””â”€â”€ RecommendationCard.vue   # æ¨èå¡ç‰‡
â”œâ”€â”€ reports/                         # æŠ¥å‘Šæ¨¡å—
â”‚   â”œâ”€â”€ ReportsSection.vue           # æŠ¥å‘ŠåŒºåŸŸ
â”‚   â”œâ”€â”€ DetailedReport.vue           # è¯¦ç»†æŠ¥å‘Šè¡¨æ ¼
â”‚   â”œâ”€â”€ ExportOptions.vue            # å¯¼å‡ºé€‰é¡¹
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ ReportTable.vue          # æŠ¥å‘Šè¡¨æ ¼
â”‚       â”œâ”€â”€ ExportButton.vue         # å¯¼å‡ºæŒ‰é’®
â”‚       â””â”€â”€ FilterControls.vue       # ç­›é€‰æ§åˆ¶å™¨
â””â”€â”€ common/                          # é€šç”¨ç»„ä»¶
    â”œâ”€â”€ LoadingSpinner.vue           # åŠ è½½åŠ¨ç”»
    â”œâ”€â”€ ErrorBoundary.vue            # é”™è¯¯è¾¹ç•Œ
    â””â”€â”€ EmptyState.vue               # ç©ºçŠ¶æ€æç¤º
```

### 2. Composablesè®¾è®¡

#### æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æŠ½ç¦»
```typescript
// 1. ç»Ÿè®¡æ•°æ®ç®¡ç†
export function useStatisticsData() {
  const statisticsStore = useStatisticsStore()
  
  const refreshData = async () => {
    await statisticsStore.fetchAllStatistics()
  }
  
  const getProgressData = computed(() => 
    statisticsStore.getProgressAnalysis()
  )
  
  const getAccuracyTrend = computed(() => 
    statisticsStore.getAccuracyTrendData()
  )
  
  return {
    refreshData,
    getProgressData,
    getAccuracyTrend,
    // ... å…¶ä»–ç»Ÿè®¡æ•°æ®
  }
}

// 2. å›¾è¡¨ç®¡ç†
export function useChartManager() {
  const charts = ref(new Map())
  
  const createChart = (canvasRef: Ref<HTMLCanvasElement>, config: ChartConfig) => {
    // Chart.jså®ä¾‹åˆ›å»ºå’Œç®¡ç†
  }
  
  const destroyChart = (chartId: string) => {
    // å›¾è¡¨é”€æ¯å’Œå†…å­˜æ¸…ç†
  }
  
  const updateChart = (chartId: string, newData: any) => {
    // å›¾è¡¨æ•°æ®æ›´æ–°
  }
  
  return { createChart, destroyChart, updateChart }
}

// 3. å­¦ä¹ åˆ†æç®—æ³•
export function useLearningAnalysis() {
  const analyzeWeaknesses = (data: KnowledgeData[]) => {
    // è–„å¼±ç‚¹æ£€æµ‹ç®—æ³•
    const weaknesses = data.filter(item => 
      item.accuracy < 0.6 || item.reviewCount < 3
    )
    return weaknesses.map(item => ({
      id: item.id,
      weakness: analyzeWeaknessType(item),
      severity: calculateSeverity(item),
      recommendation: generateRecommendation(item)
    }))
  }
  
  const calculateEfficiency = (reviews: ReviewRecord[]) => {
    // å­¦ä¹ æ•ˆç‡è®¡ç®—ä¼˜åŒ–
    const timeWeightedAccuracy = reviews.reduce((acc, review) => {
      const timeWeight = Math.min(review.timeSpent / 60, 1) // å½’ä¸€åŒ–åˆ°1åˆ†é’Ÿ
      return acc + (review.isCorrect ? 1 : 0) * timeWeight
    }, 0) / reviews.length
    
    return Math.round(timeWeightedAccuracy * 100)
  }
  
  return { analyzeWeaknesses, calculateEfficiency }
}

// 4. æŠ¥å‘Šç”Ÿæˆ
export function useReportGeneration() {
  const generateDetailedReport = () => {
    // è¯¦ç»†æŠ¥å‘Šæ•°æ®ç”Ÿæˆ
  }
  
  const exportToJSON = (data: any) => {
    // JSONæ ¼å¼å¯¼å‡º
  }
  
  const exportToPDF = (data: any) => {
    // PDFæ ¼å¼å¯¼å‡º(æ–°å¢åŠŸèƒ½)
  }
  
  const exportToExcel = (data: any) => {
    // Excelæ ¼å¼å¯¼å‡º(æ–°å¢åŠŸèƒ½)
  }
  
  return { generateDetailedReport, exportToJSON, exportToPDF, exportToExcel }
}

// 5. æ™ºèƒ½æ¨è
export function useRecommendationEngine() {
  const generateLearningRecommendations = (userData: UserLearningData) => {
    const recommendations = []
    
    // åŸºäºå­¦ä¹ æ¨¡å¼çš„æ¨è
    if (userData.accuracy < 0.7) {
      recommendations.push({
        type: 'focus',
        title: 'åŠ å¼ºåŸºç¡€ç»ƒä¹ ',
        description: 'å½“å‰æ­£ç¡®ç‡åä½ï¼Œå»ºè®®é‡ç‚¹å¤ä¹ åŸºç¡€çŸ¥è¯†ç‚¹',
        priority: 'high',
        actions: ['åŸºç¡€çŸ¥è¯†å¤ä¹ ', 'é™ä½éš¾åº¦ç»ƒä¹ ']
      })
    }
    
    // åŸºäºæ—¶é—´åˆ†å¸ƒçš„æ¨è
    if (userData.studyPattern.concentration < 0.5) {
      recommendations.push({
        type: 'timing',
        title: 'ä¼˜åŒ–å­¦ä¹ æ—¶é—´',
        description: 'å­¦ä¹ æ³¨æ„åŠ›åˆ†æ•£ï¼Œå»ºè®®è°ƒæ•´å­¦ä¹ æ—¶æ®µ',
        priority: 'medium',
        actions: ['é€‰æ‹©æœ€ä½³å­¦ä¹ æ—¶æ®µ', 'å‡å°‘å•æ¬¡å­¦ä¹ æ—¶é•¿']
      })
    }
    
    return recommendations
  }
  
  return { generateLearningRecommendations }
}

// 6. æ•°æ®ç¼“å­˜ä¼˜åŒ–
export function useStatisticsCache() {
  const cache = new Map()
  const cacheTimeout = 5 * 60 * 1000 // 5åˆ†é’Ÿç¼“å­˜
  
  const getCachedData = (key: string) => {
    const cached = cache.get(key)
    if (cached && Date.now() - cached.timestamp < cacheTimeout) {
      return cached.data
    }
    return null
  }
  
  const setCachedData = (key: string, data: any) => {
    cache.set(key, { data, timestamp: Date.now() })
  }
  
  return { getCachedData, setCachedData }
}
```

### 3. PiniaçŠ¶æ€ç®¡ç†

#### StatisticsStoreè®¾è®¡
```typescript
interface StatisticsState {
  // åŸå§‹æ•°æ®
  rawData: {
    knowledgeData: KnowledgeItem[]
    reviewHistory: ReviewRecord[]
    mistakeRecords: MistakeRecord[]
  }
  
  // è®¡ç®—ç»“æœç¼“å­˜
  computed: {
    progressData: ProgressData | null
    accuracyTrend: AccuracyTrendData | null
    categoryStats: CategoryStats | null
    difficultyStats: DifficultyStats | null
    efficiencyData: EfficiencyData | null
  }
  
  // UIçŠ¶æ€
  ui: {
    selectedTimeRange: TimeRange
    activeChart: string | null
    isLoading: boolean
    error: string | null
  }
  
  // ä¸ªæ€§åŒ–è®¾ç½®
  settings: {
    chartTheme: 'light' | 'dark'
    defaultTimeRange: TimeRange
    enableRealTimeUpdate: boolean
    exportFormat: 'json' | 'pdf' | 'excel'
  }
}

export const useStatisticsStore = defineStore('statistics', () => {
  const state = reactive<StatisticsState>({
    rawData: { knowledgeData: [], reviewHistory: [], mistakeRecords: [] },
    computed: { progressData: null, accuracyTrend: null, categoryStats: null, difficultyStats: null, efficiencyData: null },
    ui: { selectedTimeRange: 'week', activeChart: null, isLoading: false, error: null },
    settings: { chartTheme: 'light', defaultTimeRange: 'week', enableRealTimeUpdate: true, exportFormat: 'json' }
  })
  
  // Actions
  const fetchAllStatistics = async () => {
    state.ui.isLoading = true
    try {
      const [knowledge, reviews, mistakes] = await Promise.all([
        knowledgeService.getAllKnowledge(),
        reviewService.getReviewHistory(),
        mistakeService.getAllMistakes()
      ])
      
      state.rawData = { knowledgeData: knowledge, reviewHistory: reviews, mistakeRecords: mistakes }
      
      // è§¦å‘è®¡ç®—
      await computeAllStatistics()
    } catch (error) {
      state.ui.error = error.message
    } finally {
      state.ui.isLoading = false
    }
  }
  
  const computeAllStatistics = async () => {
    // ä½¿ç”¨Web Workerè¿›è¡Œå¤§é‡è®¡ç®—
    const worker = new Worker('/workers/statistics-worker.js')
    
    return new Promise((resolve) => {
      worker.postMessage(state.rawData)
      worker.onmessage = (e) => {
        state.computed = e.data
        resolve(e.data)
      }
    })
  }
  
  // Getters
  const getProgressAnalysis = computed(() => {
    if (!state.computed.progressData) return null
    
    return {
      ...state.computed.progressData,
      trends: calculateProgressTrends(state.rawData.reviewHistory)
    }
  })
  
  const getRecommendations = computed(() => {
    const { knowledgeData, reviewHistory } = state.rawData
    return generateSmartRecommendations(knowledgeData, reviewHistory)
  })
  
  return {
    // State
    ...toRefs(state),
    
    // Actions  
    fetchAllStatistics,
    computeAllStatistics,
    updateTimeRange: (range: TimeRange) => { state.ui.selectedTimeRange = range },
    
    // Getters
    getProgressAnalysis,
    getRecommendations
  }
})
```

### 4. TypeScriptç±»å‹å®šä¹‰

#### ç»Ÿè®¡åˆ†æç›¸å…³ç±»å‹
```typescript
// ç»Ÿè®¡æ•°æ®ç±»å‹
export interface ProgressData {
  mastered: number
  needReview: number
  newKnowledge: number
  totalCount: number
  masteryPercentage: number
  trends: {
    masteredChange: number
    reviewChange: number
  }
}

export interface AccuracyTrendData {
  labels: string[]
  datasets: {
    accuracy: number[]
    reviewCount: number[]
    difficulty: number[]
  }
  insights: TrendInsight[]
}

export interface CategoryStats {
  [category: string]: {
    total: number
    reviewed: number
    correct: number
    mastered: number
    accuracy: number
    avgDifficulty: number
    masteryRate: number
    weaknessLevel: 'low' | 'medium' | 'high'
  }
}

export interface EfficiencyData {
  overall: number
  byCategory: Record<string, number>
  byDifficulty: Record<number, number>
  trends: {
    last7Days: number[]
    last30Days: number[]
  }
  factors: {
    timeEfficiency: number
    accuracyConsistency: number
    difficultyProgression: number
  }
}

// åˆ†ææ´å¯Ÿç±»å‹
export interface TrendInsight {
  type: 'improvement' | 'decline' | 'stable' | 'breakthrough'
  title: string
  description: string
  confidence: number
  timeframe: string
  recommendations?: string[]
}

export interface WeaknessAnalysis {
  category: string
  weaknessType: 'knowledge_gap' | 'concept_confusion' | 'application_difficulty'
  severity: 1 | 2 | 3 | 4 | 5
  affectedTopics: string[]
  recommendations: {
    immediate: string[]
    longTerm: string[]
  }
  estimatedImprovementTime: string
}

// å›¾è¡¨é…ç½®ç±»å‹
export interface ChartConfig {
  type: 'doughnut' | 'line' | 'bar' | 'radar' | 'scatter'
  data: any
  options: any
  responsive: boolean
  maintainAspectRatio: boolean
  theme: 'light' | 'dark'
}

export interface ChartTheme {
  primary: string
  secondary: string
  success: string
  warning: string
  danger: string
  info: string
  background: string
  grid: string
  text: string
}

// æŠ¥å‘Šå¯¼å‡ºç±»å‹
export interface ExportOptions {
  format: 'json' | 'pdf' | 'excel' | 'csv'
  timeRange: TimeRange
  includeCharts: boolean
  includeDetails: boolean
  includeRecommendations: boolean
  template?: 'summary' | 'detailed' | 'academic'
}

export interface ReportData {
  metadata: {
    generatedAt: string
    timeRange: TimeRange
    version: string
    exportFormat: string
  }
  summary: ProgressData & EfficiencyData
  detailed: {
    categoryBreakdown: CategoryStats
    difficultyAnalysis: any
    weeknessAnalysis: WeaknessAnalysis[]
    insights: TrendInsight[]
  }
  recommendations: Recommendation[]
  rawData?: any // å¯é€‰çš„åŸå§‹æ•°æ®
}
```

### 5. æ–°å¢é«˜çº§åŠŸèƒ½

#### ğŸš€ æ™ºèƒ½åˆ†æå¼•æ“
```typescript
// å­¦ä¹ æ¨¡å¼è¯†åˆ«
export interface LearningPattern {
  studyConsistency: number      // å­¦ä¹ ä¸€è‡´æ€§ 0-1
  difficultyPreference: number  // éš¾åº¦åå¥½ 1-5
  timeDistribution: {           // æ—¶é—´åˆ†å¸ƒæ¨¡å¼
    peak: string               // æœ€ä½³å­¦ä¹ æ—¶æ®µ
    duration: number           // å¹³å‡å­¦ä¹ æ—¶é•¿
    frequency: number          // å­¦ä¹ é¢‘ç‡
  }
  strengthAreas: string[]      // å¼ºé¡¹é¢†åŸŸ
  improvementAreas: string[]   // å¾…æå‡é¢†åŸŸ
}

// æ™ºèƒ½æ¨èç®—æ³•
const generateAdaptiveRecommendations = (pattern: LearningPattern, currentStats: any) => {
  const recommendations = []
  
  // åŸºäºå­¦ä¹ æ¨¡å¼çš„ä¸ªæ€§åŒ–æ¨è
  if (pattern.studyConsistency < 0.6) {
    recommendations.push({
      type: 'habit',
      priority: 'high',
      title: 'å»ºç«‹è§„å¾‹å­¦ä¹ ä¹ æƒ¯',
      content: 'åŸºäºæ‚¨çš„å­¦ä¹ æ•°æ®ï¼Œå»ºè®®æ¯å¤©å›ºå®šæ—¶é—´æ®µè¿›è¡Œå¤ä¹ ',
      implementation: {
        suggestedTime: pattern.timeDistribution.peak,
        duration: Math.min(pattern.timeDistribution.duration * 1.2, 120),
        reminders: true
      }
    })
  }
  
  return recommendations
}
```

#### ğŸ“Š é«˜çº§æ•°æ®å¯è§†åŒ–
```vue
<!-- 3Då­¦ä¹ åœ°å›¾ç»„ä»¶ -->
<template>
  <div class="learning-map-container">
    <canvas ref="mapCanvas" class="learning-map"></canvas>
    <div class="map-controls">
      <MapControls @view-change="updateView" />
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import * as THREE from 'three'

// 3DçŸ¥è¯†ç‚¹å…³ç³»å›¾
const createKnowledgeMap = (knowledgeData) => {
  const scene = new THREE.Scene()
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
  const renderer = new THREE.WebGLRenderer()
  
  // æ ¹æ®æŒæ¡åº¦å’Œå…³è”åº¦åˆ›å»º3DèŠ‚ç‚¹
  knowledgeData.forEach((item, index) => {
    const geometry = new THREE.SphereGeometry(item.mastery * 0.5, 32, 32)
    const material = new THREE.MeshBasicMaterial({ 
      color: getColorByCategory(item.category),
      opacity: item.confidence
    })
    const sphere = new THREE.Mesh(geometry, material)
    
    // ä½ç½®åŸºäºçŸ¥è¯†ç‚¹å…³è”åº¦
    sphere.position.set(
      (item.relationships.x - 0.5) * 20,
      (item.relationships.y - 0.5) * 20,
      (item.relationships.z - 0.5) * 20
    )
    
    scene.add(sphere)
  })
  
  return { scene, camera, renderer }
}
</script>
```

#### ğŸ“ˆ é¢„æµ‹æ€§åˆ†æ
```typescript
// å­¦ä¹ è¶‹åŠ¿é¢„æµ‹
export function usePredictiveAnalysis() {
  const predictMasteryTimeline = (currentData: KnowledgeItem[], targetMastery: number) => {
    // ä½¿ç”¨çº¿æ€§å›å½’é¢„æµ‹æŒæ¡æ—¶é—´
    const learningRate = calculateLearningRate(currentData)
    const currentMastery = calculateCurrentMastery(currentData)
    
    const timeToTarget = Math.ceil((targetMastery - currentMastery) / learningRate)
    
    return {
      estimatedDays: timeToTarget,
      confidence: calculatePredictionConfidence(currentData),
      milestones: generateMilestones(currentMastery, targetMastery, timeToTarget),
      assumptions: [
        'åŸºäºå½“å‰å­¦ä¹ é¢‘ç‡å’Œæ•ˆç‡',
        'å‡è®¾å­¦ä¹ æ¨¡å¼ä¿æŒä¸€è‡´',
        'ä¸è€ƒè™‘å¤–éƒ¨å¹²æ‰°å› ç´ '
      ]
    }
  }
  
  const optimizeLearningPath = (weaknesses: WeaknessAnalysis[], timeConstraint: number) => {
    // åŸºäºè–„å¼±ç‚¹ä¼˜å…ˆçº§å’Œæ—¶é—´çº¦æŸä¼˜åŒ–å­¦ä¹ è·¯å¾„
    const optimizedPath = weaknesses
      .sort((a, b) => b.severity * b.impact - a.severity * a.impact)
      .slice(0, Math.floor(timeConstraint / 7)) // æ¯å‘¨å¤„ç†ä¸€ä¸ªä¸»è¦è–„å¼±ç‚¹
      
    return optimizedPath.map((weakness, index) => ({
      week: index + 1,
      focus: weakness.category,
      goals: weakness.recommendations.immediate,
      expectedImprovement: weakness.estimatedImprovementTime,
      resources: generateLearningResources(weakness)
    }))
  }
  
  return { predictMasteryTimeline, optimizeLearningPath }
}
```

### 6. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### ğŸš€ è®¡ç®—æ€§èƒ½ä¼˜åŒ–
```typescript
// Web Workerè®¡ç®—ä¼˜åŒ–
// /public/workers/statistics-worker.js
self.onmessage = function(e) {
  const { knowledgeData, reviewHistory, mistakeRecords } = e.data
  
  // å¤§é‡ç»Ÿè®¡è®¡ç®—åœ¨Workerçº¿ç¨‹ä¸­è¿›è¡Œ
  const results = {
    progressData: calculateProgress(knowledgeData),
    accuracyTrend: calculateAccuracyTrend(reviewHistory),
    categoryStats: calculateCategoryStats(knowledgeData),
    efficiencyData: calculateEfficiency(reviewHistory),
    predictions: generatePredictions(knowledgeData, reviewHistory)
  }
  
  self.postMessage(results)
}

// å¢é‡è®¡ç®—ä¼˜åŒ–
export function useIncrementalComputation() {
  const lastComputeTime = ref(0)
  const computedCache = ref(new Map())
  
  const incrementalUpdate = (newData: any[], lastUpdateTime: number) => {
    // åªè®¡ç®—å¢é‡æ•°æ®
    const incrementalData = newData.filter(item => 
      new Date(item.timestamp) > new Date(lastUpdateTime)
    )
    
    if (incrementalData.length === 0) {
      return computedCache.value
    }
    
    // åŸºäºç¼“å­˜ç»“æœæ›´æ–°
    const updatedResults = updateCachedResults(computedCache.value, incrementalData)
    computedCache.value = updatedResults
    lastComputeTime.value = Date.now()
    
    return updatedResults
  }
  
  return { incrementalUpdate }
}
```

#### ğŸ“± UIæ€§èƒ½ä¼˜åŒ–
```vue
<!-- è™šæ‹Ÿæ»šåŠ¨è¡¨æ ¼ -->
<template>
  <div class="virtual-table-container">
    <VirtualList
      :items="reportData"
      :item-height="50"
      :container-height="400"
      v-slot="{ item, index }"
    >
      <ReportTableRow :data="item" :index="index" />
    </VirtualList>
  </div>
</template>

<!-- å›¾è¡¨æ‡’åŠ è½½ -->
<template>
  <div class="charts-grid">
    <Suspense>
      <template #default>
        <AsyncChart
          v-for="chartConfig in visibleCharts"
          :key="chartConfig.id"
          :config="chartConfig"
          :lazy="true"
        />
      </template>
      <template #fallback>
        <ChartSkeleton />
      </template>
    </Suspense>
  </div>
</template>
```

### 7. ç”¨æˆ·ä½“éªŒå¢å¼º

#### ğŸ¨ äº¤äº’å¼å›¾è¡¨
```vue
<template>
  <div class="interactive-chart">
    <canvas
      ref="chartCanvas"
      @mousemove="handleMouseMove"
      @click="handleChartClick"
    ></canvas>
    
    <!-- æ•°æ®é’»å–é¢æ¿ -->
    <Transition name="slide">
      <div v-if="drillDownData" class="drill-down-panel">
        <h4>{{ drillDownData.title }}</h4>
        <DetailedBreakdown :data="drillDownData.details" />
      </div>
    </Transition>
  </div>
</template>

<script setup>
// å›¾è¡¨äº¤äº’é€»è¾‘
const handleChartClick = (event) => {
  const point = Chart.helpers.getRelativePosition(event, chart)
  const datasetIndex = chart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true)
  
  if (datasetIndex.length) {
    const { dataIndex, datasetIndex: dsIndex } = datasetIndex[0]
    drillDownData.value = generateDrillDownData(dsIndex, dataIndex)
  }
}
</script>
```

#### ğŸ“‹ æ™ºèƒ½ä»ªè¡¨æ¿
```vue
<!-- è‡ªå®šä¹‰ä»ªè¡¨æ¿ -->
<template>
  <div class="smart-dashboard">
    <DragDropGrid
      v-model:layouts="dashboardLayouts"
      :widgets="availableWidgets"
      @widget-add="addWidget"
      @widget-remove="removeWidget"
    >
      <template #widget="{ widget }">
        <Component
          :is="widget.component"
          v-bind="widget.props"
          @update="handleWidgetUpdate"
        />
      </template>
    </DragDropGrid>
    
    <FloatingActionButton @click="showWidgetLibrary = true">
      <PlusIcon />
    </FloatingActionButton>
  </div>
</template>

<script setup>
// å¯é…ç½®çš„å°éƒ¨ä»¶ç³»ç»Ÿ
const availableWidgets = ref([
  { id: 'progress-ring', name: 'å­¦ä¹ è¿›åº¦ç¯', component: ProgressRingWidget },
  { id: 'streak-counter', name: 'è¿ç»­å­¦ä¹ å¤©æ•°', component: StreakCounterWidget },
  { id: 'efficiency-gauge', name: 'æ•ˆç‡ä»ªè¡¨', component: EfficiencyGaugeWidget },
  { id: 'weakness-alert', name: 'è–„å¼±ç‚¹æé†’', component: WeaknessAlertWidget },
  { id: 'goal-tracker', name: 'ç›®æ ‡è·Ÿè¸ª', component: GoalTrackerWidget }
])
</script>
```

---

## ğŸ¯ å®æ–½ä¼˜å…ˆçº§

### Phase 1: æ ¸å¿ƒé‡æ„ (1-2å‘¨)
1. âœ… åŸºç¡€ç»„ä»¶æ¶æ„æ­å»º
2. âœ… PiniaçŠ¶æ€ç®¡ç†å®ç°  
3. âœ… æ ¸å¿ƒå›¾è¡¨ç»„ä»¶å¼€å‘
4. âœ… åŸºç¡€ç»Ÿè®¡è®¡ç®—è¿ç§»

### Phase 2: åŠŸèƒ½å¢å¼º (2-3å‘¨) 
1. ğŸ”„ æ™ºèƒ½åˆ†æç®—æ³•å®ç°
2. ğŸ”„ é«˜çº§å›¾è¡¨äº¤äº’åŠŸèƒ½
3. ğŸ”„ æŠ¥å‘Šç”Ÿæˆå’Œå¯¼å‡ºä¼˜åŒ–
4. ğŸ”„ æ€§èƒ½ä¼˜åŒ–å®æ–½

### Phase 3: ä½“éªŒä¼˜åŒ– (1-2å‘¨)
1. â³ é¢„æµ‹æ€§åˆ†æåŠŸèƒ½
2. â³ è‡ªå®šä¹‰ä»ªè¡¨æ¿
3. â³ 3Då¯è§†åŒ–(å¯é€‰)
4. â³ ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–

---

## ğŸ“Š æˆåŠŸæŒ‡æ ‡

### æŠ€æœ¯æŒ‡æ ‡
- **æ€§èƒ½æå‡**: ç»Ÿè®¡è®¡ç®—é€Ÿåº¦æå‡60%ä»¥ä¸Š
- **å“åº”é€Ÿåº¦**: å›¾è¡¨æ¸²æŸ“æ—¶é—´æ§åˆ¶åœ¨200mså†…
- **å†…å­˜ä¼˜åŒ–**: å¤§æ•°æ®é›†å¤„ç†å†…å­˜å ç”¨é™ä½40%
- **ä»£ç è´¨é‡**: TypeScriptè¦†ç›–ç‡è¾¾åˆ°95%ä»¥ä¸Š

### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡  
- **äº¤äº’æµç•…åº¦**: å›¾è¡¨äº¤äº’å»¶è¿Ÿå°äº100ms
- **å¯è§†åŒ–æ¸…æ™°åº¦**: æ•°æ®æ´å¯Ÿè¯†åˆ«æ•ˆç‡æå‡50%
- **åŠŸèƒ½å®Œæ•´æ€§**: æ”¯æŒ5ç§ä»¥ä¸Šçš„å¯¼å‡ºæ ¼å¼
- **ä¸ªæ€§åŒ–ç¨‹åº¦**: å¯é…ç½®ä»ªè¡¨æ¿æ”¯æŒ10+ç§å°éƒ¨ä»¶

---

*Task-4.6 ç»Ÿè®¡åˆ†ææ¨¡å—åŠŸèƒ½è§„æ ¼è®¾è®¡å®Œæˆ âœ…*
*æ€»è®¡6ä¸ªæ ¸å¿ƒæ¨¡å—é‡æ„æ–¹æ¡ˆåˆ¶å®šå®Œæ¯•ï¼Œè¿›å…¥å¼€å‘å®æ–½é˜¶æ®µ ğŸš€*

---

## ğŸ¨ UIç»„ä»¶ç­–ç•¥åº”ç”¨æ€»ç»“

### æ•´ä½“æ¶æ„ä¸‹çš„ç»„ä»¶ç­–ç•¥

åŸºäºç”¨æˆ·é€‰æ‹©çš„**æ··åˆç»„ä»¶ç­–ç•¥**ï¼Œæ•´ä¸ªMemorinç³»ç»Ÿçš„UIå®ç°å°†é‡‡ç”¨ä»¥ä¸‹åˆ†å±‚æ¶æ„ï¼š

```typescript
// ç³»ç»Ÿç»„ä»¶æ¶æ„å›¾
Memorinç³»ç»Ÿ
â”œâ”€â”€ ğŸ¨ è‡ªå®šä¹‰æ¯›ç»ç’ƒç»„ä»¶åº“ (70%)
â”‚   â”œâ”€â”€ GlassåŸºç¡€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ GlassCard        // æ‰€æœ‰å¡ç‰‡çš„åŸºç¡€
â”‚   â”‚   â”œâ”€â”€ GlassButton      // æ‰€æœ‰æŒ‰é’®çš„åŸºç¡€  
â”‚   â”‚   â”œâ”€â”€ GlassModal       // æ‰€æœ‰å¼¹çª—çš„åŸºç¡€
â”‚   â”‚   â”œâ”€â”€ GlassInput       // è¡¨å•è¾“å…¥çš„åŸºç¡€
â”‚   â”‚   â””â”€â”€ GradientHeader   // å¤´éƒ¨èƒŒæ™¯ç»„ä»¶
â”‚   â”œâ”€â”€ ä¸šåŠ¡ç‰¹è‰²ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ ReviewCard       // å¤ä¹ å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ KnowledgeCard    // çŸ¥è¯†ç‚¹å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ StatCard         // ç»Ÿè®¡å¡ç‰‡
â”‚   â”‚   â”œâ”€â”€ MistakeCard      // é”™é¢˜å¡ç‰‡
â”‚   â”‚   â””â”€â”€ ProgressBar      // è¿›åº¦æ¡ç»„ä»¶
â”‚   â””â”€â”€ é€šçŸ¥äº¤äº’ç»„ä»¶
â”‚       â”œâ”€â”€ NotificationToast // æ¶ˆæ¯é€šçŸ¥
â”‚       â””â”€â”€ ConfirmDialog     // ç¡®è®¤å¯¹è¯æ¡†
â”œâ”€â”€ ğŸ“š Element Plusç»„ä»¶ (25%)
â”‚   â”œâ”€â”€ æ•°æ®å±•ç¤º
â”‚   â”‚   â”œâ”€â”€ ElTable + glass-tableæ ·å¼
â”‚   â”‚   â””â”€â”€ ElPagination + glass-paginationæ ·å¼
â”‚   â”œâ”€â”€ è¡¨å•æ§ä»¶
â”‚   â”‚   â”œâ”€â”€ ElForm + éªŒè¯é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ ElSelect + glass-selectæ ·å¼
â”‚   â”‚   â”œâ”€â”€ ElDatePicker + glass-date-pickeræ ·å¼
â”‚   â”‚   â””â”€â”€ ElSwitch + glass-switchæ ·å¼
â”‚   â””â”€â”€ é«˜çº§æ§ä»¶
â”‚       â””â”€â”€ ElSlider + glass-slideræ ·å¼
â””â”€â”€ ğŸ”§ å·¥å…·ç±»ç»„ä»¶ (5%)
    â”œâ”€â”€ ElLoadingæŒ‡ä»¤
    â”œâ”€â”€ ElMessage (è‡ªå®šä¹‰æ ·å¼)
    â”œâ”€â”€ ElMessageBox (è‡ªå®šä¹‰æ ·å¼)
    â””â”€â”€ ElTooltip
```

### å„æ¨¡å—ç»„ä»¶åº”ç”¨ç­–ç•¥

| åŠŸèƒ½æ¨¡å— | è‡ªå®šä¹‰ç»„ä»¶ | Element Plusç»„ä»¶ | æ ·å¼ä¸€è‡´æ€§ä¿è¯ |
|---------|-----------|-----------------|---------------|
| **ä»ªè¡¨ç›˜** | StatCard, ActionButton, GradientHeader | - | 100%æ¯›ç»ç’ƒä¸»é¢˜ |
| **çŸ¥è¯†ç®¡ç†** | KnowledgeCard, GlassModal, GlassButton | ElTable, ElPagination | 95%ä¸€è‡´æ€§ |
| **å¤ä¹ ç³»ç»Ÿ** | ReviewCard, ProgressBar, GlassButton | ElForm | 100%æ ¸å¿ƒä½“éªŒä¿æŒ |
| **é”™é¢˜æœ¬** | MistakeCard, GlassCard | ElTable, ElDatePicker | 95%ä¸€è‡´æ€§ |
| **ç¬”è®°ç¼–è¾‘** | GlassCard, GlassModal | ElForm, ElSelect | 90%ä¸€è‡´æ€§ |
| **ç»Ÿè®¡åˆ†æ** | StatCard, å›¾è¡¨å®¹å™¨ | ElTable, ElDatePicker | 95%ä¸€è‡´æ€§ |

### æ ·å¼è¦†ç›–ç­–ç•¥æ‰§è¡Œ

```scss
// å…¨å±€Element Plusæ ·å¼è¦†ç›–
// styles/element-plus-theme.scss

// ç»Ÿä¸€çš„æ¯›ç»ç’ƒä¸»é¢˜å˜é‡
:root {
  --glass-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --glass-bg: rgba(255, 255, 255, 0.7);
  --glass-blur: blur(20px);
  --glass-border: 1px solid rgba(102, 126, 234, 0.1);
  --glass-radius: 15px;
  --glass-shadow: 0 4px 20px rgba(102, 126, 234, 0.08);
}

// Element Plusç»„ä»¶æ¯›ç»ç’ƒåŒ–
.el-table {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  border-radius: var(--glass-radius);
  border: var(--glass-border);
  box-shadow: var(--glass-shadow);
}

.el-button--primary {
  background: var(--glass-primary);
  border: none;
  backdrop-filter: var(--glass-blur);
}

.el-input__inner {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  border: 2px solid rgba(102, 126, 234, 0.2);
  border-radius: 12px;
}

// ç¡®ä¿æ‰€æœ‰Element Plusç»„ä»¶éƒ½èå…¥æ¯›ç»ç’ƒä¸»é¢˜
.el-select-dropdown,
.el-date-picker__header,
.el-pagination {
  background: var(--glass-bg);
  backdrop-filter: var(--glass-blur);
  border: var(--glass-border);
  border-radius: var(--glass-radius);
}
```

### å®æ–½æˆåŠŸæ ‡å‡†

**è§†è§‰ä¸€è‡´æ€§éªŒè¯ï¼š**
- âœ… ç”¨æˆ·æ— æ³•åŒºåˆ†è‡ªå®šä¹‰ç»„ä»¶å’ŒElement Plusç»„ä»¶
- âœ… æ‰€æœ‰ç»„ä»¶éƒ½å…·å¤‡æ¯›ç»ç’ƒæ•ˆæœ
- âœ… è‰²å½©æ–¹æ¡ˆå®Œå…¨ç»Ÿä¸€
- âœ… äº¤äº’åŠ¨ç”»ä¿æŒä¸€è‡´

**å¼€å‘æ•ˆç‡æå‡ï¼š**
- âœ… å¤æ‚è¡¨æ ¼åŠŸèƒ½ä½¿ç”¨Element Plusï¼Œå¼€å‘æ•ˆç‡æå‡60%
- âœ… è¡¨å•éªŒè¯é€»è¾‘ä½¿ç”¨Element Plusï¼Œå‡å°‘50%å¼€å‘æ—¶é—´
- âœ… è‡ªå®šä¹‰ç»„ä»¶å¤ç”¨ç‡è¾¾åˆ°80%ä»¥ä¸Š
- âœ… æ ·å¼ç»´æŠ¤æˆæœ¬é™ä½70%

**ç”¨æˆ·ä½“éªŒä¿è¯ï¼š**
- âœ… æ ¸å¿ƒä¸šåŠ¡æµç¨‹(å¤ä¹ ã€çŸ¥è¯†ç®¡ç†)ä¿æŒ100%åŸæœ‰ä½“éªŒ
- âœ… æ–°å¢åŠŸèƒ½(è¡¨æ ¼æ’åºã€åˆ†é¡µ)æå‡ç”¨æˆ·ä½“éªŒ
- âœ… å“åº”é€Ÿåº¦ä¸ä½äºåŸç³»ç»Ÿ
- âœ… è§†è§‰æ•ˆæœå®Œå…¨ä¿æŒåŸæœ‰ç‰¹è‰²

è¿™ç§æ··åˆç­–ç•¥ç¡®ä¿äº†åœ¨ä¿æŒMemorinç‹¬ç‰¹æ¯›ç»ç’ƒä¸»é¢˜çš„åŒæ—¶ï¼Œå……åˆ†åˆ©ç”¨æˆç†Ÿç»„ä»¶åº“çš„ä¼˜åŠ¿ï¼Œå®ç°äº†**ç¾è§‚æ€§**ä¸**æ•ˆç‡æ€§**çš„å®Œç¾å¹³è¡¡ã€‚