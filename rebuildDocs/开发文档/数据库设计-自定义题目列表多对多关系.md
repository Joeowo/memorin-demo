# 自定义题目列表数据库设计 - 多对多关系架构

> **设计目标**: 支持灵活的知识点组织和自定义题目列表配置  
> **核心特性**: 多对多关系，跨知识库/知识区组合  
> **设计时间**: 2025-01-08  

## 🎯 设计需求分析

### 核心需求
1. **跨域组合**: 题目列表可包含来自不同知识库、不同知识区的知识点
2. **多重归属**: 同一知识点可以隶属于多个知识区和多个知识库
3. **灵活配置**: 用户可以自由组合任意知识点创建自定义题目列表
4. **权限管理**: 支持用户级别的题目列表管理

### 现有模型问题
```sql
-- 当前模型的局限性
CREATE TABLE knowledge_points (
    id BIGINT PRIMARY KEY,
    knowledge_base_id BIGINT,  -- 🚫 单一归属，不支持多对多
    area_id BIGINT,            -- 🚫 单一归属，不支持多对多
    question TEXT,
    answer TEXT
);
```

## 🏗️ 新数据模型设计

### 核心实体分离

#### 1. 知识点核心表
```sql
-- 知识点核心信息表（不直接关联知识库和知识区）
CREATE TABLE knowledge_points (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '创建者用户ID',
    type ENUM('fill', 'choice') NOT NULL DEFAULT 'fill' COMMENT '题目类型',
    question TEXT NOT NULL COMMENT '问题内容',
    answer TEXT NOT NULL COMMENT '答案内容',
    explanation TEXT COMMENT '解释说明',
    difficulty TINYINT NOT NULL DEFAULT 3 COMMENT '难度等级 1-5',
    
    -- 选择题特有字段
    choice_type ENUM('single', 'multiple') COMMENT '选择题类型',
    options JSON COMMENT '选择题选项',
    correct_answer VARCHAR(50) COMMENT '正确答案',
    
    -- 扩展字段
    tags JSON COMMENT '标签数组',
    score DECIMAL(5,2) DEFAULT 0 COMMENT '分值',
    source VARCHAR(100) COMMENT '来源标识',
    
    -- 时间字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 索引
    INDEX idx_user_type (user_id, type),
    INDEX idx_difficulty (difficulty),
    INDEX idx_created_at (created_at),
    FULLTEXT INDEX ft_question_answer (question, answer)
) COMMENT='知识点核心表';
```

#### 2. 知识库表
```sql
-- 知识库表
CREATE TABLE knowledge_bases (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '所属用户ID',
    name VARCHAR(100) NOT NULL COMMENT '知识库名称',
    description TEXT COMMENT '知识库描述',
    icon VARCHAR(50) DEFAULT '📚' COMMENT '图标',
    color VARCHAR(20) DEFAULT '#667eea' COMMENT '主题色',
    category VARCHAR(50) COMMENT '分类',
    is_public BOOLEAN DEFAULT FALSE COMMENT '是否公开',
    sort_order INT DEFAULT 0 COMMENT '排序序号',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_category (user_id, category),
    INDEX idx_public (is_public),
    INDEX idx_sort (sort_order)
) COMMENT='知识库表';
```

#### 3. 知识区表
```sql
-- 知识区表
CREATE TABLE knowledge_areas (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '所属用户ID',
    name VARCHAR(100) NOT NULL COMMENT '知识区名称',
    description TEXT COMMENT '知识区描述',
    color VARCHAR(20) DEFAULT '#667eea' COMMENT '主题色',
    category VARCHAR(50) COMMENT '分类',
    parent_area_id BIGINT COMMENT '父知识区ID（支持层次结构）',
    sort_order INT DEFAULT 0 COMMENT '排序序号',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_category (user_id, category),
    INDEX idx_parent (parent_area_id),
    INDEX idx_sort (sort_order),
    FOREIGN KEY (parent_area_id) REFERENCES knowledge_areas(id) ON DELETE SET NULL
) COMMENT='知识区表';
```

### 关联关系表

#### 4. 知识点-知识库关联表
```sql
-- 知识点与知识库的多对多关联表
CREATE TABLE knowledge_point_base_relations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_point_id BIGINT NOT NULL COMMENT '知识点ID',
    knowledge_base_id BIGINT NOT NULL COMMENT '知识库ID',
    user_id BIGINT NOT NULL COMMENT '操作用户ID',
    
    -- 关联属性
    category VARCHAR(50) COMMENT '在该知识库中的分类',
    sort_order INT DEFAULT 0 COMMENT '在知识库中的排序',
    is_primary BOOLEAN DEFAULT FALSE COMMENT '是否为主要归属',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT COMMENT '关联创建者',
    
    -- 唯一约束和索引
    UNIQUE KEY uk_point_base (knowledge_point_id, knowledge_base_id),
    INDEX idx_base_points (knowledge_base_id),
    INDEX idx_point_bases (knowledge_point_id),
    INDEX idx_user_relations (user_id),
    INDEX idx_primary (is_primary),
    
    FOREIGN KEY (knowledge_point_id) REFERENCES knowledge_points(id) ON DELETE CASCADE,
    FOREIGN KEY (knowledge_base_id) REFERENCES knowledge_bases(id) ON DELETE CASCADE
) COMMENT='知识点-知识库关联表';
```

#### 5. 知识点-知识区关联表
```sql
-- 知识点与知识区的多对多关联表
CREATE TABLE knowledge_point_area_relations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    knowledge_point_id BIGINT NOT NULL COMMENT '知识点ID',
    knowledge_area_id BIGINT NOT NULL COMMENT '知识区ID',
    user_id BIGINT NOT NULL COMMENT '操作用户ID',
    
    -- 关联属性
    relevance_score DECIMAL(3,2) DEFAULT 1.0 COMMENT '相关度评分 0.0-1.0',
    sort_order INT DEFAULT 0 COMMENT '在知识区中的排序',
    is_primary BOOLEAN DEFAULT FALSE COMMENT '是否为主要归属',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT COMMENT '关联创建者',
    
    -- 唯一约束和索引
    UNIQUE KEY uk_point_area (knowledge_point_id, knowledge_area_id),
    INDEX idx_area_points (knowledge_area_id),
    INDEX idx_point_areas (knowledge_point_id),
    INDEX idx_user_relations (user_id),
    INDEX idx_relevance (relevance_score),
    INDEX idx_primary (is_primary),
    
    FOREIGN KEY (knowledge_point_id) REFERENCES knowledge_points(id) ON DELETE CASCADE,
    FOREIGN KEY (knowledge_area_id) REFERENCES knowledge_areas(id) ON DELETE CASCADE
) COMMENT='知识点-知识区关联表';
```

### 自定义题目列表

#### 6. 自定义题目列表表
```sql
-- 自定义题目列表表
CREATE TABLE custom_question_lists (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '创建用户ID',
    name VARCHAR(100) NOT NULL COMMENT '题目列表名称',
    description TEXT COMMENT '描述说明',
    
    -- 配置信息
    total_count INT DEFAULT 0 COMMENT '题目总数',
    estimated_time INT COMMENT '预估完成时间（分钟）',
    difficulty_level DECIMAL(3,1) COMMENT '平均难度等级',
    
    -- 生成配置（存储 question-list-generator 的配置）
    generation_config JSON COMMENT '生成配置JSON',
    source_summary JSON COMMENT '数据源摘要信息',
    
    -- 状态和权限
    status ENUM('draft', 'active', 'archived') DEFAULT 'active' COMMENT '状态',
    is_public BOOLEAN DEFAULT FALSE COMMENT '是否公开',
    is_template BOOLEAN DEFAULT FALSE COMMENT '是否为模板',
    
    -- 使用统计
    usage_count INT DEFAULT 0 COMMENT '使用次数',
    last_used_at TIMESTAMP NULL COMMENT '最后使用时间',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_user_status (user_id, status),
    INDEX idx_public_template (is_public, is_template),
    INDEX idx_usage (usage_count, last_used_at),
    INDEX idx_difficulty (difficulty_level)
) COMMENT='自定义题目列表表';
```

#### 7. 题目列表-知识点关联表
```sql
-- 题目列表与知识点的关联表
CREATE TABLE question_list_point_relations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    question_list_id BIGINT NOT NULL COMMENT '题目列表ID',
    knowledge_point_id BIGINT NOT NULL COMMENT '知识点ID',
    
    -- 在列表中的属性
    sequence_order INT NOT NULL COMMENT '在列表中的顺序',
    weight DECIMAL(3,2) DEFAULT 1.0 COMMENT '权重系数',
    source_type VARCHAR(50) COMMENT '来源类型：knowledge-base, knowledge-area, custom等',
    source_id BIGINT COMMENT '来源ID',
    
    -- 选择原因和标签
    selection_reason VARCHAR(200) COMMENT '选择原因',
    custom_tags JSON COMMENT '自定义标签',
    
    -- 元数据（从 question-list-generator 的 _meta 字段）
    generation_meta JSON COMMENT '生成时的元数据',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- 唯一约束和索引
    UNIQUE KEY uk_list_point (question_list_id, knowledge_point_id),
    INDEX idx_list_sequence (question_list_id, sequence_order),
    INDEX idx_point_lists (knowledge_point_id),
    INDEX idx_source (source_type, source_id),
    INDEX idx_weight (weight),
    
    FOREIGN KEY (question_list_id) REFERENCES custom_question_lists(id) ON DELETE CASCADE,
    FOREIGN KEY (knowledge_point_id) REFERENCES knowledge_points(id) ON DELETE CASCADE
) COMMENT='题目列表-知识点关联表';
```

## 📊 高级查询示例

### 1. 查询某个知识点的所有归属
```sql
-- 查询知识点的完整归属信息
SELECT 
    kp.id, kp.question,
    GROUP_CONCAT(DISTINCT kb.name) as knowledge_bases,
    GROUP_CONCAT(DISTINCT ka.name) as knowledge_areas
FROM knowledge_points kp
LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
LEFT JOIN knowledge_bases kb ON kpbr.knowledge_base_id = kb.id
LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id  
LEFT JOIN knowledge_areas ka ON kpar.knowledge_area_id = ka.id
WHERE kp.id = ?
GROUP BY kp.id;
```

### 2. 跨知识库查询知识点
```sql
-- 查询同时属于多个知识库的知识点
SELECT kp.*, COUNT(DISTINCT kpbr.knowledge_base_id) as base_count
FROM knowledge_points kp
JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
WHERE kpbr.knowledge_base_id IN (1, 2, 3)
GROUP BY kp.id
HAVING base_count > 1;
```

### 3. 自定义题目列表的复杂查询
```sql
-- 查询题目列表的详细信息和知识点分布
SELECT 
    cql.name as list_name,
    cql.total_count,
    COUNT(DISTINCT qlpr.knowledge_point_id) as actual_count,
    COUNT(DISTINCT kpbr.knowledge_base_id) as base_count,
    COUNT(DISTINCT kpar.knowledge_area_id) as area_count,
    AVG(kp.difficulty) as avg_difficulty
FROM custom_question_lists cql
JOIN question_list_point_relations qlpr ON cql.id = qlpr.question_list_id
JOIN knowledge_points kp ON qlpr.knowledge_point_id = kp.id
LEFT JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
LEFT JOIN knowledge_point_area_relations kpar ON kp.id = kpar.knowledge_point_id
WHERE cql.id = ?
GROUP BY cql.id;
```

## 🔧 数据迁移策略

### 从现有模型迁移
```sql
-- 迁移现有知识点数据
INSERT INTO knowledge_point_base_relations (knowledge_point_id, knowledge_base_id, user_id, is_primary)
SELECT id, knowledge_base_id, user_id, TRUE
FROM old_knowledge_points 
WHERE knowledge_base_id IS NOT NULL;

INSERT INTO knowledge_point_area_relations (knowledge_point_id, knowledge_area_id, user_id, is_primary)
SELECT id, area_id, user_id, TRUE  
FROM old_knowledge_points
WHERE area_id IS NOT NULL;
```

### 批量操作函数
```sql
-- 创建存储过程：添加知识点到多个知识库
DELIMITER $$
CREATE PROCEDURE AddPointToMultipleBases(
    IN p_point_id BIGINT,
    IN p_base_ids JSON,
    IN p_user_id BIGINT
)
BEGIN
    DECLARE i INT DEFAULT 0;
    DECLARE base_count INT;
    DECLARE current_base_id BIGINT;
    
    SET base_count = JSON_LENGTH(p_base_ids);
    
    WHILE i < base_count DO
        SET current_base_id = JSON_EXTRACT(p_base_ids, CONCAT('$[', i, ']'));
        
        INSERT IGNORE INTO knowledge_point_base_relations 
        (knowledge_point_id, knowledge_base_id, user_id, is_primary)
        VALUES (p_point_id, current_base_id, p_user_id, i = 0);
        
        SET i = i + 1;
    END WHILE;
END$$
DELIMITER ;
```

## 🎯 应用层适配

### 1. Question List Generator 适配
```typescript
// 适配新的多对多关系查询
interface QuestionSource {
  type: 'multiple-bases' | 'multiple-areas' | 'cross-domain' | 'custom-list';
  params: {
    knowledgeBaseIds?: number[];
    knowledgeAreaIds?: number[];
    customListId?: number;
    includeShared?: boolean;
  };
}

// 新的查询策略
class MultiDomainQuestionStrategy {
  async getQuestions(params: QuestionSource['params']): Promise<KnowledgePoint[]> {
    if (params.knowledgeBaseIds?.length > 0) {
      return this.getFromMultipleBases(params.knowledgeBaseIds);
    }
    if (params.customListId) {
      return this.getFromCustomList(params.customListId);
    }
    // ...其他策略
  }
  
  private async getFromMultipleBases(baseIds: number[]): Promise<KnowledgePoint[]> {
    // 查询属于任意指定知识库的知识点
    const query = `
      SELECT DISTINCT kp.*
      FROM knowledge_points kp
      JOIN knowledge_point_base_relations kpbr ON kp.id = kpbr.knowledge_point_id
      WHERE kpbr.knowledge_base_id IN (${baseIds.join(',')})
    `;
    return this.executeQuery(query);
  }
}
```

### 2. API 设计适配
```typescript
// RESTful API 设计
interface CustomQuestionListAPI {
  // 创建自定义题目列表
  POST: '/api/question-lists' {
    name: string;
    description?: string;
    knowledgePointIds: number[];
    generationConfig?: QuestionGenerationConfig;
  };
  
  // 添加知识点到列表（支持批量）
  POST: '/api/question-lists/{listId}/points' {
    knowledgePointIds: number[];
    sourceType?: string;
    sourceId?: number;
  };
  
  // 跨域查询知识点
  GET: '/api/knowledge-points/cross-domain' {
    knowledgeBaseIds?: number[];
    knowledgeAreaIds?: number[];
    tags?: string[];
    difficulty?: [number, number];
  };
}
```

## ⚡ 性能优化建议

### 1. 索引策略
- **复合索引**: 为常用查询组合创建复合索引
- **覆盖索引**: 为频繁查询创建覆盖索引
- **JSON索引**: 为JSON字段的常用查询路径创建索引

### 2. 查询优化
- **分页查询**: 大数据量时使用游标分页
- **缓存策略**: Redis缓存热门题目列表
- **预计算**: 定时计算题目列表的统计信息

### 3. 数据分片
```sql
-- 按用户ID分片
CREATE TABLE knowledge_points_shard_1 LIKE knowledge_points;
CREATE TABLE knowledge_points_shard_2 LIKE knowledge_points;
-- 分片路由：user_id % shard_count
```

---

**总结**: 这个多对多关系设计完全解耦了知识点与知识库/知识区的绑定关系，支持灵活的跨域组合和自定义题目列表配置。通过关联表的设计，实现了高度灵活的数据组织方式，同时保持了良好的查询性能和数据一致性。 